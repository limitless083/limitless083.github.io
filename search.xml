<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[LintCode-162. 矩阵归零]]></title>
    <url>%2FLintCode-162-%E7%9F%A9%E9%98%B5%E5%BD%92%E9%9B%B6%2F</url>
    <content type="text"><![CDATA[一、问题描述给定一个m×n矩阵，如果一个元素是0，则将其所在行和列全部元素变成0。 需要在原矩阵上完成操作。 二、解决方法1. O(mn)空间复杂度12345678910111213141516171819202122232425262728293031public class Solution &#123; /* * @param matrix: A lsit of lists of integers * @return: */ public void setZeroes(int[][] matrix) &#123; // write your code here int m = matrix.length; if (m == 0) return; int n = matrix[0].length; if (n == 0) return; boolean[] rows = new boolean[m]; boolean[] columns = new boolean[n]; for (int i = 0; i &lt; m; i++) &#123; for (int j = 0; j &lt; n; j++) &#123; if (matrix[i][j] == 0) &#123; rows[i] = true; columns[j] = true; &#125; &#125; &#125; for (int i = 0; i &lt; m; i++) &#123; for (int j = 0; j &lt; n; j++) &#123; if (rows[i] || columns[j]) &#123; matrix[i][j] = 0; &#125; &#125; &#125; &#125;&#125; 2. O(1)空间复杂度思路：借用matrix第0行，第0列，遍历剩下的行和列，若在剩下的行和列中出现0，则将所在行或列的第0个元素设置为0。即m[i][j] = 0 =&gt; m[0][j] = 0; m[i][0] = 0; 注意matrix除去0行0列可能没有元素，且m[0][0]的最终值要根据matrix[0][j]和matrix[i][0]处理，因此要对第0行和第0列进行特殊处理。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354public class Solution &#123; /* * @param matrix: A lsit of lists of integers * @return: */ public void setZeroes(int[][] matrix) &#123; // write your code here int m = matrix.length; if (m == 0) return; int n = matrix[0].length; if (n == 0) return; boolean isFirstRowZero = false; boolean isFirstColZero = false; for (int i = 0; i &lt; m; i++) &#123; if (matrix[i][0] == 0) &#123; isFirstColZero = true; &#125; &#125; for (int j = 0; j &lt; n; j++) &#123; if (matrix[0][j] == 0) &#123; isFirstRowZero = true; &#125; &#125; for (int i = 1; i &lt; m; i++) &#123; for (int j = 1; j &lt; n; j++) &#123; if (matrix[i][j] == 0) &#123; matrix[0][j] = 0; matrix[i][0] = 0; &#125; &#125; &#125; for (int i = 1; i &lt; m; i++) &#123; for (int j = 1; j &lt; n; j++) &#123; if (matrix[i][0] == 0 || matrix[0][j] == 0) &#123; matrix[i][j] = 0; &#125; &#125; &#125; if (isFirstColZero) &#123; for (int i = 0; i &lt; m; i++) &#123; matrix[i][0] = 0; &#125; &#125; if (isFirstRowZero) &#123; for (int j = 0; j &lt; n; j++) &#123; matrix[0][j] = 0; &#125; &#125; &#125;&#125;]]></content>
      <tags>
        <tag>算法</tag>
        <tag>LintCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LintCode-77.最长公共子序列]]></title>
    <url>%2FLintCode-77-%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%AD%90%E5%BA%8F%E5%88%97%2F</url>
    <content type="text"><![CDATA[一、问题描述给出两个字符串，找到最长公共子序列(LCS)，返回LCS的长度。 二、解决方法第1步，拆分问题： 对于输入序列X,Y 设S[i][j]表示X的前i位组成的序列以及Y的前j为组成的序列的公共子序列的长度 求S[len(X) - 1][len(Y) - 1] 状态：S[i][j] 第二步，求状态转移方程： S[i][j] = S[i-1][j-1] + 1, 若X[i] == Y[j] S[i][j] = max(S[i-1][j], S[i][j-1]), 若X[i] != Y[j] (由于不需要连续，则X[i]和Y[j]不相等也是有值的，而对于最长公共子串来说，不相等则等于0)。 第三步，求状态初始值： S[i][0] = X[i] == Y[0] ? 1 : 0; S[0][j] = X[0] == Y[j] ? 1 : 0; 第四步，根据递推得出结果 12345678910111213141516171819202122232425262728293031323334353637public class Solution &#123; /* * @param A: A string * @param B: A string * @return: The length of longest common subsequence of A and B */ public int longestCommonSubsequence(String A, String B) &#123; // write your code here char[] x = A.toCharArray(); char[] y = B.toCharArray(); int m = x.length; int n = y.length; int[][] dp = new int[m][n]; if (m == 0 || n == 0) return 0; // 状态定义 dp[i][j]表示A的第i位,B的第j位前的最长公共子序列 // 状态初始值 for (int i = 0; i &lt; m; i++) &#123; dp[i][0] = x[i] == y[0] ? 1 : 0; &#125; for (int j = 0; j &lt; n; j++) &#123; dp[0][j] = x[0] == y[j] ? 1 : 0; &#125; // 状态转移 for (int i = 1; i &lt; m; i++) &#123; for (int j = 1; j &lt; n; j++) &#123; int same = x[i] == y[j] ? 1 : 0; dp[i][j] = Math.max(dp[i-1][j-1] + same, Math.max(dp[i][j-1], dp[i-1][j])); &#125; &#125; return dp[m-1][n-1]; &#125;&#125; 三、相关问题LintCode-79.最长公共子串：状态转移方程： S[i][j] = X[i] == Y[j] ? S[i-1][j-1] + 1 : 0; 状态初始值： S[i][0] = X[i] == Y[0] ? 1 : 0; S[0][j] = X[0] == Y[j] ? 1 : 0; 123456789101112131415161718192021222324252627282930313233343536373839404142public class Solution &#123; /* * @param A: A string * @param B: A string * @return: the length of the longest common substring. */ public int longestCommonSubstring(String A, String B) &#123; // write your code here char[] x = A.toCharArray(); char[] y = B.toCharArray(); int m = x.length; int n = y.length; if (m == 0 || n == 0) return 0; int[][] dp = new int[m][n]; int max = 0; for (int i = 0; i &lt; m; i++) &#123; dp[i][0] = x[i] == y[0] ? 1 : 0; if (max &lt; dp[i][0]) &#123; max = dp[i][0]; &#125; &#125; for (int j = 0; j &lt; n; j++) &#123; dp[0][j] = x[0] == y[j] ? 1 : 0; if (max &lt; dp[0][j]) &#123; max = dp[0][j]; &#125; &#125; for (int i = 1; i &lt; m; i++) &#123; for (int j = 1; j &lt; n; j++) &#123; dp[i][j] = x[i] == y[j] ? dp[i-1][j-1] + 1 : 0; if (max &lt; dp[i][j]) &#123; max = dp[i][j]; &#125; &#125; &#125; return max; &#125;&#125;]]></content>
      <tags>
        <tag>算法</tag>
        <tag>动态规划</tag>
        <tag>LintCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode-416. Partition Equal Subset Sum]]></title>
    <url>%2FLeetCode-416-Partition-Equal-Subset-Sum%2F</url>
    <content type="text"><![CDATA[一、问题描述Given a non-empty array containing only positive integers, find if the array can be partitioned into two subsets such that the sum of elements in both subsets is equal. Note:Each of the array element will not exceed 100.The array size will not exceed 200.Example 1: Input: [1, 5, 11, 5] Output: true Explanation: The array can be partitioned as [1, 5, 5] and [11]. 二、解题方法 当数组和为奇数时，return false; 当数组和尾偶数时，则需要在数组中找到一个子集，使得子集的和尾sum/2 因此可以将题目归结为subset sum problem 代码： 12345678910111213141516171819202122232425262728293031323334353637class Solution &#123; public boolean canPartition(int[] nums) &#123; int sum = 0; for (int num : nums) &#123; sum += num; &#125; if (sum%2 != 0) &#123; return false; &#125; return isSubSum(nums, sum/2); &#125; public boolean isSubSum(int[] nums, int sum) &#123; boolean[][] dp = new boolean[nums.length + 1][sum + 1]; // 定义初始值 for (int i = 0; i &lt;= n; i++) &#123; dp[i][0] = true; //使用前i个元素组成的集合得到sum=0，当i=0是表示集合为空集 &#125; for (int j = 1; j &lt;= sum; j++) &#123; dp[0][j] = false; //使用空集得到sum=j &#125; // 根据状态转移方程递推 for (int i = 1; i &lt;= n; i++) &#123; for (int j = 1; j &lt;= m; j++) &#123; if (j &lt; nums[i-1]) &#123; dp[i][j] = dp[i-1][j]; &#125; else &#123; dp[i][j] = dp[i-1][j] || dp[i-1][j-nums[i-1]; &#125; &#125; &#125; return dp[nums.length][sum]; &#125;&#125; 三、 subset sum problem1.暴力法列出所有子集，看子集和是否有等于target的，时间复杂度为(2^n) 2.动态规划nums = [1,3,5,2,9], target = 15 第一步，拆分问题成子问题： 设 S[i][j]为：是否存在前i个元素组成的集合的子集和为j。 求S[len(nums)][sum] 状态：S[i][j] 第二步，求状态转移方程： S[i][j] = S[i-1][j] || S[i-1][j-nums[i-1]] {j &gt;= nums[i-1]} S[i][j] = S[i-1][j] {j &lt; nums[i-1]} 第三步，求状态初始值： S[0][j] = false {j = 1,2,…,sum} S[i][0] = true {i=0,1,2…,len(nums)} 第四步，根据递推得出结果 12345678910111213141516171819202122232425public boolean isSubSum(int[] nums, int sum) &#123; boolean[][] dp = new boolean[nums.length + 1][sum + 1]; int n = nums.length; int m = sum; // 定义初始值 for (int i = 0; i &lt;= n; i++) &#123; dp[i][0] = true; //使用前i个元素组成的集合得到sum=0，当i=0是表示集合为空集 &#125; for (int j = 1; j &lt;= sum; j++) &#123; dp[0][j] = false; //使用空集得到sum=j &#125; // 根据状态转移方程递推 for (int i = 1; i &lt;= n; i++) &#123; for (int j = 1; j &lt;= m; j++) &#123; if (j &lt; nums[i-1]) &#123; dp[i][j] = dp[i-1][j]; &#125; else &#123; dp[i][j] = dp[i-1][j] || dp[i-1][j-nums[i-1]; &#125; &#125; &#125; return dp[nums.length][sum];&#125; 时间复杂度：O(n*sum)，空间复杂度：O(n*sum) 3. 优化动态规划 O(sum)空间复杂度状态转移方程： S[i][j] = S[i-1][j] || S[i-1][j-nums[i-1]] {j &gt;= nums[i-1]} S[i][j] = S[i-1][j] {j &lt; nums[i-1]} 根据此状态转移方程来看，只需要存储两行即可，前一行作为i-1，当前行作为i，则S = new boolean[2][sum+1]，空间复杂度为O(m) 优化后的代码： 12345678910111213141516171819202122public boolean isSubSum(int[] nums, int sum) &#123; boolean[][] dp = new boolean[2][sum+1]; int n = nums.length; for (int j = 0; j &lt;= sum; j++) &#123; dp[0][j] = false; &#125; dp[0][0] = true; for (int i = 1; i &lt;= n; i++) &#123; for (int j = 0; j &lt;= sum; j++) &#123; if (j == 0) &#123; dp[i&amp;2][j] = true; //&amp;2表示对2快速取余 &#125; if (j &lt; nums[i-1]) &#123; dp[i&amp;2][j] = dp[(i+1)&amp;2][j]; &#125; else &#123; dp[i&amp;2][j] = dp[(i+1)&amp;2][j] || dp[(i+1)&amp;2][j-nums[i-1]]; &#125; &#125; &#125; return dp[n&amp;2][sum];&#125; 4. 获取所有子集根据dp矩阵，从dp[nums.length][sum]深度优先搜索即可 123456789101112131415161718192021222324252627282930public void dfs(int[] nums, boolean[][] dp, int i, int sum, ArrayList&lt;Integer&gt; q) &#123; // If sum becomes 0 if (i == 0) &#123; display(q); q.clear(); return; &#125; if (dp[i-1][sum]) &#123; ArrayList&lt;Integer&gt; b = new ArrayList&lt;&gt;(); b.addAll(q); //很关键, 因为这里可能会出现岔路, 只要在出现岔路的某个分支上加新的ArrayList就好。 dfs(nums, dp, i-1, sum, b); &#125; if (sum &gt;= nums[i-1]) &#123; if (dp[i-1][sum-nums[i-1]]) &#123; // ArrayList&lt;Integer&gt; b = new ArrayList&lt;&gt;(); // b.addAll(q); // b.add(nums[i-1]); // dfs(nums, dp, i-1, sum-nums[i-1], b); 在这里添加分叉也可以,两边都加也可以 q.add(nums[i-1]); dfs(nums, dp, i-1, sum, q); &#125; &#125;&#125;public void display(ArrayList&lt;Integer&gt; q) &#123; for (Integer i : q) &#123; System.out.print(i + &quot; &quot;); &#125; System.out.println();&#125;]]></content>
      <tags>
        <tag>LeetCode</tag>
        <tag>算法</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode-300-Longest Increasing Subsequence]]></title>
    <url>%2FLeetCode-300-Longest-Increasing-Subsequence%2F</url>
    <content type="text"><![CDATA[一、问题描述Given an unsorted array of integers, find the length of longest increasing subsequence. For example,Given [10, 9, 2, 5, 3, 7, 101, 18],The longest increasing subsequence is [2, 3, 7, 101], therefore the length is 4. Note that there may be more than one LIS combination, it is only necessary for you to return the length. Your algorithm should run in O(n2) complexity. Follow up: Could you improve it to O(n log n) time complexity? 二、解题方法1. O(n^2)将问题抽象为第K个数的上升序列有多长 状态转移方程：Fk=max{Fi+1 | a[i] &lt; a[k]} 代码： 1234567891011121314151617181920212223class Solution &#123; public int lengthOfLIS(int[] nums) &#123; int n = nums.length; if (n == 0) return 0; int[] dp = new int[n]; int result = 0; for (int i = 0; i &lt; n; i++) &#123; int max = 0; for (int j = 0; j &lt; i; j++) &#123; if (nums[j] &lt; nums[i]) &#123; if (max &lt; dp[j]) &#123; max = dp[j]; &#125; &#125; &#125; dp[i] = max + 1; if (dp[i] &gt; result) &#123; result = dp[i]; &#125; &#125; return result; &#125;&#125; 2.O(nlogn)使用binary search，用一个数组存储上升序列长度所对应的序列的最小最右边的值。 比如[3,5,7,2,4,6,1]，使用O(n^2)的方法会遍历k之前所有的i，而其实只要知道k之前上升序列最右边最小的数是否比当前k值要小。 第1次，k=0, len=0; dp[0]=3, 上升序列长度为1的最右边最小值为2 第2次，k=1, len=1; dp[1]=5, 上升序列长度为2的最右边最小值为5 第3次，k=2, len=2; dp[2]=7, 上升序列长度为3的最右边最小值为7 第4次，k=3, len=3; dp[0] &lt; 4 &lt; dp[1], 则上升序列为长度为2的最右边最小值为4， 更新长度为2的上升序列最右边的值，即dp[1] = 4 第5次，k=4, len=3; dp[1] &lt; 6 &lt; dp[2], 则上升序列长度为3的最右边最小的值为6,更新长度为3的上升序列最右边最小值，即dp[2] = 6 第6次，k=1, len=3; 1 &lt; dp[0], 则上升序列长度为1的最优最小值为1，dp[0] = 1 综上，只要知道a[k]在dp数组中的位置就可以了。 a[k] &lt; dp[0] dp[0]=a[k]; dp[i-1] &lt; a[k] &lt; dp[i] dp[i] = a[k] dp[len] &lt; a[k] dp[len] = a[k], len++ 代码： 12345678910111213141516171819202122class Solution &#123; public int lengthOfLIS(int[] nums) &#123; int n = nums.length; if (n == 0) return 0; int[] dp = new int[n]; int size = 0; for (int i = 0; i &lt; n; i++) &#123; int k = 0, l = size; while (k != l) &#123; int t = (k+l)/2; if (dp[t] &gt;= nums[i]) &#123; l = t; &#125; else &#123; k = t + 1; &#125; &#125; dp[k] = nums[i]; if (k == size) size++; //找到最后还是没找到则size+1 &#125; return size; &#125;&#125; 参考Youtube Longest Increasing Subsequence O(n^2) Youtube Longest Increasing Subsequence O(nlogn) LeetCode-300 Solution]]></content>
      <tags>
        <tag>LeetCode</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[动态规划]]></title>
    <url>%2F%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%2F</url>
    <content type="text"><![CDATA[一、定义 dynamic programming (also known as dynamic optimization) is a method for solving a complex problem by breaking it down into a collection of simpler subproblems, solving each of those subproblems just once, and storing their solutions. 动态规划是通过拆分问题，定义问题状态和状态之间的关系，使得问题能够以递推（或者说分治）的方式去解决。是用来求解最优化问题的一种方法，与贪心算法求得局部最优解不同，动态规划是求解全局最优解的。 二、求解步骤动态规划算法的4个步骤： 状态是什么 状态转移方程是什么 状态的初始值是什么 问题要求的最后答案是什么 构建状态转移方程的详细步骤： 构造问题所对应的过程。 思考过程的最后一个步骤，看看有哪些选择情况。(方便构建状态转移方程) 找到最后一步的子问题，确保符合“子问题重叠”，把子问题中不相同的地方设置为参数。 使得子问题符合“最优子结构”。 找到边界，考虑边界的各种处理方式。 确保满足“子问题独立”，一般而言，如果我们是在多个子问题中选择一个作为实施方案，而不会同时实施多个方案，那么子问题就是独立的。 考虑如何做备忘录。 分析所需时间是否满足要求。 写出转移方程式。 三、动态规划应用1. LeetCode-62 Unique paths A robot is located at the top-left corner of a m x n grid (marked ‘Start’ in the diagram below).The robot can only move either down or right at any point in time. The robot is trying to reach the bottom-right corner of the grid (marked ‘Finish’ in the diagram below).How many possible unique paths are there? 1234567891011121314public class Solution &#123; private int[][] path; //路径的数组 public int uniquePaths(int m, int n) &#123; path = new int[m][n]; return dp(m-1, n-1); &#125; public int dp(int m, int n) &#123; if (m == 0 || n == 0) return 1; //边界条件 if (path[m][n] != 0) return path[m][n]; path[m][n] = dp(m-1, n) + dp(m, n-1); //状态转移 return path[m][n]; &#125;&#125; 2. LeetCode-63 Unique paths2 Follow up for “Unique Paths”: Now consider if some obstacles are added to the grids. How many unique paths would there be? An obstacle and empty space is marked as 1 and 0 respectively in the grid. 1234567891011121314151617181920212223242526272829303132333435363738public class Solution &#123; public int uniquePathsWithObstacles(int[][] obstacleGrid) &#123; int m = obstacleGrid.length; if (m == 0) &#123; return 0; &#125; int n = obstacleGrid[0].length; if (n == 0) &#123; return 0; &#125; int[][] path = new int[m][n]; for (int i = 0; i &lt; m; i ++) &#123; for (int j = 0; j &lt; n; j++) &#123; if (obstacleGrid[i][j] == 1) &#123; path[i][j] = 0; &#125; else &#123; if (i==0 &amp;&amp;j==0) &#123; path[i][j] = 1; &#125; else&#123; if (i &gt; 0 &amp;&amp; j &gt; 0) &#123; path[i][j] = path[i-1][j] + path[i][j-1]; &#125; else &#123; if (i &gt; 0) &#123; path[i][j] = path[i-1][j]; &#125; else if (j &gt; 0)&#123; path[i][j] = path[i][j-1]; &#125; &#125; &#125; &#125; &#125; &#125; return path[m-1][n-1]; &#125;&#125; 3. LeetCode-64 Minimum Path Sum Given a m x n grid filled with non-negative numbers, find a path from top left to bottom right which minimizes the sum of all numbers along its path. 123456789101112131415161718192021public class Solution &#123; public int minPathSum(int[][] grid) &#123; if (grid.length == 0 || grid[0].length == 0) return 0; int m = grid.length; int n = grid[0].length; for (int i = 1; i &lt; m; i++) &#123; grid[i][0] += grid[i-1][0]; &#125; for (int j = 1; j &lt; n; j++) &#123; grid[0][j] += grid[0][j-1]; &#125; for (int i = 1; i &lt; m; i++) &#123; for (int j = 1; j &lt; n; j++) &#123; grid[i][j] += grid[i-1][j] &gt; grid[i][j-1] ? grid[i][j-1] : grid[i-1][j]; &#125; &#125; return grid[m-1][n-1]; &#125;&#125; LintCode-动态规划 参考什么是动态规划？动态规划的意义是什么？ 如何理解动态规划？ 五大常用算法之二：动态规划算法]]></content>
      <tags>
        <tag>算法</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode-200.Number of Islands]]></title>
    <url>%2FLeetCode-200-Number-of-Islands%2F</url>
    <content type="text"><![CDATA[一、问题描述Given a 2d grid map of ‘1’s (land) and ‘0’s (water), count the number of islands. An island is surrounded by water and is formed by connecting adjacent lands horizontally or vertically. You may assume all four edges of the grid are all surrounded by water. Example 1: 11110 11010 11000 00000 Answer: 1 Example 2: 11000 11000 00100 00011 Answer: 3 二、解题方法1. 使用union-find方法，将→和↓的相邻的1连接起来(16ms)相邻的1可以union，以↓和→的方式查找可以union的1，遍历所有的边。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576class Solution &#123; class UF &#123; private int[] idx; private int[] rank; private int count; public UF(int N) &#123; idx = new int[N]; rank = new int[N]; for (int i = 0; i &lt; N; i++) &#123; idx[i] = i; rank[i] = 1; &#125; count = N; &#125; private int getCount() &#123; return count; &#125; private int find(int p) &#123; if (idx[p] == p) &#123; return p; &#125; idx[p] = find(idx[p]); return idx[p]; &#125; private void union(int p, int q) &#123; int i = find(p); int j = find(q); if (i != j) &#123; // 两个set不同，根据秩合并 if (rank[i] &gt;= rank[j]) &#123; // 只有秩相同才加1 rank[i] = rank[i] == rank[j] ? rank[i] + 1 : rank[i]; idx[j] = i; &#125; else &#123; idx[i] = j; &#125; count--; &#125; &#125; &#125; public int numIslands(char[][] grid) &#123; int rows = grid.length; if (rows == 0) &#123; return 0; &#125; int columns = grid[0].length; UF uf = new UF(rows*columns); int oneCount = 0; for (int i = 0; i &lt; rows; i++) &#123; for (int j = 0; j &lt; columns; j++) &#123; if (grid[i][j] == '1') &#123; oneCount++; &#125; if (j &lt; columns - 1) &#123; if (grid[i][j] == '1' &amp;&amp; grid[i][j+1] == '1') &#123; uf.union(i*columns+j, i*columns+j+1); &#125; &#125; if (i &lt; rows - 1) &#123; if (grid[i][j] == '1' &amp;&amp; grid[i+1][j] == '1') &#123; uf.union(i*columns+j, (i+1)*columns+j); &#125; &#125; &#125; &#125; // 每连接一个1都会减一，但输入是包括0的，所以要用1的个数减去减少的量 return oneCount - (rows*columns - uf.getCount()); &#125;&#125; 2. 使用DFS方法(7ms)深度优先搜索，由某一点开始开始向↑↓←→遍历，每次遍历将所在点置成’0’，一条路走完岛屿数就加1，直到遍历完所有的。 1234567891011121314151617181920212223242526272829303132class Solution &#123; private int rows, columns; public int numIslands(char[][] grid) &#123; int count = 0; rows = grid.length; if (rows == 0) &#123; return 0; &#125; columns = grid[0].length; for (int i = 0; i &lt; rows; i++) &#123; for (int j = 0; j &lt; columns; j++) &#123; if (grid[i][j] == '1') &#123; dfs(grid, i, j, rows, columns); count++; &#125; &#125; &#125; return count; &#125; private void dfs(char[][] grid, int i, int j, int rows, int columns) &#123; if (i &lt; 0 || j &lt; 0 || i &gt;= rows || j &gt;= columns || grid[i][j] != '1') &#123; return ; &#125; grid[i][j] = '0'; dfs(grid, i, j - 1, rows, columns); dfs(grid, i - 1, j, rows, columns); dfs(grid, i, j + 1, rows, columns); dfs(grid, i + 1, j, rows, columns); &#125;&#125; 3. 使用BFS方法(11ms)12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970class Solution &#123; class Dot &#123; private int m; private int n; Dot(int m, int n) &#123; this.m = m; this.n = n; &#125; public int getM() &#123; return m; &#125; public int getN() &#123; return n; &#125; &#125; private int rows, columns; public int numIslands(char[][] grid) &#123; if (grid.length == 0) &#123; return 0; &#125; int count = 0; rows = grid.length; columns = grid[0].length; for (int i = 0; i &lt; rows; i++) &#123; for (int j = 0; j &lt; columns; j++) &#123; if (grid[i][j] == '1') &#123; bfs(grid, i, j); count++; &#125; &#125; &#125; return count; &#125; private void bfs(char[][] grid, int i, int j) &#123; grid[i][j] = '0'; Deque&lt;Dot&gt; queue = new ArrayDeque&lt;&gt;(); queue.add(new Dot(i, j)); while (!queue.isEmpty()) &#123; Dot element = queue.poll(); int m = element.getM(); int n = element.getN(); // uper if (m - 1 &gt;= 0 &amp;&amp; grid[m-1][n] == '1') &#123; queue.add(new Dot(m-1, n)); grid[m-1][n] = '0'; &#125; // down if (m + 1 &lt; rows &amp;&amp; grid[m+1][n] == '1') &#123; queue.add(new Dot(m+1, n)); // 必须立马标记为0，这样下一次出队列查询上下左右的时候不会一直加入队列中。 grid[m+1][n] = '0'; &#125; // left if (n - 1 &gt;= 0 &amp;&amp; grid[m][n-1] == '1') &#123; queue.add(new Dot(m, n-1)); grid[m][n-1] = '0'; &#125; // right if (n + 1 &lt; columns &amp;&amp; grid[m][n+1] == '1') &#123; queue.add(new Dot(m, n+1)); grid[m][n+1] = '0'; &#125; &#125; &#125;&#125;]]></content>
      <tags>
        <tag>LeetCode</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构-图]]></title>
    <url>%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%9B%BE%2F</url>
    <content type="text"><![CDATA[一、基本概念 顶点V：数据元素通常称为顶点。 边：顶点之间的无向连线 弧：顶点之间的有向连线 有向图：由一组顶点和一组有方向的边组成 无向图：由一组顶点和一组无方向的边组成 简单图：不存在顶点到其自身的边，且同一条边不重复。 边或弧很少的图称为稀疏图；边或弧较多的图称为稠密图。 度：一个顶点的度是与它相关联的边的条数 入度：有向图中到达顶点的边数。 出度：有向图中顶点出发的边数 网：带权值的图，分为有向网和无向网。 子图：由一幅图的所有边的子集（以及它们所依附的所有顶点）组成的图。 路径：由边顺序连接的一系列顶点。 路径长度：路径上边或弧的数目；网中为路径上的边或弧的权值之和。 环：至少含有一条边且起点和重点相同的路径。 简单路径：没有重复顶点的路径。 简单环：不含有重复顶点和边的环。 连通：当两个顶点之间存在一条连接双方的路径时，称一个顶点和另一个顶点是连通的。 连通图：如果从任意一个顶点都存在一条路径到达另一个任意顶点，即任一对顶点都存在路径，则成为连通图。 连通分量：无向图中的极大连通子图。 强连通图：在有向图中，任何一对顶点都存在路径 强连通分量：有向图中的极大连通子图。 生成树：连通图中一个极小连通子图，含有全部顶点，但只有足以构成树的n-1条边。 生成树森林：在连通图中每个连通分量，都可以得到一颗生成树，这些生成树构成生成森林。 二、图的存储结构1. 邻接矩阵使用二维数组表示顶点之间相邻关系的矩阵。 arc[i,j] = 1((v[i], v[j]) ∈E或 ∈E) 1()为指示器函数 2. 邻接表邻接表表示法类似于树的孩子链表表示法，用顺序结构存放节点，用链式结构存储弧。 3. 十字链表邻接表和逆邻接表的结合，方便同时求出度和入度。 4. 邻接多重表5. 边集数组利用两个一维数组，其中一个数组存储图中的顶点，另一个数组存储图中的边。在存储边的数组中，每个数组元素存储一条边的起点、终点和权值，在数组中的次序可以任意安排。 三、图的遍历 深度优先搜索(DFS) 广度优先搜索(BFS) 四、最小生成树基本概念图的生成树是它的一棵含有其所有顶点的无环连通子图。一副加权图的最小生成树是它的一棵权值（树中所有边的权值之和）最小的生成树。 当且仅当一幅含有V个节点的图G满足下列5个条件之一时，它就是一棵树： G有V-1条边且不含有环 G有V-1条边且是连通的 G是连通的，但删除任意一条边都会使它不再连通 G是无环图，但添加任意一条边都会产生一条环 G中的任意一对顶点之间仅润在一条简单路径。 Kruskal算法和Prim算法都是依据了上述5个条件来建立的。 Prim算法假设n个顶点分成两个集合U(包含已落在生成树上的结点)和V-U(尚未落在生成树上的顶点)，则在所有连通U中顶点和V-U中顶点的边中选取权值最小的边，就是最小生成树上的边，把对应的顶点添加到U中。具体做法和dijkstra算法类似, Prim算法是找到某个顶点的某条边的值最小，而dijkstra则是找到某个顶点的路径值最小，因此dijkstra需要累加。 优先队列主要有几个方法： add poll heapifyDown() heapifyUp() 时间复杂度：简易实现是O(|V|^2), 使用二叉堆实现是O(|E|log|V|) 代码：no heap Prim Prim’s Algorithm Minimum Spanning Tree Graph Algorithm Kruskal算法思想：为使生成树上边的权值之和最小，显然，其中每一条边的权值应该尽可能小。 操作：使用DisJointSet，先对所有顶点makeSet，然后排序所有边(时间复杂度为O(ElogE))，接着从小到大选择边，将边对应的两个顶点所在集合合并，若两个顶点所在集合一致则不加入，直到所有顶点在一个set里(即所有点都连通了)。 伪代码： 123456789101112sort(E)for vertex in V: disJointSet.makeSet(vertex.getId())for edge in E: # 如果disJointSet只剩一个就表明所有顶点已连通 if (disJointSet.getCount() == 1): break; v1 = edge.getV1() v2 = edge.getV2() if disJointSet.find(v1) != disJointSet.find(v2): result.add(edge) disJointSet.union(v1.getId(), v2.getId()) 五、最短路径Dijkstra算法单源到任意顶点的最短路， 使用binary heap和贪心算法做。 步骤： 找出从源点能够直接到达的顶点的所有路径，从中选出一条最短的路径； 以这条已选出的最短路径作为转发路径，找出经过这条路径转发后到达的其他能直接到达的顶点的路径，并从中选出一条最短的路径，更新从源点到节点路径的长度。 重复执行上述操作，直到找到所有顶点的最短路径为止。 时间复杂度：若不采用最小优先队列，时间复杂度为O(|V|^2)，否则为O(|E|log|V|). Youtube-Dijkstra’s Shortest Path Algorithm Folyd算法六、拓扑排序拓扑排序]]></content>
      <tags>
        <tag>算法</tag>
        <tag>数据结构</tag>
        <tag>图</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构-拓扑排序]]></title>
    <url>%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[1. 概念拓扑排序是对有向无环图的顶点的一种排序，它使得如果存在一条从顶点A到顶点B的路径，那么在排序中B出现在A的后面。 在图论中，由一个有向无环图的顶点组成的序列，当且仅当满足下列条件时，称为该图的一个拓扑排序：①每个顶点出现且只出现一次；②若A在序列中排在B的前面，则在图中不存在从B到A的路径。 只有DAG才有拓扑排序。通常，一个有向无环图可以有一个或多个拓扑排序序列。 2.算法Kahn算法 从DAG图中选择一个没有前驱即入度为0的顶点并输出(根据拓扑排序的定义来，若有入度，则在该顶点之前必然还有顶点要输出)。 从图中删除该顶点和所有以它为起点的有向边（把问题缩小） 重复前面两个步骤直到DAG图为空。 DFS DFS思路和Kahn算法类似，在深度优先搜索的过程中，最下面的顶点在Kahn算法中是被最后删除的，因此应该放在栈底，即应该第一个被放入栈中。（拓扑序列也要求最后的点应该放在最末尾，即栈底） 时间复杂度 当以邻接表存储时，时间复杂度为O(|V|+|E|) 当以邻接矩阵存储时，时间复杂度为O(|V|^2)。 代码实现：Topological Sort 3.如何检测有向环？ 使用Kahn算法，迭代删除入度为0的顶点和边所对应的顶点，若最后还有未遍历到的点，则有环。 使用深度优先搜索，一条深度优先搜索的路径上如果折回到已经遍历的点，则表示有环。具体可以加个white set表示没被访问过的，gray set表示正在访问的，black set表示已经访问的，但凡在dfs过程中遇到的点在gray set中就表示有环。 代码实现:有向环检测 4. 如何检测无向环 使用Disjoint算法，一开始将所有顶点放到不同的set中，然后遍历边，将边所对应的两个set合并，若出现有边对应的两个顶点在同一个set中，则表明有环。 使用深度优先搜索算法，将parent顶点传下去防止子顶点遍历parent顶点，只要在visited中已经被访问过，则表示有环。 代码实现:无向环检测 5. 有向环和无向环检测的区别区别的关键在于有向图是有方向的，无向环的检测方法都忽略了方向，若使用检测无向环的方式检测的话会导致判断错误，如下图所示。 6.参考：geeksforgeeks Topological sort Youtube-Topological Sort Graph Algorithm 相关问题并查集(union-find)在计算机科学中，并查集是一种树型的数据结构，用于处理一些不相交集合（Disjoint Sets）的合并及查询问题。 有一个联合-查找算法（union-find algorithm）定义了两个用于此数据结构的操作： Find：确定元素属于哪一个子集。它可以被用来确定两个元素是否属于同一子集。 Union：将两个子集合并成同一个集合。 由于支持这两种操作，一个不相交集也常被称为联合-查找数据结构（union-find data structure）或合并-查找集合（merge-find set）。其他的重要方法，MakeSet，用于建立单元素集合。有了这些方法，许多经典的划分问题可以被解决。 实现 加权(按秩):12345678910111213141516private void union(long data1, long data2) &#123; Node node1 = map.get(data1); Node node2 = map.get(data2); Node parent1 = findSet(node1); Node parent2 = findSet(node2); if (parent1.data != parent2.data) &#123; if (parent1.rank &gt;= parent2.rank) &#123; parent1.rank = parent1.rank == parent2.rank ? parent1.rank + 1 : parent1.rank; //按秩，两个集合秩相同才加1 parent2.parent = parent1; &#125; else &#123; parent1.parent = parent2; &#125; &#125;&#125; 路径压缩：12345678private Node findSet(Node node) &#123; if (node.parent == node) &#123; // base case return node; &#125; else &#123; node.parent = findSet(node.parent); //路径压缩 return node.parent; &#125;&#125; 复杂度 时间复杂度：O(α(n)) 空间复杂度：O(n) 完整代码 使用Node的并查集 使用数组的并查集]]></content>
      <tags>
        <tag>数据结构</tag>
        <tag>图</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[机器学习Stacking]]></title>
    <url>%2F%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0Stacking%2F</url>
    <content type="text"><![CDATA[简要总结Staking 是一种模型融合方法，以多个模型的对Training set 和 Test set的预测结果作为特征。 例如： Training set：X_train -&gt; y_trainTest set: X_test -&gt; y_test 将X_train和X_test同时用某个模型变换成X_train’和X_test’, 再使用 stacking 模型训练, 最终对X_test’进行预测得到结果y, 如下图所示: 代码1234567891011121314151617181920212223ntrain = train.shape[0]ntest = test.shape[0]SEED = 0 # for reproducibilityNFOLDS = 5 # set folds for out-of-fold predictionkf = KFold(ntrain, n_folds= NFOLDS, random_state=SEED)def get_oof(clf, X_train, y_train, X_test): oof_train = np.zeros((ntrain,)) oof_test = np.zeros((ntest,)) oof_test_skf = np.empty((NFOLDS, ntest)) for i, (train_index, test_index) in enumerate(kf): x_tr = x_train[train_index] y_tr = y_train[train_index] x_te = x_train[test_index] clf = clf.fit(x_tr, y_tr) oof_train[test_index] = clf.predict(x_te) oof_test_skf[i, :] = clf.predict(x_test) oof_test[:] = oof_test_skf.mean(axis=0) return oof_train.reshape(-1, 1), oof_test.reshape(-1, 1) 具体可以参考： Kaggle机器学习之模型融合（stacking）心得 A Kaggler’s Guide to Model Stacking in Practice 如何在 Kaggle 首战中进入前 10%]]></content>
      <tags>
        <tag>机器学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[统计学习方法笔记：感知机]]></title>
    <url>%2F%E7%BB%9F%E8%AE%A1%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%B3%95%E7%AC%94%E8%AE%B0%EF%BC%9A%E6%84%9F%E7%9F%A5%E6%9C%BA%2F</url>
    <content type="text"><![CDATA[感知机是二类分类的线性分类模型，属于判别模型。 感知机模型f(x) = sign(wx+b) 假设空间：{f|f(x)=wx+b} 感知机学习策略假设训练数据集是线性可分的，感知机学习的目标是求得一个能够将训练集正实例点和负实例点完全正确分开的分离超平面。为了找到这样的超平面，即确定模型参数w,b，需要确定一个学习策略，即定义经验损失函数并将损失函数极小化。 损失函数： 感知机学习算法感知机学习问题转化为求解损失函数的最优化问题，最优化的方法是随机梯度下降法。 具体算法： 原始形式 对偶形式 参考： 浅析感知机（一）–模型与学习策略 如何理解感知机学习算法的对偶形式？ 支持向量机中的函数距离和几何距离怎么理解？]]></content>
      <tags>
        <tag>机器学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[机器学习范数]]></title>
    <url>%2F%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E8%8C%83%E6%95%B0%2F</url>
    <content type="text"><![CDATA[监督机器学习问题无非就是“minimizeyour error while regularizing your parameters”，也就是在规则化参数的同时最小化误差。规则化是结构风险最小化策略的实现，是在经验风险上加一个正则化项(regularizer)或惩罚项(penalty term)。 机器学习中的范数一般指的是向量的范数。 L0范数，向量中非零元素的个数。用于产生稀疏性，但是在实际研究中很少用，因为L0范数很难优化求解，是一个NP-hard问题，因此更多情况下我们是使用L1范数 L1范数，为绝对值之和。用以产生稀疏性，因为它是L0范式的一个最优凸近似，容易优化求解 L2范数，向量元素绝对值的平方和再开方。L2范数更多是防止过拟合，并且让优化求解变得稳定很快速（这是因为加入了L2范式之后，满足了强凸）。 从贝叶斯的角度来看，正则化等价于对模型参数引入先验分布 。 对参数引入先验分布，降低模型复杂度。L1正则相当于假设参数w服从拉普拉斯分布；L2正则假设参数服从高斯分布。 参考： LR正则化与数据先验分布的关系 l0-Norm, l1-Norm, l2-Norm, … , l-infinity Norm L0,L1,L2范数及其应用 0范数、1范数、2范数有什么区别 机器学习中的范数规则化之（一）L0、L1与L2范数]]></content>
      <tags>
        <tag>机器学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[统计学习方法第一章笔记]]></title>
    <url>%2F%E7%BB%9F%E8%AE%A1%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%B3%95%E7%AC%AC%E4%B8%80%E7%AB%A0%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[一、统计学习方法三要素1.模型监督学习的目的在于学习一个由输入到输出的映射，这一映射由模型来表示。 模型属于由输入空间到输出空间的映射的集合，这个集合是假设空间。 概率模型：由条件概率分布P(Y|X)表示 非概率模型：由决策函数f(X)表示 假设空间：F = {f|Y=f(X)} 或 F = {P|P(Y|X)} 2.策略有了模型的假设空间，统计学习的目标在于从假设空间中选取最优模型，如何选择模型就是统计学习的策略。 损失函数：0-1损失函数；平方损失函数；绝对损失函数；对数损失函数等 风险函数：损失函数的期望 经验风险：模型关于训练数据集的平均损失 结构风险：当样本容量很小时，经验风险最小化学习的效果会导致过拟合。结构风险=经验风险+正则化项 监督学习常用两种策略： 经验风险最小化 结构风险最小化 3.算法最小二乘法、梯度下降法、牛顿法等 二、模型评估 训练误差 测试误差 过拟合：学习时选择的模型所包含的参数过多，导致在训练集表现良好而在测试集上表现很差的现象 三、模型选择1.正则化 结构风险最小化 范数 2.交叉验证 简单交叉验证 S折交叉验证 留一交叉验证 四、监督学习方法1.生成方法由数据学习联合概率分布P(X,Y)，然后求出条件概率分布P(Y|X)作为预测的模型，即生成模型： P(Y|X) = P(X,Y)/P(X) e.g. 朴素贝叶斯、隐马尔科夫模型 优点：收敛速度更快，适用于存在隐变量的情况 2.判别方法由数据直接学习决策函数f(X)或条件概率分布P(Y|X) e.g. k邻近法、感知机、决策树、逻辑斯谛回归模型、最大熵模型、支持向量机、提升方法、条件随机场等。 优点：准确率更高；便于对数据进行抽象和特征提取 五、监督学习种类1.分类问题 准确率 accuracy=(TP+TN)/(TP+TN+FP+FN) 精确率 P = TP/(TP+FP)：预测为正类的有多少是真正的正类 召回率 R=TP/(TP+FN):样本中正类样本多少标记正确 如何解释召回率与准确率？ 2.标注问题分类问题的推广 3.回归问题等价于函数拟合]]></content>
      <tags>
        <tag>机器学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前序遍历、中序遍历、后序遍历的递归和非递归实现方法]]></title>
    <url>%2F%E5%89%8D%E5%BA%8F%E9%81%8D%E5%8E%86%E3%80%81%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86%E3%80%81%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86%E7%9A%84%E9%80%92%E5%BD%92%E5%92%8C%E9%9D%9E%E9%80%92%E5%BD%92%E5%AE%9E%E7%8E%B0%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[二叉树有4种遍历方式：前序遍历、中序遍历、后序遍历和后序遍历方式。 前序遍历、中序遍历、后序遍历是深度优先搜索，适合用递归方式和栈实现。 层次遍历是广度优先搜索，适合用队列实现。 树的结点：12345678Node &#123; int data; Node left, right; Node(int data) &#123; this.data = data; left = right = null; &#125;&#125; 一、前序遍历 root -&gt; left_child -&gt; right_child 递归方式： 访问根节点 访问左子树 访问右子树 123456public void recursivePreorder(Node root) &#123; if (root == null) return; System.out.println(root.data); recursivePreorder(root.left); recursivePreorder(root.right);&#125; 非递归方式：方法1 push左子树直到叶子节点，边push边遍历 12345while (p != null) &#123; System.out.println(p.data); stack.push(p); p = p.left;&#125; 当Stack不为空时，弹出栈，若该节点有右子树，则push右子树的左子树直到叶子节点。重复1,2（根节点-&gt;遍历左子树-&gt;遍历右子树） 12p = stack.pop();p = p.right; 完整代码： 123456789101112131415public void iterativePreorder(Node root) &#123; ArrayDeque&lt;Node&gt; stack = new ArrayDeque&lt;&gt;(); Node p = root; while (!stack.isEmpty() || p != null) &#123; while (p != null) &#123; // 边push边遍历，之后要借助push进来的节点到右子树上 System.out.println(p.data); stack.push(p); p = p.left; &#125; p = stack.pop(); p = p.right; &#125;&#125; 方法2利用栈具有First-In-Last-Out的特点。 过程：循环{ pop出节点后，先push当前节点的右节点，再push当前节点的左节点 }。 完整代码： 12345678910111213141516public void iterativePreorder(Node root) &#123; if (root == null) return; Node p = null; stack.push(root); while (!stack.isEmpty()) &#123; p = stack.pop(); System.out.println(p.data); if (p.right != null) &#123; stack.push(p.right); &#125; if (p.left != null) &#123; stack.push(p.left); &#125; &#125;&#125; 二、中序遍历 left_child -&gt; root -&gt; right_child 递归方式： 访问左子树 访问根节点 访问右子树 123456public void recursiveInorder(Node root) &#123; if (root == null) return; recursivePreorder(root.left); System.out.println(root.data); recursivePreorder(root.right);&#125; 非递归方式： push左子树直到叶子节点 1234while (p != null) &#123; stack.push(p); p = p.left;&#125; 当Stack不为空时，弹出栈，遍历该节点。若该节点有右子树，则push右子树的左子树直到叶子节点。重复1，2 （遍历左子树-&gt;根节点-&gt;遍历右子树） 123p = stack.pop();System.out.println(p.data);p = p.right; 完整代码：123456789101112131415public void iterativeInorder(Node root) &#123; ArrayDeque&lt;Node&gt; stack = new ArrayDeque&lt;&gt;(); Node p = root; while (!stack.isEmpty() || p != null) &#123; while (p != null) &#123; stack.push(p); p = p.left; &#125; p = stack.pop(); System.out.println(p.data); p = p.right; //下次循环就开始遍历右子树了 &#125;&#125; 三、后序遍历 left_child -&gt; right_child -&gt; root 递归方式： 访问左子树 访问右子树 访问根节点 123456public void recursiveInorder(Node root) &#123; if (root == null) return; recursivePreorder(root.left); recursivePreorder(root.right); System.out.println(root.data);&#125; 非递归方式：方法1后序遍历的迭代方法比前两个要难一点，难点在于只有当右子树遍历完了以后才可以弹出根节点。 设置一个lastVisitNode来指示最后一次遍历到哪了，根据这个来判断弹出的元素的右子树有没有遍历过，只有遍历过才可以访问根节点。 push左子树直到叶子节点 1234while (p != null) &#123; stack.push(p); p = p.left;&#125; 当Stack非空时，peek栈顶，看栈顶节点的右子树是否全部访问过，如果访问过就弹出该栈顶节点并访问；如果没有访问过，则push右子树的左子树直到叶子节点。重复1,2。（遍历左子树-&gt;遍历右子树-&gt;根节点） 12345678p = stack.peek();if (p.right == null || p.right == lastVisitNode) &#123; stack.pop(); System.out.println(p.data); lastVisitNode = p;&#125; else &#123; p = p.right;&#125; 完整代码： 12345678910111213141516171819202122public void iterativePostorder(Node root) &#123; ArrayDeque&lt;Node&gt; stack = new ArrayDeque&lt;&gt;(); Node p = root; Node lastVisitNode = null; while (!stack.isEmpty() || p != null) &#123; while (p != null) &#123; stack.push(p); p = p.left; &#125; p = stack.peek(); if (p.right == null || p.right == lastVisitNode) &#123; stack.pop(); System.out.println(p.data); lastVisitNode = p; // p节点已经访问过了，要置null防止下次循环再遍历 p = null; &#125; else &#123; p = p.right; &#125; &#125;&#125; 方法2思路：后序遍历是左子树-&gt;右子树-&gt;根节点，倒过来则可以是根节点-&gt;右子树-&gt;左子树，是前序遍历的变形。然后将这样的遍历压到另一个栈中，再弹出来。这样空间复杂度会由O(logn)变大为O(n)。 完整代码：123456789101112131415161718public void iterativePostorder3(Node root) &#123; ArrayDeque&lt;Node&gt; stack1 = new ArrayDeque&lt;&gt;(); ArrayDeque&lt;Node&gt; stack2 = new ArrayDeque&lt;&gt;(); Node p = root; while (!stack1.isEmpty() || p != null) &#123; while (p != null) &#123; stack2.push(p); stack1.push(p); p = p.right; &#125; p = stack1.pop(); p = p.left; &#125; while (!stack2.isEmpty()) &#123; System.out.println(stack2.pop().data); &#125;&#125; 四、层次遍历 level1 -&gt; level2 -&gt; … (每一层从左到右) 层次遍历是广度优先搜索，需要使用队列，利用队列的First-In-First-Out的特点，每一层逐个按左孩子右孩子的顺序往队列里添加。 12345678910111213141516public void levelOrder(Node root) &#123; ArrayDeque&lt;Node&gt; queue = new ArrayDeque&lt;&gt;(); if (root == null) return; Node p = null; queue.offer(root); while (!queue.isEmpty()) &#123; p = queue.poll(); System.out.println(p.data); if (p.left != null) &#123; queue.offer(p.left); &#125; if (p.right != null) &#123; queue.offer(p.right); &#125; &#125;&#125; 五、总结 一定要记住树的定义本身是一种递归的方式定义的。因此左子树和右子树都可以看成一棵树，实现各种算法的时候可以根据这点来考虑。左孩子是左子树的根节点，右孩子是右子树的根节点。 A tree data structure can be defined recursively (locally) as a collection of nodes (starting at a root node), where each node is a data structure consisting of a value, together with a list of references to nodes (the “children”), with the constraints that no reference is duplicated, and none points to the root. 递归一定要从大局入手，不要考虑细节，比如前序遍历，大局就是先访问根节点，再访问左子树，再访问右子树，可以立马能写出来代码。 广度优先搜索一般使用队列；深度优先搜索一般使用栈和递归方式。 所有代码见github-tree 参考Iterative Preorder Traversal Inorder Tree Traversal without Recursion Iterative Postorder Traversal | Set 2 (Using One Stack) 二叉树前序、中序、后序遍历非递归写法的透彻解析 二叉树的层次遍历]]></content>
      <tags>
        <tag>算法</tag>
        <tag>树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Windows Server 2016 计划任务优先级更改方法]]></title>
    <url>%2FWindows-Server-2016-%E8%AE%A1%E5%88%92%E4%BB%BB%E5%8A%A1%E4%BC%98%E5%85%88%E7%BA%A7%E6%9B%B4%E6%94%B9%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[遇到的问题 以交互方式运行程序的IO速度远快于以计划任务运行程序的IO速度 原因 计划任务默认的优先级为低于正常，IO速度会下降。 解决方式打开任务计划程序 创建任务 创建完成后，导出该任务为xml文件 编辑修改该xml文件的&lt;Priority&gt;7&lt;/Priority&gt;，将7改成正常的优先级(4-6)。优先级4将会使计划任务有和交互式程序一样的IO优先级和内存优先级；优先级5和6则会有较低的内存优先级。 在任务计划程序中删除刚才创建的任务。 在任务计划程序中导入修改好的任务xml文件创建计划任务。 参考Is there any way for a win2k8 scheduled task to have normal priority IO? TaskSettings.Priority]]></content>
      <tags>
        <tag>Windows</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[如何寻找N范围内的所有质数]]></title>
    <url>%2F%E5%A6%82%E4%BD%95%E5%AF%BB%E6%89%BEN%E8%8C%83%E5%9B%B4%E5%86%85%E7%9A%84%E6%89%80%E6%9C%89%E8%B4%A8%E6%95%B0%2F</url>
    <content type="text"><![CDATA[一、基本概念质数(prime number):指在大于1的自然数中，除了1和该数自身外，无法被其他自然数整除的数。 合数(composite number)：指在大于1的自然数中，因数除了1和其本身外具有另一因数的正整数。 0和1既不是质数也不是合数。 孪生素数：是指一对素数，它们之间相差2。例如3和5，5和7，11和13，10016957和10016959等等都是孪生素数。 约数：假如整数n除以m，结果是无余数的整数，那么我们称m就是n的约数。 自然数 N 的全部正约数个数以d(n)表示，若N=a1^n1 *a2^n2 …，其中a1,a2为质数，则d(n) = (n1+1)(n2+1)… ，对a1可以取a1^0 可以取 a1^1, a1^2…,所有a1因子有n1+1中选择，其他因子类似。 二、相关定理素数定理素数定理用于估计素数个数。对正整数x，小于等于x范围内的素数的个数π(x)≈x/lnx，误差一般不超过±15%。x越大误差越小。 算术基本定理算术基本定理，又称为正整数的唯一分解定理。每个大于1的自然数均可写为质数的积，而且这些素因子按大小排列之后，写法仅有一种方式。 三、测试素数1. 试除法（确定性算法）测试n是否为素数的最基本方法为试除法。此一程序将n除以每个大于1且小于等于n的平方根之整数m。若存在一个相除为整数的结果，则n不是素数；反之则是个素数。实际上，若n=ab是个合数（其中a与b≠1），则其中一个约数a或b必定至大为sqrt(n)。 2. 埃拉托斯特尼筛法埃拉托斯特尼筛法（sieve of Eratosthenes），简称埃氏筛，是一种简单且年代久远的筛法，用来找出一定范围内所有的素数。 所使用的原理是从2开始，将每个素数的各个倍数，标记成合数。一个素数的各个倍数，是一个差为此素数本身的等差数列。此为这个筛法和试除法不同的关键之处，后者是以素数来测试每个待测数能否被整除。 伪代码: 1234567891011Input: an integer n &gt; 1Let A be an array of Boolean values, indexed by integers 2 to n,initially all set to true.for i = 2, 3, 4, ..., not exceeding √n: if A[i] is true: for j = i^2, i^2+i, i^2+2i, i^2+3i, ..., not exceeding n: A[j] := falseOutput: all i such that A[i] is true. Java 代码： 1234567891011121314public boolean[] primes(int num) &#123; boolean[] isPrime = new boolean[num + 1]; for (int i = 2; i &lt;= num; i++) &#123; isPrime[i] = true; &#125; for (int i = 2; i*i &lt;= num; i++) &#123; if (isPrime[i]) &#123; for (int j = i*i; j &lt;= num; j+=i) &#123; isPrime[j] = false; &#125; &#125; &#125; return isPrime;&#125; 时间复杂度：O(nloglogn)。此种筛法会重复删除某个合数，比如30=2*15=3*10=5*6，会重复筛掉3次，这样会导致速度慢。解决方法是按照一个数的最小素因子筛选。 3. 欧拉筛法（线性筛法）基本思想：按照一个数的的最小素因子筛选。每个合数一定有几个素因子，一定有最小的一个素因子。最大素因子是唯一的，所以合数只会被它自己唯一的最素因子筛掉一次。 过程：当前数字是n=p1^a * p2^b * p3^c (p1 &lt; p2 &lt; p3)，一次循环筛掉小于等于p1素因子（根据构建的素数表）乘以n得到的数。比如p1之前有pi,pj和pk三个素数，则此次循环筛掉的数有 pi*n, pj*n, pk*n 和 p1*n。 从图上我们看到，第一列筛掉的是最小素因子是2的数，第二列筛掉的是最小素因子为3的数，依次类推，可以把所有的合数都筛掉，不会重复筛选。 比如30=2*15=3*10=5*6仅仅会根据15*2去筛掉。 Java 代码： 123456789101112131415161718192021public boolean[] primes(int num) &#123; boolean[] isPrime = new boolean[num + 1]; int[] primes = new int[num]; int cnt = 0; for (int i = 2; i &lt;= num; i++) &#123; isPrime[i] = true; &#125; for (int i = 2; i &lt;= num; i++) &#123; if (isPrime[i]) &#123; primes[cnt++] = i; &#125; for (int j = 0; j &lt; cnt &amp;&amp; i*primes[j] &lt;= num; j++) &#123; isPrime[i*primes[j]] = false; if (i % primes[j] == 0) &#123; break; &#125; &#125; &#125; return isPrime;&#125; 时间复杂度：O(n) 代码见：github max prime 4. 米勒拉宾检验（随机性算法）参考：求质数算法的 N 种境界1-试除法和初级筛法 线性筛法 wiki-Sieve of Eratosthenes 这只菜鸟总算搞懂了线性筛素数 数论——筛法求素数 线性筛法求素数 Sieve of Sundaram]]></content>
      <tags>
        <tag>算法</tag>
        <tag>数论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构-哈希表]]></title>
    <url>%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%93%88%E5%B8%8C%E8%A1%A8%2F</url>
    <content type="text"><![CDATA[一、前言查找的实质是确定关键码等于给定值的记录在查找集合中的存储位置。 由于存储位置与关键码之间不存在确定的对应关系，一般的查找方法是通过比较的方法找到要查询的记录。 若存储位置与关键码之间存在对应关系，则可以通过计算的方式来查找，这种方式就是散列技术. 二、基本概念 若关键字为 key，则其值存放在H(key)的存储位置上。由此，不需比较便可直接取得所查记录。称这个对应关系H为散列函数，按这个思想建立的表为散列表，也叫哈希表。 散列过程：①存储记录，通过H(key)计算记录的散列地址，并按此地址存储记录；②查找记录，通过同样的H(key)计算记录的散列地址，按此地址访问该记录。 现实中，对不同的关键字可能得到同一散列地址，即key1≠key2，而H(kye1)=H(key2)，则产生了冲突，针对冲突有多种解决方式。 哈希表的实现主要需要解决两个问题，哈希函数和冲突处理。 三、散列函数(哈希函数)哈希查找第一步就是使用哈希函数将键映射成索引。这种映射函数就是哈希函数。如果我们有一个保存0-M数组，那么我们就需要一个能够将任意键转换为该数组范围内的索引（0~M-1）的哈希函数。哈希函数需要易于计算并且能够均匀分布所有键。 1. 直接定址法取关键字或关键字的某个线性函数值为散列地址。H(key) = a * k + b 2. 除留余数法取关键字被某个不大于散列表表长m的数p除后所得的余数为散列地址。H(key) = key % p, p &lt;= m.其中p一般选取为小于或等于散列表长度m的某个最大素数。这种方法计算简单且效果好，因此最常用。 3. 数字分析法在已知所有关键码，并对每一位的取值分布有所分析的情况下，可以取关键字的若干数位（分布均匀的数位）组合成为哈希地址。 4. 平方取中法取关键字平方后的中间几位为哈希地址。通常在选定哈希函数时不一定能知道关键字的全部情况，取其中的哪几位也不一定合适，而一个数平方后的中间几位数和数的每一位都相关，由此使随机分布的关键字得到的哈希地址也是随机的。取的位数由表长决定。 5. 折叠法将关键码从左到右分割成位数相等（根据散列表长的位数决定）的若干部分，然后取他们的叠加并舍弃最高进位后的结果为哈希地址。 叠加的方法有两种： 移位叠加：将各部分相加。 间界叠加：从一端到另一端沿各部分分界来回折叠后相加，其中奇数段为正序，偶数段为倒序。 如key=25346358705，散列表长为三位数，则可以将关键码三位一分割，得到253,463,587,05。 移位叠加：(253+463+587+05) = 1308 舍弃最高进位得308。 间界叠加：(253+364+587+50) = 1254 舍弃最高进位得254。 这种方法适用于关键字的数字位数特别多的情况。 四、冲突处理尽管散列函数的目标是使得冲突最少，但实际上冲突是无法避免的。因此，我们必须研究冲突解决策略。 冲突处理实质上是为产生冲突的地址寻找下一个地址。 冲突处理的方法有以下几种： 1. 开放地址法(open addressing)当冲突发生时，使用某种方法在散列表中形成一个探测序列，沿着此探测序列逐个单元地查找，直到找到给定的关键码或者碰到一个开放的地址为止。 形成探测序列的方法不同，所得到的解决冲突的方法也不同。 哈希地址的计算公式为： H=(H(key) + di) % m 其中m为散列表的长度，di表示探测序列。 不同的di，会产生不同的探测法。 线性探测法，di=1,2,3,…,m-1。此种方法会造成聚集(cluster)现象，产生一次聚集。 平方探测法，di=1^2, 2^2, 3^2, …, k^2(k&lt;=m/2)。此种方法解决了线性探测法的一次聚集，但还是会产生二次聚集。 随机探测法，di是一组伪随机数列。 2. 链地址法(seperate chaining)将所有散列地址相同的记录都存储在一个单链表中，称为同义词子表。 如图所示： 链地址法优点：不会产生聚集现象；适合无法确定表长的情况；删除节点方便。 3. 公共溢出法公共溢出法的基本思想是散列表包含基本表和溢出表两个部分，将发生冲突的记录存储在溢出表中。对应的查找方法是通过散列函数计算散列地址，先与基本表进行比较，若相等，则查找成功；否则，到溢出表中顺序查找。 4.双散列法 Double Hashing is works on a similar idea to linear and quadratic probing. Use a big table and hash into it. Whenever a collision occurs, choose another spot in table to put the value. The difference here is that instead of choosing next opening, a second hash function is used to determine the location of the next spot. For example, given hash function H1 and H2 and key. do the following: Check location hash1(key). If it is empty, put record in it.If it is not empty calculate hash2(key). Check if hash1(key)+hash2(key) is open, if it is, put it in repeat with hash1(key)+2hash2(key), hash1(key)+3hash2(key) and so on, until an opening is found. like quadratic probing, you must take care in choosing hash2. hash2 CANNOT ever return 0. hash2 must be done so that all cells will be probed eventually. 5.再散列法即在上次散列计算发生冲突时，利用该次冲突的散列函数地址产生新的散列函数地址，直到冲突不再发生. 五、哈希表的性能影响冲突的因素有： 散列函数是否均匀 处理冲突的方法 散列函数的装填因子(负载因子)a，即 a=填入表中的元素的个数/散列表的长度，a与表中的元素的个数成正比，表征了哈希表装满程度。a越大，表中的元素越多，产生的冲突可能性就越大。 扩展哈希树 参考：Collision Resolution YouTube-CS50-Hash Tables YouTube-Hashing Technique - Simplified YouTube-Hash Tables and Hash Functions]]></content>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构-栈和队列]]></title>
    <url>%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97%2F</url>
    <content type="text"><![CDATA[一、栈栈 (Stack)是一种后进先出(last in first out，LIFO)的数据结构。栈只允许在一端进行操作。 栈的操作栈是一种抽象数据类型(ADT),其上的操作有: Stack() 创建空栈 void push(T x) 向栈中添加元素 T pop() 从栈顶弹出数据 T peek() 仅查看栈顶元素，并不弹出 boolean isEmpty() 判断栈是否为空。 以上这些操作的时间复杂度要满足O(1)的约束。 栈的实现栈的实现方式有两种：采用数组或链表实现。 数组实现Java官方库中有个Stack类（但不推荐，因为它是遗留下来的，不属于集合类中，建议使用Deque实现栈的操作），其采用的就是数组实现。 数组实现要注意动态Resize，当栈满的时候扩充容量，当栈较空的时候缩小容量。有一个top指明了当前栈顶元素所在位置，当top=-1时，栈为空。 实现见 github ArrayStack 链表实现栈也可以采用单链表实现，push和pop操作只要在链表头进行操作即可满足O(1)的约束。无论采取何种方式实现，只要满足以上ADT的约束（即实现这些操作，并使这些操作的时间复杂度为O(1))，则为Stack。 实现见 github LinkedListStack 参考：浅谈算法和数据结构: 一 栈和队列 纸上谈兵: 栈 (stack) YouTube - Array implementation of Stack 二、队列队列 (Queue)是一种先进先出(first in first out，FIFO)的数据结构。队列只允许在后端（称为rear）进行插入操作，在前端（称为front）进行删除操作。 队列的操作队列是一种抽象数据类型(ADT),其上的操作有: Queue() 创建空队列 void enqueue(T x) 向队列中添加元素 T dequeue() 从队列中出列一个数据 T front() 仅查看队列的头元素，并不出列 boolean isEmpty() 判断队列是否为空。 以上这些操作的时间复杂度要满足O(1)的约束。无论采取何种方式实现，只要满足以上ADT的约束（即实现这些操作，并使这些操作的时间复杂度为O(1))，则为Queue。 队列的实现队列的实现方式有两种：采用数组或链表实现。 数组实现Java官方库中有个ArrayBlockingQueue类，其采用的就是数组实现。 数组实现中有两个指针，head和tail，分别指向队列头和尾。初始时head=tail=-1。 实现见 github ArrayQueue 链表实现队列也可以采用单链表实现，要有两个指针，head和tail指针分别指向对头和对尾。 实现见 github LinkedListQueue 参考：The Queue Abstract Data Type YouTube - Array implementation of Queue 数据结构（三）——队列及实现、循环队列实现 java数据结构与算法之（Queue）队列设计与实现 三、双端队列双端队列（deque，全名double-ended queue）是一种同时具有队列和栈性质的数据结构。双端队列中的元素可以从两端弹出，插入和删除操作限定在队列的两边进行。 在Java中实现了Deque，有两个重要的实现子类，ArrayDeque和LinkedList。ArrayDeque是采用数组实现的双端队列，LinkedList是采用链表实现的双端队列。 建议使用栈时，用ArrayDeque或者LinkedList的push和pop方法；使用队列时，使用ArrayDeque或者LinkedList的add和remove方法。 参考：java 中的Stack、Queue、Deque Wiki-Deque 深入理解循环队列—-循环数组实现ArrayDeque Java 数据结构之Deque(双向队列)]]></content>
      <tags>
        <tag>算法</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[算法问题-约瑟夫问题]]></title>
    <url>%2F%E7%AE%97%E6%B3%95%E9%97%AE%E9%A2%98-%E7%BA%A6%E7%91%9F%E5%A4%AB%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[约瑟夫问题是一个非常著名的趣题，即由n个人坐成一圈，按顺时针由1开始给他们编号。然后由第一个人开始报数，数到m的人出局。现在需要求的是最后一个出局的人的编号。 给定两个int n和m，代表游戏的人数。请返回最后一个出局的人的编号。保证n和m小于等于1000。 测试样例： 5 3 返回: 4 一、单循环链表法构建单循环链表，遇到被kill的编号则删除节点，直到最后留下一个节点。此种方法较为简单直接，不作具体展开。 时间复杂度：O(n*m) 二、递推法初始情况：0,1,2,3,4…,n-1(共n个人)，0为第一个人的编号 第一个被kill的人的编号是 (m-1) % n，分析过程如下： 当m &lt;= n 时，比如m=3，n=5，则第一个被kill的编号为0，即 (m-1)%n 当m &gt; n 时，比如m=3, n=2，则第一个被kill的编号为0，即 (m-1)%n 设第一个被kill的人编号为k, k = (m-1) % n，则第二次报数从k+1开始，剩下的构成了n-1人的约瑟夫环。 k+1 -&gt; 0 k+2 -&gt; 1 n-1 -&gt; n-k-2 … 0 -&gt; n-k-1 1 -&gt; n-k … k-1 -&gt; n-2 右边即为n-1的约瑟夫环问题了，求出n-1的约瑟夫的幸存者编号x0，则可以由上面的关系来逆推得到n的约瑟夫环问题的编号x， x = (x0 + k + 1) % n = (x0 + m) % n。 设初始问题的解为f(n, m)，子问题的解为f(n-1, m)，则有以下递推式： f(n, m) = (f(n-1, m) + m) % n f(1, m) = 0 特别地，当m=2时， 若n=2^a + t f(n, 2) = 2*t 当编号由1开始时，递推式变成： f(n, m) = (f(n-1, m) + m - 1) % n + 1 f(1, m) = 1 f(n, 2) = 2*t + 1 注：比如当n = 5, m = 5时，第一个被kill的编号为5，是(m-1) % n + 1，内部式子减掉1，取余后再加1即可得到5。 代码实现见 github： 迭代版 12345678910public class Joseph &#123; public int getResult(int n, int m) &#123; if (n &lt; 1 || m &lt; 1) return -1; int last = 1; for (int i = 2; i &lt;= n; i++) &#123; last = (last + m - 1) % i + 1; &#125; return last; &#125;&#125; 递推版 12345678public class Joseph &#123; public int getResult(int n, int m) &#123; // write code here if (n &lt; 1 || m &lt; 1) return -1; if (n == 1) return 1; return (getResult(n - 1, m) + m - 1) % n + 1; &#125;&#125; 时间复杂度: O(n)，空间复杂度：O(1) 参考： What is the best solution for Josephus problem algorithm? Youtube - 约瑟夫问题(m=2) Wiki - Josephus problem 动态规划解决约瑟夫环问题 约瑟夫问题的两个O(log n)解法 Explanation for recursive implementation of Josephus prob]]></content>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构-数组和链表]]></title>
    <url>%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%95%B0%E7%BB%84%E5%92%8C%E9%93%BE%E8%A1%A8%2F</url>
    <content type="text"><![CDATA[数据存储结构数据元素在计算机存储器的方式主要有两种： 顺序存储，一般使用数组。 链式存储，一般使用链表。 数组数组是一种最基本的数据结构，它是一种物理存储单元上连续、顺序的存储结构，数据元素的逻辑顺序是通过数组的索引次序实现的。 时间复杂度： Access: O(1) Delete: O(n) Insert: O(n) 优点：查找访问速度快。缺点：不能适应动态数据增减；插入和删除操作速度慢。 链表链表是一种最基本的数据结构，它是一种物理存储单元上非连续、非顺序的存储结构，数据元素的逻辑顺序是通过链表中的指针链接次序实现的。 链表由一系列结点（链表中每一个元素称为结点）组成，结点可以在运行时动态生成。每个结点包括两个部分：存储数据元素的数据域，存储下一个结点地址的指针域。 123456789101112131415161718192021222324252627public class Node &#123; private int data; private Node next; Node() &#123; &#125; Node(int data) &#123; this.data = data; &#125; public void setData(int data) &#123; this.data = data; &#125; public void setNextNode(Node nextNode) &#123; this.next = nextNode; &#125; public int getData() &#123; return this.data; &#125; public Node getNextNode() &#123; return this.next; &#125;&#125; 时间复杂度： Access: O(n) Delete: O(1) Insert: O(1) 优点：能适应动态数据增减，新添加的节点可以动态申请内存，对内存的利用率高；插入和删除操作速度快。缺点：由于要存储指针域，空间占用大；查找访问速度慢。 链表按链表方式分为： 单链表：只有一个next指针域。一般有个头指针指向链表中第一个结点，为了操作的统一与方便，设立了，放在第一个元素结点之前，其数据域一般无意义。实现见github singly linked list 双链表：有next指针域和prev指针域。克服了单链表查找前驱节点时间复杂度为O(n)的缺点。 循环链表：最后一个结点的指针域指向头结点，整个链表形成一个环。用尾指针rear表示的单循环链表对开始结点a1和终端结点an查找时间都是O(1)，如果仅用头指针来表示的话，查找到终端节点需要O(n)。表的操作常常是在表的首尾位置上进行，因此，实用中多采用尾指针表示单循环链表。循环链表可以解决约瑟夫问题。 链表按实现方式分为： 动态链表(使用指针或引用的方式实现) 静态链表(使用数组和游标实现) 扩展-链表相关问题静态链表静态链表相当于是用一个数组来实现线性表的链式存储结构，在静态链表中操作的是数组。 静态链表的数组元素也有数据域和指针域，只不过指针域是int型，表示下一个元素在数组中的索引，也可以称之为游标。 1234private static class Node&lt;E&gt; &#123; E data; int next; //下一个结点所在的数组下标&#125; 数组第一个元素和最后一个元素为特殊元素，数据域不存数据，第一个元素的指针域(cur)存放的是第一个空间可用元素(元素为空)的下标，最后一个元素的指针域(cur)存放的是实际数据的首元素的下标(类似于动态链表front-&gt;next)。 实现见github static linked list 参考： 数据结构与算法–静态链表 静态链表（游标实现法） 使用递归方法反向单链表1234567891011public Node reverse(Node node) &#123; if (node == null || node.getNext() == null) &#123; front.setNext(node); return; &#125; reverse(node.getNext()); node.getNext().setNext(node); node.setNext(null);&#125; 针对递归方式，要弄清楚最后一次end condition，以及递归返回以后要做什么操作。 参考：YouTube-Reverse a linked list - Reverse a linked list using recursion 使用非递归方法反向单链表123456789101112131415161718public void reverse() &#123; if (front.getNext() == null) &#123; return; &#125; Node prev = null; Node curr = front.getNext(); Node next; while (curr != null) &#123; next = curr.getNext(); curr.setNext(prev); prev = curr; curr = next; &#125; front.setNext(prev);&#125; 参考：YouTube-Reverse a linked list - Iterative method 检查链表是否有环使用龟兔赛跑模型：如果是一条直线，兔子永远会跑在前面；如果兔子发现又追上乌龟了，那么只能是兔子套了乌龟一圈。 算法逻辑如下： 指针hare初始化指向链表头结点，每次向后移动2个节点。 指针tortoise初始化指向链表头结点，每次向后移动1个节点。 如果hare最终指向尾节点或尾节点前一个节点（总结点数可能是奇数也可能是偶数），则该链表无圈。 如果hare和tortoise又指向了同一个节点，则该链表有圈。 1234567891011121314151617181920212223242526272829303132333435// Floyd's cycle-finding algorithmpublic boolean isCyclic() &#123; Node tortoise = front; Node hare = front; while (hare != null &amp;&amp; hare.getNext() != null) &#123; tortoise = tortoise.getNext(); hare = hare.getNext().getNext(); if (tortoise == hare) &#123; return true; &#125; &#125; return false;&#125;// Brent's Cycle Detection Algorithmpublic boolean isCyclic2() &#123; Node tortoise = front; Node hare = front; int taken = 0; int limit = 2; while (hare != null) &#123; hare = hare.getNext(); taken++; if (hare == tortoise) &#123; return true; &#125; if (taken == limit) &#123; taken = 0; limit &lt;&lt;= 1; tortoise = hare; &#125; &#125; return false;&#125; 参考： wiki-Cycle detection How to detect a loop in a linked list? Brent’s Cycle Detection Algorithm (The Teleporting Turtle 使用单向循环链表解决约瑟夫问题 其他参考： CSDN 数组、链表、堆栈和队列 cnblogs 数组、链表、栈、队列和STL 时间复杂度分别为 O（n）和 O（1）的删除单链表结点的方法 结构之美：单链表的头结点与头指针 用链表的目的是什么？省空间还是省时间？ LeetCode #141 Linked List Cycle How to Find if Linked List contains Loops or Cycles in Java How to reverse a singly linked list in Java 单循环链表中设置尾指针比设置头指针更好的原因]]></content>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构和算法基本概念]]></title>
    <url>%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5%2F</url>
    <content type="text"><![CDATA[算法 + 数据结构 = 程序 一、数据结构数据结构是指数据的逻辑结构和存储结构。数据结构是按照某种逻辑关系组成的一组数据，并按一定的存储方式存储在计算机的存储器中，并在这些数据上定义了一组运算的集合。 数据结构有三要素：数据逻辑结构、数据存储结构、数据的运算。 逻辑结构逻辑结构：数据元素之间的存储关系。 集合结构 集合结构:数据元素除了同属于一个集合外,他们之间没有其他关系。 线性结构 数据元素之间的关系是一对一的关系。 线性表 栈 队列 串 非线性结构 数据元素之间的关系是一对多或多对多的关系。 树 图 多维数组 堆 存储结构存储结构：数据元素及其关系在计算机存储器内的存储形式。 顺序存储结构：逻辑上相邻的节点存储在物理位置上相邻的存储单元中。通常以数组的形式存储，但是静态链表由于相邻的节点并不一定存储在物理位置相邻的存储单元中，所以不是顺序存储结构，还是一个链式存储结构。 链式存储结构：任意的存储单元存储线性表的数据元素，每个结点由数据域和指针域组成。 索引存储结构：在存储元素信息的同时，还建立附加的索引表。索引表中的每一项称为索引项，索引项的一般形式是：（关键字，地址）。 散列存储结构：根据元素的关键字直接计算出该元素的存储地址，又称为Hash存储。 用顺序存储结构存储的线性表称为顺序表。 用链式存储结构存储的线性表称为链表。 其他逻辑结构都可以采用两种不同的存储结构来实现，比如栈既可以用数组实现，也可以用链表实现，区别就在于数组需要固定大小，而链表则可以动态添加。` 链表按实现方式可分为：静态链表和动态链表。 链表按链接方式可分为：单链表、双链表和循环链表。 抽象数据类型(ADT)抽象数据类型（Abstract Data Type，ADT）是计算机科学中具有类似行为的特定类别的数据结构的数学模型；或者具有类似语义的一种或多种程序设计语言的数据类型。抽象数据类型是间接定义的，通过其上的可执行的操作以及这些操作的效果的数学约束（与可能的代价）。 对于用户来说只关心数据模型和在其上的操作，并不关心如何实现，如何存储的。比如Stack,它仅能在一端进行添加数据和取出数据的操作(LIFO),有init, push, pop, top, isEmpty等操作。 粗略地说， 抽象数据类型=逻辑结构+操作 在Java中通过接口来表示抽象数据类型，接口的实现来表示抽闲数据类型的实现。 参考: 「数据结构」和「数据类型」两个概念的本质是什么，区别与联系 数据类型和常用数据结构 二、算法算法是指对数据的操作方法的描述。]]></content>
      <tags>
        <tag>算法</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[非比较排序算法：计数排序、基数排序和桶排序]]></title>
    <url>%2F%E9%9D%9E%E6%AF%94%E8%BE%83%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%EF%BC%9A%E8%AE%A1%E6%95%B0%E6%8E%92%E5%BA%8F%E3%80%81%E5%9F%BA%E6%95%B0%E6%8E%92%E5%BA%8F%E5%92%8C%E6%A1%B6%E6%8E%92%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[计数排序计数排序的思想：对每一个输入元素，计算小于等于它的元素个数，如果有10个元素小于等于它，那么它就应该放在11的位置上，如果有17个元素小于等于它，它就应该放在18的位置上。 计数排序的过程： 找出待排序的数组中最大和最小的元素 统计数组中每个值为i的元素出现的次数，存入数组 C 的第 i 项（如果min &gt; 0， 则存入数组 C 的第 i - min 项，下同） 对所有的计数累加（从C中的第一个元素开始，每一项和前一项相加） 反向填充目标数组：将每个元素i放在新数组的第C(i)项，每放一个元素就将C(i)减去1，原来数组后面的先放，这样就保证了稳定性。 复杂度： 时间复杂度：O(n+k)， n是输入数据的个数，k是输入数据的范围大小 空间复杂度: O(n+k)， n是输入数据的个数，k是输入数据的范围大小 当输入数据的范围大小超过n时，计数排序就不合适了，计数排序适用于小范围的整数序列的排序。 算法实现见:github counting sort 计数排序参考： YouTube-CountingSort Why can’t we use count sort as a general purpose sorting algorithm? 基数排序基数排序（Radix sort)是把每一位用计数排序来排序（由低位到高位排序，每次排序得到一个中间结果，然后用这个中间结果继续排序，直到所有位都排序完得到最终结果），解决了计数排序范围大时时间复杂度和空间复杂度都大的问题。 为什么要从低位开始向高位排序? 如果要从高位排序, 那么次高位的排序会影响高位已经排好的大小关系. 在数学中, 数位越高,数位值对数的大小的影响就越大.从低位开始排序,就是对这种影响的排序. 数位按照影响力从低到高的顺序排序, 数位影响力相同则比较数位值。 其实，也是可以从高位开始排序，算法为MSD Radix sort。过程： 获取每个key的最大位。 根据最大位排序，并将相同位的数据放在一个bucket中。 根据下一位递归的排序每一个bucket。 将所有的bucket组合按顺序输出即可。 复杂度： 时间复杂度：O(d(n+k))， n是输入数据的个数，d是最大数字位数，k是每一位的数据范围大小 空间复杂度: O(n+k)，n是输入数据的个数, k是每一位的数据范围大小 算法实现见:github radix sort 基数排序参考: YouTube-Radix Sort-step by step guide 维基百科-基数排序 YouTube-MSD radix sort 桶排序桶排序的过程： 将输入数据划分到N个桶中(多少个桶由自己决定)，即将min~max分成N份（最好能差不多均匀分布）。 对这N个桶分别进行插入排序。 遍历每个桶，按照次序把各个桶的元素列出来。 伪代码： 1234567function bucketSort(array, n) is buckets ← new array of n empty lists for i = 0 to (length(array)-1) do insert array[i] into buckets[msbits(array[i], k)] for i = 0 to n - 1 do nextSort(buckets[i]); return the concatenation of buckets[0], ...., buckets[n-1] 当每个桶的数据范围大小为1时，则为鸽巢排序。当数据分布很不均匀时，时间复杂度有可能是O(n^2)。 桶排序参考： YouTube-Bucket Sort-step by step guide YouTube-Bucket sort YouTube-Pigeonholes sort 总结：以上三种排序算法虽然能在线性时间内排序，但是需要额外的空间，并且输入要满足一定的条件，比如计数排序要求输入满足整数才可以，桶排序则需要输入数据满足均匀分布，因此大部分情况下都是采用的基于排序的O(nlogn)的排序算法如快速排序。]]></content>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构-堆]]></title>
    <url>%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%A0%86%2F</url>
    <content type="text"><![CDATA[堆是计算机科学中一类特殊的数据结构的统称。堆又被称为优先队列，普通的队列是先进先出，堆是最小或最大(分别对应最小堆和最大堆)先出。 n个元素序列{k1,k2…ki…kn},当且仅当满足下列关系时称之为堆：(ki &lt;= k2i,ki &lt;= k2i+1)或者(ki &gt;= k2i,ki &gt;= k2i+1), (i = 1,2,3,4…n/2) 堆的性质堆的实现是完全二叉树，实现的堆称为二叉堆。其具有以下性质: 父节点大于所有子节点(最大堆，大根堆)或者父节点小于所有子节点(最小堆，小根堆) 堆总是一棵完全树。即除了最底层，其它层的节点都被元素填满，最底层尽可能地从左到右填入。 应用场景重要有两个： 堆排序 优先队列 堆的操作堆的操作主要有两个(其他的比如创建空堆，重构堆等操作则是辅助操作)： 删除操作(删除操作只能删除根节点) 插入操作 这两个操作都涉及到了堆的重构，因为它们都破坏了堆的结构。本文暂时以小根堆来讲解这些操作。 针对删除操作的重构方式：删掉根节点后，会有两个子树，将最后一个节点放到根节点的位置，然后不断的跟子节点比较，如果大于小的那个子节点，则交换两者，递归这个过程，直到下沉的节点不再大于任一子节点或者成为了叶节点。 针对插入操作的重构方式：新插入的节点放在完全二叉树最后的位置（数组的末尾）。再和父节点进行比较，如果小于父节点，这父节点交换，递归调用此过程直至不小于父节点或成为根节点。 堆的实现堆通常以数组的形式实现，位置k的节点的父节点的位置为k/2向下取整(可以使用右移一位表示)，而它的两个子节点的位置分别为2k和2k+1。为方便这样计数，简化计算，一般根节点是放在k=1的位置，堆的表示中不使用a[0]。 具体实现代码见 github 总结堆有两种主要操作：插入元素和删除根节点。堆一般用数组实现。 扩展阅读优先队列优先队列是计算机科学中的一类抽象数据类型。优先队列中的每个元素都有各自的优先级，优先级最高的元素最先得到服务；优先级相同的元素按照其在优先队列中的顺序得到服务。优先队列往往用堆来实现。 优先队列有两种实现： 初级实现 堆实现 初级实现采用有序数组或者无序数组来实现。有序数组插入操作时间复杂度为O(n)，删除操作为O(1)；无序数组插入操作时间复杂度为O(1)，删除操作为O(n)。 堆实现则使插入和删除操作的时间复杂度为O(logn)。 因此优先队列常使用堆来实现。 堆排序堆排序（Heapsort）是指利用堆这种数据结构所设计的一种排序算法。 在堆的数据结构中，堆中的最大值总是位于根节点(在优先队列中使用堆的话堆中的最小值位于根节点)。堆中定义以下几种操作： 最大堆调整（Max_Heapify）：将堆的末端子节点作调整，使得子节点永远小于父节点 创建最大堆（Build_Max_Heap）：将堆所有数据重新排序 堆排序（HeapSort）：移除位在第一个数据的根节点，交换到数组的末尾，并做最大堆调整的递归运算。 具体实现代码见 github 性能： 最优时间复杂度：O(nlogn) 最坏时间复杂度：O(nlogn) 平均时间复杂度：O(nlogn) 空间复杂度: O(1) 不稳定。 参考： 纸上谈兵: 堆 (heap) Youtube-堆 数据结构系列——堆 维基百科-堆) 维基百科-优先队列]]></content>
      <tags>
        <tag>算法</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo中如何插入图片]]></title>
    <url>%2FHexo%E4%B8%AD%E5%A6%82%E4%BD%95%E6%8F%92%E5%85%A5%E5%9B%BE%E7%89%87%2F</url>
    <content type="text"><![CDATA[Hexo有多种方式插入图片，以下讲解其中三种方式。 一、通过Markdown语法引用将图片 example.jpg 放在 source/images 目录下，在文章的md文件中插入 ![](/images/example.jpg) 即可。 这种方法针对的是在hexo整个项目中有少量的图片的情况，且 _config.yml 中 post_asset_folder 必须为 false 才能引用。 二、通过标签插件引用在hexo3中，新的标签插件被加入到了核心代码里，此时可以采用标签插件引用来插入图片，这样的好处在于图片资源管理较为方便。 设置_config.yml 中 post_asset_folder 为 true 可以使每一次hexo new post postname都创建一个postname的文件夹和postname.md的文件。 把图片 example.jpg 放到postname文件夹中，然后在md文件里使用下面方式引用： {% asset_img example.jpg This is an example image %} 三、CDN引用将图片上传到一些免费的CDN服务中。上传完图片后会生成对应的url，直接引用url即可插入图片。 图片测试： 参考: Hexo官方文档-Asset资源文件夹]]></content>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[GitHub+Hexo搭建博客]]></title>
    <url>%2FGitHub%2BHexo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%2F</url>
    <content type="text"><![CDATA[一、创建github page在github.com上新建repository，repository的名字是 username.github.io ，比如我在github上的用户名是limitless083，因此新建的repository名字为 limistless083.github.io 二、安装Hexo的依赖Hexo依赖下列应用程序： Git Node.js Git 用来将生成的网页部署到github上。 Node 则用来生成网页。 三、安装Hexo执行以下命令即可 $ npm install -g hexo-cli 前三部分参考: Hexo官方安装文档 四、部署Hexo应用在自己创建的文件夹比如my_blog文件夹内用命令行执行以下命令 123hexo init # 初始化hexo新项目npm install # 安装依赖npm install hexo-deployer-git --save # 安装git依赖 更新_config.yml中配置，修改为： 123deploy:- type: git repo: git@github.com:limitless083/limitless083.github.io.git 清空旧文件: hexo clean部署：hexo deploy 本部分可以参考: Hexo官方部署文档 五、更改主题hexo 主题有很多，其中最出名的是NexT主题，该主题有详细的文档设置，可以参考NexT官方文档 结语以上就是一些大概的流程介绍，Hexo官方文档和NexT官方文档解释的都比较详细，在此就不再赘述了。]]></content>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[执行inotifywait过程出现upper limit on inotify watches reached的解决方式]]></title>
    <url>%2F%E6%89%A7%E8%A1%8Cinotifywait%E8%BF%87%E7%A8%8B%E5%87%BA%E7%8E%B0upper%20limit%20on%20inotify%20watches%20reached%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[遇到的问题 执行inotifywait过程中出现upper limit on inotify watches reached 解决方式增加/proc/sys/fs/inotify/max_user_watches /proc/sys/fs/inotify/max_user_watches 表示每个inotify instatnces可监控的最大目录数量，在相关知识部分可以了解一下inotify。 解决步骤 检查一下inotify watches的最大值 1cat /proc/sys/fs/inotify/max_user_watches 设置inotify watches(以root权限) 12345678# 临时的sysctl fs.inotify.max_user_watches=81960# 永久的vi /etc/sysctl.conf添加 fs.inotify.max_user_watches=81960# 重新加载sysctl配置sysctl -p 相关知识sysctlsysctl命令被用于在内核运行时动态地修改内核的运行参数，可用的内核参数在目录/proc/sys中 常见用法: sysctl -a 列出所有可读变量 sysctl variable=value 设置指定变量(临时的,若要永久的可以更改/etc/sysctl.conf文件) sysctl -p 从配置文件“/etc/sysctl.conf”加载内核参数设置 参考：Linux命令大全-sysctl命令 inotifyInotify为Linux提供了一套高效监控和跟踪文件变化的机制，可以监控文件系统的访问属性、读写属性、权限属性、删除创建、移动等操作，也就是可以监控文件发生的一切变化，它采用的是事件驱动机制，不是轮询机制。 在Linux中提供了inotify-tools，该工具包含了两个命令inotifywait和inotifywatch,分别用来收集有关文件访问信息和关于被监视的文件系统的统计信息。 常见用法： inotifywait -mrq --timefmt &#39;%d/%m/%y/%H:%M&#39; --format &#39;%T %w %f&#39; -e create /dir 监听目录创建文件的事件。 参考: Linux命令大全-inotifywait Inotify: Efficient, Real-Time Linux File System Event Monitoring rsyncrsync是一个远程数据同步工具，可通过LAN/WAN快速同步多台主机间的文件。它使用所谓的“Rsync演算法”来使本地和远程两个主机之间的文件达到同步，这个算法只传送两个文件的不同部分，而不是每次都整份传送，因此速度相当快。所以通常可以作为备份工具来使用。 rsync的不足之处：rsync同步数据时，需要扫描所有文件后进行比对，进行差量传输。如果文件数量达到了百万甚至千万量级，扫描所有文件将是非常耗时的。因此常常使用rsync+inotify组合来实时同步数据。 常见用法: rsync -a /data /backup 从/data目录同步文件到/backup目录 rsync -v rsync://192.168.78.192/www 列远程机的文件列表。 参考: Linux命令大全-rsync]]></content>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux命令:find, grep和xargs的爱恨情仇]]></title>
    <url>%2FLinux%E5%91%BD%E4%BB%A4-find%2C%20grep%E5%92%8Cxargs%E7%9A%84%E7%88%B1%E6%81%A8%E6%83%85%E4%BB%87%2F</url>
    <content type="text"><![CDATA[find命令用来在指定目录下查找文件。 grep命令用来正则匹配，搜索文本，找到匹配的行并打印出来。全称是global search regular expression and print out the line。 xargs命令将参数列表转换成小块分段传递给其他命令，以避免参数列表过长的问题，一般是管道输出给xargs。 findfind的常见用法： 列出当前目录及子目录下所有文件和文件夹 find . 在”/home”目录下查找以.txt结尾的文件 find /home -name “*.txt” 在”/home”目录下查找不是以.txt结尾的文件 find /home ! -name “*.txt” 根据文件类型查找 find . -type 类型参数 类型参数有: f 普通文件l 符号链接d 目录c 字符设备b 块设备s 套接字p fifo 根据文件大小进行匹配, 搜索大于10k的文件 find . -type f -size +10k 根据权限进行匹配 find . -type f -perm 777 查找所有空文件 find . -empty 其他的详细的可以参考man find grepgrep的常见用法： 在文件中搜索一个单词，命令会返回一个包含”match_pattern”的文本行 grep “match_pattern” file 等同于 cat file | grep “match_pattern” 递归搜索文件 grep “text” . -r 在grep搜索结果中包括或者排除指定文件 只在目录中所有的.php和.html文件中递归搜索字符”main()” grep “main()” . -r –include *.{php,html} 在搜索结果中排除所有README文件grep “main()” . -r –exclude “README” 在搜索结果中排除filelist文件列表里的文件 grep “main()” . -r –exclude-from filelist 显示匹配某个结果的之前或之后的行，-A(after),-B(before),-C(context) cat file | grep “haha” -A 3 其他的详细的可以参考man grep xargsxargs的常见用法: xargs用作替换工具，读取输入数据重新格式化后输出 cat test.txt 输出： a b c d e f cat test.txt | xargs 输出： a b c d e f 删除最近的5个文件 ls -t | head -5 | xargs rm -rf 统计一个源代码目录中所有erlang文件的行数: find . -type f -name “*.erl” | xargs wc -l 其他的详细的可以参考man xargs]]></content>
  </entry>
  <entry>
    <title><![CDATA[How can I increase open files limit]]></title>
    <url>%2FHow-can-I-increase-open-files-limit%2F</url>
    <content type="text"><![CDATA[步骤 Use the following command command to display maximum number of open file descriptors cat /proc/sys/fs/file-max 6508886 To see the hard and soft values, issue the command as follows ulimit -Hn 4096 ulimit -Sn 1024 open the sysctl.conf and add this line fs.file-max = 65536, 65536 can be other number. vi /etc/sysctl.conf add new line: fs.file-max = 65536 modify /etc/security/limits.conf according to limits.conf man-page add user limit configuration, for example, for user cold: vi /etc/security/limits.conf add new line: cold - nofile 500000 500000 should be lower than file-max exit user and relogin 参考How can I increase open files limit for all processes? Linux Increase The Maximum Number Of Open Files / File Descriptors limits.conf man-page On Linux - set maximum open files to unlimited. Possible?]]></content>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>

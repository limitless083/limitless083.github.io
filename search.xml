<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[LintCode-131. 大楼轮廓]]></title>
    <url>%2FLintCode-131-%E5%A4%A7%E6%A5%BC%E8%BD%AE%E5%BB%93%2F</url>
    <content type="text"><![CDATA[一、题目Given N buildings in a x-axis，each building is a rectangle and can be represented by a triple (start, end, height)，where start is the start position on x-axis, end is the end position on x-axis and height is the height of the building. Buildings may overlap if you see them from far away，find the outline of them。 An outline can be represented by a triple, (start, end, height), where start is the start position on x-axis of the outline, end is the end position on x-axis and height is the height of the outline. 样例： 给出三座大楼：12345[ [1, 3, 3], [2, 4, 4], [5, 6, 1]] 外轮廓线为：12345[ [1, 2, 3], [2, 4, 4], [5, 6, 1]] 二、思路1. 找到高度变化的关键点 对各个building的顶点进行排序 使用优先队列或TreeMap返回当前最高的building。若新增一幢楼，使当前楼高最高值变大，则该点是一个关键点；若遍历完一幢楼，即删掉一幢楼，使当前楼高最高值变小，则该点也是一个关键点。 排序过程中，需要考虑以下几种情况： ① start相同，version高的比version低的顺序要靠前。 ② end相同，version高的比version低的顺序要靠后。 ③ 否则，offset小的比offset大的顺序要靠前。 由于start和end相同的时候version排序方式相反，可以将start的version标记为-version，并以此来区分一段线段的start和end。 1234567list.sort((a, b) -&gt; &#123; if (a[0] != b[0]) &#123; return a[0] - b[0]; &#125; else &#123; return a[1] - b[1]; &#125;&#125;) 完整代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748public List&lt;int[]&gt; getKeyPoints(int[][] buildings) &#123; List&lt;int[]&gt; res = new ArrayList&lt;&gt;(); List&lt;int[]&gt; points = new ArrayList&lt;&gt;(); for (int[] bd : buildings) &#123; // height 为负表示开始 points.add(new int[]&#123;bd[0], -bd[2]&#125;); points.add(new int[]&#123;bd[1], bd[2]&#125;); &#125; // 排序 points.sort((a, b) -&gt; &#123; if (a[0] != b[0]) &#123; return a[0] - b[0]; &#125; else &#123; if (Math.abs(a[1]) - Math.abs(b[1]) == 0) return 0; return a[1] - b[1]; &#125; &#125;); // 由于PriorityQueue的remove方法的时间复杂度为O(n)，会超时，因此选择TreeMap来实现。 TreeMap&lt;Integer, Integer&gt; tm = new TreeMap&lt;&gt;(Collections.reverseOrder()); tm.put(0, 1); int preMax = 0; int currMax = 0; for (int[] point : points) &#123; if (point[1] &lt; 0) &#123; if (tm.containsKey(-point[1])) &#123; tm.put(-point[1], tm.get(-point[1]) + 1); &#125; else &#123; tm.put(-point[1], 1); &#125; &#125; else &#123; if (tm.get(point[1]) == 1) &#123; tm.remove(point[1]); &#125; else &#123; tm.put(point[1], tm.get(point[1]) - 1); &#125; &#125; currMax = tm.firstKey(); if (preMax != currMax) &#123; res.add(new int[]&#123;point[0], currMax&#125;); preMax = currMax; &#125; &#125; return res; &#125; 2. 根据关键点构造轮廓12345678910111213141516171819public List&lt;List&lt;Integer&gt;&gt; buildingOutline(int[][] buildings) &#123; List&lt;List&lt;Integer&gt;&gt; result = new ArrayList&lt;&gt;(); List&lt;int[]&gt; keyPoints = getKeyPoints(buildings); for (int i = 0; i &lt; keyPoints.size() - 1; i++) &#123; if (keyPoints.get(i)[1] == 0) &#123; // 如果height为0就不需要加进去了 continue; &#125; else &#123; List&lt;Integer&gt; middle = new ArrayList&lt;&gt;(); middle.add(keyPoints.get(i)[0]); middle.add(keyPoints.get(i+1)[0]); middle.add(keyPoints.get(i)[1]); result.add(middle); &#125; &#125; return result; &#125; 三、相关知识1.TreeMapTreeMap是一个通过红黑树实现有序的key-value集合。TreeMap基于红黑树（Red-Black tree）实现。映射根据其键的自然顺序进行排序，或者根据创建映射时提供的 Comparator 进行排序，具体取决于使用的构造方法。TreeMap的基本操作containsKey、get、put、remove方法，它的时间复杂度是log(n) 2.PriorityQueuePriorityQueue是从JDK1.5开始提供的新的数据结构接口，并作为Java Collections Framework的一部分。它基于jdk1.7的使用文档在java.util目录下。它是一种基于优先级堆的极大优先级队列。PriorityQueue是不同于先进先出队列的另一种队列,每次从队列中取出的是具有最高优先权的元素。如果不提供Comparator的话，优先队列中元素默认按自然顺序排列，也就是数字默认是小的在队列头，字符串则按字典序排列，也可以根据 Comparator来指定，这取决于使用哪种构造方法。PriorityQueue不允许 null 元素。 用PriorityQueue可以解决top K问题 topK大使用小根堆，topK小使用大根堆，使队列容量保持在k]]></content>
  </entry>
  <entry>
    <title><![CDATA[剑指Offer-链表中倒数第k个节点]]></title>
    <url>%2F%E5%89%91%E6%8C%87Offer-%E9%93%BE%E8%A1%A8%E4%B8%AD%E5%80%92%E6%95%B0%E7%AC%ACk%E4%B8%AA%E8%8A%82%E7%82%B9%2F</url>
    <content type="text"><![CDATA[问题描述输入一个链表，输出该链表中倒数第k个结点。 链表结构： 12345678public class ListNode &#123; int val; ListNode next = null; ListNode(int val) &#123; this.val = val; &#125;&#125; 边界条件输入的head为空、k &lt;= 0、 k &gt; 链表节点个数 思路当我们用一个指针遍历链表不能解决问题的时候，可以尝试用两个指针来遍历链表。让其中一个指针遍历的速度快一点（比如一次在链表上走两步等）或者让其中一个指针先在链表上走几步。 本题可以用两个指针，让其中一个指针先走k-1步，然后再让另外一个指针同时走，当先走的指针到达末尾的时候，另外一个指针则在倒数第k个节点处。 代码1234567891011121314151617181920public class Solution &#123; public ListNode FindKthToTail(ListNode head,int k) &#123; if (k &lt;= 0 || head == null) return null; ListNode first = head; ListNode second = null; int step = 0; while (first != null) &#123; if (step == k - 1) &#123; //当k &gt; 链表节点个数时，second一直为null second = head; &#125; if (step &gt; k - 1 &amp;&amp; second != null) &#123; second = second.next; &#125; step++; first = first.next; &#125; return second; &#125;&#125; 相关题目 求链表的中间节点。定义两个指针，同时从head出发，一个指针每次走两步，一个指针每次走一步。当快的指针到末尾时，慢的指针则在中间。 链表中环的入口节点。①先找到环中的任意一个节点（用快慢两个指针，若两指针相遇，则有环，相遇的点为环中某一节点）；②再从该点重新出发回到该点，则可以计算出环中节点个数k；③用两个指针，一个指针从头开始走k步，然后另一个指针开始走，直到两个指针相遇，则后走的指针第一次遇到入口，而先走的指针在环中走了一圈回到了入口。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253public class Solution &#123; public ListNode EntryNodeOfLoop(ListNode pHead) &#123; if (pHead == null) return null; if (getArbitraryLoopNode(pHead) == null) &#123; // 没有环 return null; &#125; int k = getLoopNodeCount(getArbitraryLoopNode(pHead)); // 环中节点个数 int step = 0; ListNode aheadNode = pHead; ListNode behindNode = null; while (aheadNode != behindNode) &#123; if (step == k - 1 ) &#123; behindNode = pHead; &#125; if (step &gt; k - 1) &#123; behindNode = behindNode.next; &#125; aheadNode = aheadNode.next; // 相当于aheadNode距离behindNode有k步。 step++; &#125; return aheadNode; &#125; public ListNode getArbitraryLoopNode(ListNode pHead) &#123; if (pHead == null) return null; ListNode tortoise = pHead.next; if (tortoise == null) return null; ListNode hare = tortoise.next; while (hare != null &amp;&amp; tortoise != null) &#123; if (hare == tortoise) return hare; tortoise = tortoise.next; hare = hare.next; if (hare != null) &#123; hare = hare.next; &#125; &#125; return null; &#125; public int getLoopNodeCount(ListNode pNode) &#123; ListNode node = pNode; int nodeCount = 1; while (node.next != pNode) &#123; node = node.next; nodeCount++; &#125; return nodeCount; &#125;&#125;]]></content>
      <tags>
        <tag>算法</tag>
        <tag>链表</tag>
        <tag>双指针</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[剑指Offer-剪绳子]]></title>
    <url>%2F%E5%89%91%E6%8C%87Offer-%E5%89%AA%E7%BB%B3%E5%AD%90%2F</url>
    <content type="text"><![CDATA[一、问题描述给你一根长度为n的绳子，请把绳子剪成m段（m、n都是整数，n&gt;1,m&gt;1），每段绳子的长度记为 k[0], k[1], k[2], …, k[m]。请问 k[0] k[1] k[2] … k[m] 可能的最大乘积是多少？例如，当绳子的长度为8时，我们把它剪成长度分别为2、3、3的三段，此时得到的最大乘积是18。 二、思路1. 动态规划第一步，拆分问题： 设dp[i]表示长度为i的绳子，剪成若干段的最大乘积。 求dp[length] 状态dp[i] 第二步，状态初始值 dp[0] = 0; dp[1] = 1; dp[2] = 2; dp[3] = 3; // 状态初始值，其他长度大于3的绳子剪出来的，因此dp[3]最长可以为3。 第三步，状态转移方程 dp[i] = max(dp[j] * dp[i-j]); 其中 0 &lt; j &lt; i/2 1234567891011121314151617181920212223public class Solution &#123; public int maxProductAfterCutting(int length) &#123; if (length &lt; 2) return 0; // 由于要剪成m段，且m&gt;1，则当length&lt;2的时候无法剪成m段 if (length == 2) return 1; // 1*1 if (length == 3) return 2; // 1*2 int[] dp = new int[length+1]; dp[0] = 0; dp[1] = 1; dp[2] = 2; dp[3] = 3; for (int i = 4; i &lt;= length; i++) &#123; int max = 0; for (int j = 1; j &lt; i/2; j++) &#123; max = Math.max(max, dp[j]*d[i-j]); &#125; dp[i] = max; &#125; return dp[length]; &#125;&#125; 2. 贪婪法当n&gt;=5时，我们尽可能多地剪出长度为3的绳子；当n=4时，把绳子剪成两段长度为2的绳子。 比较n, 1(n-1), 2(n-2), 3*(n-3) 当 n &lt; 4时，n &gt; 2*(n-2), 即不剪的话最长 当 n = 4时，n = 2*(n-2), 即剪不剪都一样 当 n &lt; 5时，2(n-2) &gt; 3(n-3) 当 n &gt;=5时，2(n-2) &lt; 3(n-3) 总数，当n&gt;=5时，尽可能多地剪出长度为3的来；当n=4时，最大值为4 例如：当n=8，则f(8)=3f(5)=33f(2)=332=18; 当n=10,则f(10)=3f(7)=33f(4)=334=36 12345678910111213141516public class Solution &#123; public int maxProductAfterCutting(int length) &#123; if (length &lt; 2) return 0; // 由于要剪成m段，且m&gt;1，则当length&lt;2的时候无法剪成m段 if (length == 2) return 1; // 1*1 if (length == 3) return 2; // 1*2 int timesOfThree = length / 3; if (length % 3 == 1) &#123; timesOfThree--; // 如果最后剩下的是3+1=4，则不要剪出3来 &#125; int timesOfTwo = (length - timesOfThree * 3) / 2; // 要么是1，即最后只剩下2+3=5的时候；要么是2，即最后剩下是2+2=4的时候 return Math.pow(3, timesOfThree) * Math.pow(2, timesOfTwo); &#125;&#125;]]></content>
      <tags>
        <tag>算法</tag>
        <tag>动态规划</tag>
        <tag>贪婪法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[矩阵中的路径、机器人的运动范围]]></title>
    <url>%2F%E7%9F%A9%E9%98%B5%E4%B8%AD%E7%9A%84%E8%B7%AF%E5%BE%84%E3%80%81%E6%9C%BA%E5%99%A8%E4%BA%BA%E7%9A%84%E8%BF%90%E5%8A%A8%E8%8C%83%E5%9B%B4%2F</url>
    <content type="text"><![CDATA[一、矩阵中的路径1. 问题描述请设计一个函数，用来判断在一个矩阵中是否存在一条包含某字符串所有字符的路径。路径可以从矩阵中的任意一个格子开始，每一步可以在矩阵中向左，向右，向上，向下移动一个格子。如果一条路径经过了矩阵中的某一个格子，则该路径不能再进入该格子。 例如 a b c e s f c s a d e e 矩阵中包含一条字符串”bcced”的路径，但是矩阵中不包含”abcb”路径，因为字符串的第一个字符b占据了矩阵中的第一行第二个格子之后，路径不能再次进入该格子。 2. 思路利用回溯。任意一个点都可以进入，因此需要两个循环遍历每一个点。 每一个点都可以上下左右的挪动，当遇到不满足的时候就回溯。 3. 代码1234567891011121314151617181920212223242526272829303132333435363738394041public class Solution &#123; private boolean[] visited; public boolean hasPath(char[] matrix, int rows, int cols, char[] str) &#123; if (str == null) return true; if (rows &lt; 0 || cols &lt; 0 || matrix == null) return false; visited = new boolean[matrix.length]; // 注意这里，每个点都可以进入 for (int i = 0; i &lt; rows; i++) &#123; for (int j = 0; j &lt; cols; j++) &#123; // 进入某个点前先判断是否和开头匹配 if (str[0] == matrix[i*cols+j] &amp;&amp; backtracking(matrix, rows, cols, i, j, 0, str)) &#123; return true; &#125; &#125; &#125; return false; &#125; public boolean backtracking(char[] matrix, int rows, int cols, int i, int j, int index, char[] str) &#123; // 满足条件输出 if (index &gt;= str.length) return true; // 到达临界条件 if (i &gt;= rows || j &gt;= cols || i &lt; 0 || j &lt; 0 || matrix[i*cols + j] != str[index] || visited[i*cols+j]) &#123; return false; &#125; // matrix[i*cols+j] = str[index] visited[i*cols+j] = true; if ( backtracking(matrix, rows, cols, i+1, j, index + 1, str) || backtracking(matrix, rows, cols, i-1, j, index + 1, str) || backtracking(matrix, rows, cols, i, j-1, index + 1, str) || backtracking(matrix, rows, cols, i, j+1, index + 1, str)) &#123; return true; &#125; visited[i*cols+j] = false; return false; &#125;&#125; 二、机器人的运动范围1. 问题描述地上有一个m行和n列的方格。一个机器人从坐标0,0的格子开始移动，每一次只能向左，右，上，下四个方向移动一格，但是不能进入行坐标和列坐标的数位之和大于k的格子。 例如，当k为18时，机器人能够进入方格（35,37），因为3+5+3+7 = 18。但是，它不能进入方格（35,38），因为3+5+3+8 = 19。请问该机器人能够达到多少个格子？ 2. 思路与矩阵中的路径类似，但是只能由(0,0)点进入，回溯的边界条件不一致 3. 代码123456789101112131415161718192021222324252627282930public class Solution &#123; private boolean[][] visited; private int total = 0; public int movingCount(int threshold, int rows, int cols) &#123; visited = new boolean[rows][cols]; dfs(threshold, rows, cols, 0, 0); return total; &#125; public void dfs(int threshold, int rows, int cols, int i, int j) &#123; if (i &lt; 0 || j &lt; 0 || i &gt;= rows || j &gt;= cols || get_sum(i) + get_sum(j) &gt; threshold || visited[i][j]) &#123; return; &#125; total++; visited[i][j] = true; dfs(threshold, rows, cols, i+1, j); dfs(threshold, rows, cols, i-1, j); dfs(threshold, rows, cols, i, j+1); dfs(threshold, rows, cols, i, j-1); &#125; public int get_sum(int num) &#123; int sum = 0; while (num &gt; 0) &#123; sum += num % 10; num /= 10; &#125; return sum; &#125;&#125; 三、相关题目Word Search Word Search II]]></content>
      <tags>
        <tag>算法</tag>
        <tag>回溯</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[调整数组顺序使奇数位于偶数前面]]></title>
    <url>%2F%E8%B0%83%E6%95%B4%E6%95%B0%E7%BB%84%E9%A1%BA%E5%BA%8F%E4%BD%BF%E5%A5%87%E6%95%B0%E4%BD%8D%E4%BA%8E%E5%81%B6%E6%95%B0%E5%89%8D%E9%9D%A2%2F</url>
    <content type="text"><![CDATA[问题描述： 输入一个整数数组，实现一个函数来调整该数组中数字的顺序，使得所有的奇数位于数组的前半部分，所有的偶数位于位于数组的后半部分，并保证奇数和奇数，偶数和偶数之间的相对位置不变。 思路： 使用额外空间，将奇数放在新数组的前面，偶数放在后面。 12345678910111213141516171819202122232425public class Solution &#123; public void reOrderArray(int [] array) &#123; int oddCount = 0; for (int i = 0; i &lt; array.length; i++) &#123; if ((array[i] &amp; 1) == 1) &#123; oddCount++; &#125; &#125; int oddStart = 0; int evenStart = oddCount; int[] temp = new int[array.length]; for (int i = 0; i &lt; array.length; i++) &#123; if ((array[i] &amp; 1) == 1) &#123; result[oddStart++] = array[i]; &#125; else &#123; result[evenStart++] = array[i]; &#125; &#125; for (int i = 0; i &lt; array.length; i++) &#123; array[i] = temp[i]; &#125; &#125;&#125; LintCode-144.交错正负数如果需要保持顺序的话，也可以用这样的方式实现。]]></content>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LintCode-144.交错正负数]]></title>
    <url>%2FLintCode-144-%E4%BA%A4%E9%94%99%E6%AD%A3%E8%B4%9F%E6%95%B0%2F</url>
    <content type="text"><![CDATA[一、问题给出一个含有正整数和负整数的数组，重新排列成一个正负数交错的数组。 样例：给出数组[-1, -2, -3, 4, 5, 6]，重新排序之后，变成[-1, 5, -2, 4, -3, 6]或者其他任何满足要求的答案 二、思路正负数的个数有以下几种关系： 正数 &gt; 负数，则需要开头为正，即正负正负正 负数 &gt; 正数，则需要开头为负，即负正负正负 正数 = 负数，则开头可为正可为负 确定好开头以后，则奇数位置和A[0]同号，偶数位置和A[0]异号，不满足的位置交换。 三、代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263public class Solution &#123; /* * @param A: An integer array. * @return: nothing */ public void rerange(int[] A) &#123; // write your code here int negtiveCount = 0; int positiveCount = 0; int firstNeg = -1; int firstPos = -1; for (int i = 0; i &lt; A.length; i++) &#123; if (A[i] &lt; 0) &#123; negtiveCount++; if (firstNeg &lt; 0) &#123; firstNeg = i; &#125; &#125; else &#123; positiveCount++; if (firstPos &lt; 0) &#123; firstPos = i; &#125; &#125; &#125; // 根据正负数个数交换A[0]，使A[0]正负与最多的极性相同 if (negtiveCount &lt; positiveCount &amp;&amp; A[0] &lt; 0) &#123; int temp = A[0]; A[0] = A[firstPos]; A[firstPos] = temp; &#125; if (negtiveCount &gt; positiveCount &amp;&amp; A[0] &gt; 0) &#123; int temp = A[0]; A[0] = A[firstNeg]; A[firstNeg] = temp; &#125; int i = 1; int j = 2; while (i &lt; A.length &amp;&amp; j &lt; A.length) &#123; // A[1] A[3] 与 A[0] 异号 while (i &lt; A.length &amp;&amp; (A[i] &gt; 0) ^ (A[0] &gt; 0)) &#123; i += 2; &#125; // A[2] A[4] 与 A[0] 同号 while (j &lt; A.length &amp;&amp; !((A[j] &gt; 0) ^ (A[0] &gt; 0))) &#123; j += 2; &#125; // 如果遇到了不满足奇数位置与A[0]异号,偶数位置与A[0]同号的条件， // 则交换两个位置，并进行下一个比较 if (i &lt; A.length &amp;&amp; j &lt; A.length) &#123; int temp = A[i]; A[i] = A[j]; A[j] = temp; i += 2; j += 2; &#125; &#125; &#125;&#125;]]></content>
      <tags>
        <tag>算法</tag>
        <tag>LintCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[旋转数组]]></title>
    <url>%2F%E6%97%8B%E8%BD%AC%E6%95%B0%E7%BB%84%2F</url>
    <content type="text"><![CDATA[一、定义 原数组：[1,2,3,4,5,6,7] 旋转数组：[5,6,7,1,2,3,4] 二、LeetCode相关题目1. 问题描述：Rotate an array of n elements to the right by k steps. For example, with n = 7 and k = 3, the array [1,2,3,4,5,6,7] is rotated to [5,6,7,1,2,3,4] 解法1：使用辅助数组 1234567891011public class Solution &#123; public void rotate(int[] nums, int k) &#123; int[] a = new int[nums.length]; for (int i = 0; i &lt; nums.length; i++) &#123; a[(i + k) % nums.length] = nums[i]; &#125; for (int i = 0; i &lt; nums.length; i++) &#123; nums[i] = a[i]; &#125; &#125;&#125; 解法2：使用reverse 1234Original List : 1 2 3 4 5 6 7After reversing all numbers : 7 6 5 4 3 2 1After reversing first k numbers : 5 6 7 4 3 2 1After revering last n-k numbers : 5 6 7 1 2 3 4 --&gt; Result 123456789101112131415161718class Solution &#123; public void rotate(int[] nums, int k) &#123; k %= nums.length; reverse(nums, 0, nums.length - 1); reverse(nums, 0, k-1); reverse(nums, k, nums.length - 1); &#125; public void reverse(int[] nums, int start, int end) &#123; while (start &lt; end) &#123; nums[start] ^= nums[end]; nums[end] ^= nums[start]; nums[start] ^= nums[end]; start++; end--; &#125; &#125;&#125; 2. 问题描述： 1234567Suppose an array sorted in ascending order is rotated at some pivot unknown to you beforehand.(i.e., 0 1 2 4 5 6 7 might become 4 5 6 7 0 1 2).You are given a target value to search. If found in the array return its index, otherwise return -1.You may assume no duplicate exists in the array. 解法1：二分法 1234567891011121314151617181920212223242526class Solution &#123; public int search(int[] nums, int target) &#123; int left = 0; int right = nums.length - 1; int mid = 0; while (left &lt;= right) &#123; mid = left + (right - left) / 2; if (nums[mid] == target) return mid; if (nums[mid] &gt;= nums[left]) &#123; if (target &gt;= nums[left] &amp;&amp; target &lt;= nums[mid]) &#123; right = mid - 1; &#125; else &#123; left = mid + 1; &#125; &#125; else &#123; if (target &gt;= nums[mid] &amp;&amp; target &lt;= nums[right]) &#123; left = mid + 1; &#125; else &#123; right = mid - 1; &#125; &#125; &#125; return -1; &#125;&#125; 解法2：使用标准的二分法 参考：https://leetcode.com/problems/search-in-rotated-sorted-array/discuss/14435 12345678910111213141516171819class Solution &#123; public int search(int[] nums, int target) &#123; int left = 0; int right = nums.length - 1; int mid = 0; while (left &lt;= right) &#123; mid = left + (right - left) / 2; if (nums[mid] == target) return mid; int midNum = ((nums[mid] &gt;= nums[0]) == (target &gt;= nums[0])) ? nums[mid] : target &gt;= nums[0] ? Integer.MAX_VALUE : Integer.MIN_VALUE; if (target &lt; midNum) &#123; right = mid - 1; &#125; else &#123; left = mid + 1; &#125; &#125; return -1; &#125;&#125; 3. 问题描述： 与LeetCode 33题类似，多加了数组可能有重复元素的条件。 解法：二分法，和LeetCode 33题类似，只不过最坏情况下为O(n) 1234567891011121314151617181920212223242526272829303132333435363738public boolean search(int[] nums, int target) &#123; int start = 0, end = nums.length - 1; //check each num so we will check start == end //We always get a sorted part and a half part //we can check sorted part to decide where to go next while(start &lt;= end)&#123; int mid = start + (end - start)/2; if(nums[mid] == target) return true; //if left part is sorted if(nums[start] &lt; nums[mid])&#123; if(target &lt; nums[start] || target &gt; nums[mid])&#123; //target is in rotated part start = mid + 1; &#125;else&#123; end = mid - 1; &#125; &#125;else if(nums[start] &gt; nums[mid])&#123; //right part is rotated //target is in rotated part if(target &lt; nums[mid] || target &gt; nums[end])&#123; end = mid -1; &#125;else&#123; start = mid + 1; &#125; &#125;else&#123; //duplicates, we know nums[mid] != target, so nums[start] != target //based on current information, we can only move left pointer to skip one cell //thus in the worest case, we would have target: 2, and array like 11111111, then //the running time would be O(n) start ++; &#125; &#125; return false;&#125; 4. 问题描述：找非递减旋转数组中最小值 1234567891011121314151617181920212223242526class Solution &#123; public int findMin(int[] nums) &#123; if (nums[nums.length - 1] &gt; nums[0]) return nums[0]; int left = 0; int right = nums.length - 1; int mid = left; while (left &lt;= right) &#123; mid = left + (right - left) / 2; if (nums[mid] &gt; nums[right]) &#123; // 可以确定最小值在mid+1 ~ right 间 left = mid + 1; &#125; else if (nums[mid] &lt; nums[right]) &#123; // mid可能是最小值，最小值在left~mid间 right = mid; &#125; else &#123; if (nums[mid] == nums[left]) &#123; // mid 和 left、right相等，不能确定最小值在哪边，因此left++,right--,以此来找到最小值下次在哪边 left++; right--; &#125; else &#123; right = mid; // mid仅和right相等，则最小值应该在左边 &#125; &#125; &#125; return nums[mid]; &#125;&#125;]]></content>
      <tags>
        <tag>LeetCode</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode-154. Find Minimum in Rotated Sorted Array II]]></title>
    <url>%2FLeetCode-154-Find-Minimum-in-Rotated-Sorted-Array-II%2F</url>
    <content type="text"><![CDATA[问题描述： Suppose an array sorted in ascending order is rotated at some pivot unknown to you beforehand. (i.e., 0 1 2 4 5 6 7 might become 4 5 6 7 0 1 2). Find the minimum element. The array may contain duplicates. 解决方法：1. 常规解法从头遍历数组，遇到num[i] &lt; nums[i+1]截止，返回nums[i] 2. 二分法，根据旋转数组性质做旋转数组从最小值点到最小值点前一个点是非递减的。 分析left/mid/right： ① 若nums[mid] &gt; mid[right]最小值在mid+1~right间， 如图所示， △代表最小值 ② 若nums[mid] &lt; mid[right]最小值在left~mid间， 如图所示， △代表最小值 ③ 若nums[mid] == mid[right] 若 nums[mid] == nums[left]: 最小值不能确定在哪，则left++, right– 若 nums[mid] != nums[left]: 最小值在left~mid间 如图所示， △代表最小值 1234567891011121314151617181920212223242526class Solution &#123; public int findMin(int[] nums) &#123; if (nums[nums.length - 1] &gt; nums[0]) return nums[0]; // 如果一开始就有序的 int left = 0; int right = nums.length - 1; int mid = left; while (left &lt;= right) &#123; mid = left + (right - left) / 2; if (nums[mid] &gt; nums[right]) &#123; // 最小值在mid+1 ~ right 间 left = mid + 1; &#125; else if (nums[mid] &lt; nums[right]) &#123; // 最小值在left~mid间 right = mid; &#125; else &#123; if (nums[mid] == nums[left]) &#123; // mid 和 left、right相等，不能确定最小值在哪边，因此left++,right--,以此来找到最小值下次在哪边 left++; right--; &#125; else &#123; right = mid; // mid仅和right相等，则最小值应该在左边 &#125; &#125; &#125; return nums[mid]; &#125;&#125;]]></content>
      <tags>
        <tag>LeetCode</tag>
        <tag>算法</tag>
        <tag>二分法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[位运算]]></title>
    <url>%2F%E4%BD%8D%E8%BF%90%E7%AE%97%2F</url>
    <content type="text"><![CDATA[一、前言注意：位运算等数值计算的时候应注意考虑是否overflow，在对int型数据执行计算时可以将int转为long来保证不会overflow。 1. 数字编码数字在计算机当中的编码都是以补码形式存储。 参考: 知乎-原码、反码、补码的产生、应用以及优缺点有哪些 原码最高位为符号位，0表示正数，1表示负数；其他位表示数值 对于8位二进制，[1000 0001] 表示 -1;[0000 0001] 表示 1 其中[1000 0000] 表示 -0；[0000 0000] 表示 +0，因此对于8位二进制来说只能表示-127~127 反码正数不变；负数符号位不变，数值位取反。 [1000 0001]原 = [1111 1110]反 [0000 0001]原 = [0000 0001]反 解决了原码中-1和+1的和不为0的缺点，但还存在+0和-0 补码正数不变；负数符号位不变，先求反码，再+1 [1000 0001]原 = [1111 1110]反 = [1111 1111]补 [0000 0001]原 = [0000 0001]反 = [0000 0001]补 -1 + (+1) = [1111 1111]补 + [0000 0001]补 = [0000 0000]补 = 0 (-1) + (-127) = [1000 0001]原 + [1111 1111]原 = [1111 1111]补 + [1000 0001]补 = [1000 0000]补 即[1000 0000]补表示-128 2. 符号扩展/零扩展符号扩展：二进制中的有符号数，符号位总是位于数的第一位，如果向方位较大的数据类型进行扩展，符号位也应该位于第一位才对，所以当一个负数被扩展时，其扩展的高位全被置位为1 (由补码决定的)；对于整数，因为符号位是0，所以其扩展的位仍然是0。 零扩展：不管要转换成什么整型类型，不要最初值的符号位是什么，扩展的高位都被置位0. 从范围较小的整型类型转换位范围较大的整型类型时有个规定：如果最初的值的数值类型是有符号的，那么就执行符号扩展；如果最初的值是char类型的，那么不管它将要转换成什么类型的数据，都执行零扩展。 3. 位操作位操作优先级低于加减乘除，因此在做位运算时最好加上括号。 或运算0 | 0 = 0; 0 | 1 = 1; 1 | 0 = 1; 1 | 1 = 1 与运算1 &amp; 1 = 1; 1 &amp; 0 = 0; 0 &amp; 1 = 0; 0 &amp; 0 = 0 取反运算~1 = 0; ~0 = 1 异或运算1^0 = 1; 0^1 = 1; 0^0 = 0; 1^1 = 0; 两个位相同为0，相异为1。满足交换律，即1^0^1 = 1^1^0 = 0 左移运算丢弃左边指定位数，右边补0. 当int类型进行左移操作时，左移位数大于等于32位操作时，会先求余（%）后再进行左移操作 右移运算有符号右移( &gt;&gt; ): 丢弃右边指定位数，左边补上符号位, 当int类型进行右移操作时，右移位数大于等于32位操作时，会先求余（%）后再进行右移操作 无符号右移( &gt;&gt;&gt; ): 丢弃右边指定位数，左边补上0 对于正数来说，无符号右移和有符号右移一致。 二、位运算技巧1. 判断奇偶根据最未位是0还是1来决定，为0就是偶数，为1就是奇数 a &amp; 1 == 0 为偶数，否则为奇数 2. 交换两数12345a ^= b;b ^= a;a ^= b;// a = a ^ b, b = b ^ a ^ b = b ^ b ^ a = a, a = a ^ (a ^ b) = a ^ a ^ b = b 3. 变换符号-1 + 1 = 0 取反+1 1b = ~a + 1; 4. maskget第i位： x &amp; (1 &lt;&lt; i) set第i位： x | (1 &lt;&lt; i) clear第i位： x &amp; (~(1 &lt;&lt; i)) 5. 其他 n &amp; -n 得到最右边的1的值 n &amp; (n-1) 则是减掉了最右边的1的值 n = (n&amp;-n) | (n &amp; (n-1)) 例如 n = 0110, -n = 1010, n-1 = 0101,则n &amp; -n = 0010; n &amp; (n-1) = 0100, (n&amp;-n) | (n &amp; (n-1)) = 0110 = n 三、LeetCode 问题 Given an array of integers, every element appears twice except for one. Find that single one. 思路：以[a,a,b,b,c]为例 找出原数组中不同的数[a,b,c], 则2(a+b+c) - (a+a+b+b+c) = c 使用位运算, a^0 = a; a^a = 0;则出现两次的数异或运算以后都为0，a^a^b^b^c = 0^c = c 123456789class Solution &#123; public int singleNumber(int[] nums) &#123; int result = 0; for (int i = 0; i &lt; nums.length; i++) &#123; result ^= nums[i]; &#125; return result; &#125;&#125; Given an array of integers, every element appears three times except for one, which appears exactly once. Find that single one. 思路：以[a,a,a,b,b,b,c]为例 找出原数组中不同的数[a,b,c], 则3(a+b+c) - (a+a+a+b+b+b+c) = 2c 设a的第i位为1,b的第i位为0,c的第i位为1,则第i位为1总和为4，对3取余，剩下的就是c的第i位是否为1。用到了mask 1234567891011121314class Solution &#123; public int singleNumber(int[] nums) &#123; int res = 0; for (int i = 0; i &lt; 32; i++) &#123; int sum = 0; for (int j = 0; j &lt; nums.length; j++) &#123; sum += (nums[j] &gt;&gt; i) &amp; 1; &#125; int bit = (sum % 3 &gt; 0) ? 1 : 0; // 这样不论最后留下来的c是1次还是2次，都可以找到 res |= (bit &lt;&lt; i); &#125; return res; &#125;&#125; 利用2的思想，利用ab两个数字来表示第i位上第几次遇到1，根据真值表可以算出b = (b^nums[i]) &amp; ~a; a = (a ^ nums[i]) &amp; ~b; b得出的结果对应于except number只有1个的情况， a得出的结果对应except number有2个的情况。 参考： http://www.cnblogs.com/grandyang/p/4263927.html http://blog.csdn.net/yutianzuijin/article/details/50597413 123456789101112class Solution &#123; public int singleNumber(int[] nums) &#123; int one = 0; int two = 0; for (int i = 0; i&lt; nums.length; i++) &#123; one = (one ^ nums[i]) &amp; ~two; two = (two ^ nums[i]) &amp; ~one; &#125; return one | two; &#125;&#125; 扩展：若有m个数重复次数n次，其中有1个数重复a次（a&lt;n)。则可以用n-1个数来求真值表。 例如，其他数重复5次，有一个数重复1-4次，则可以选择a,b,c,d, a=0,b=0,c=0,d=0为初始状态，状态转移为0000-&gt;1000-&gt;0100-&gt;0010-&gt;0001-&gt;0000.从第一个变化的位开始求，接着求第二个开始变化的位…则任意位=其他位取反&amp;(该位^输入)，如a=~b &amp; ~c &amp; ~d &amp; (a ^ nums[i]); 123456789101112131415class Solution &#123; public int singleNumber(int[] nums) &#123; // int a = 0 , b = 0, c = 0; int a = 0 , b = 0, c = 0, d = 0; for (int i = 0; i &lt; nums.length; i++) &#123; a = ~b &amp; ~c &amp; ~d &amp; (a ^ nums[i]); b = ~a &amp; ~c &amp; ~d &amp; (b ^ nums[i]); c = ~a &amp; ~b &amp; ~d &amp; (c ^ nums[i]); d = ~a &amp; ~b &amp; ~c &amp; (d ^ nums[i]); // System.out.printf("a: %d, b: %d, c: %d\n", a, b, c); System.out.printf("a: %d, b: %d, c: %d, d: %d\n", a, b, c, d); &#125; return a; &#125;&#125; 注意：从第一个开始变化的位求，第一次变化的位代表的是最终重复次数为1的数。 Given an array of numbers nums, in which exactly two elements appear only once and all the other elements appear exactly twice. Find the two elements that appear only once. For example: Given nums = [1, 2, 1, 3, 2, 5], return [3, 5]. 思路： 所有的数进行异或运算，出现两次的数抵消，剩余两个不相等的数进行异或运算，假设结果为xor，则xor肯定有一位是1，选出xor的为1的某位，将原数组分成两个不同的数组，再对两个数组进行异或运算，得到两个只出现一次的结果 参考：http://www.cnblogs.com/grandyang/p/4741122.html 123456789101112131415161718192021class Solution &#123; public int[] singleNumber(int[] nums) &#123; int[] result = new int[2]; int xor = 0; for (int num : nums) &#123; xor ^= num; &#125; xor &amp;= -xor; for (int i = 0; i &lt; nums.length; i++) &#123; if ((xor &amp; nums[i]) != 0) &#123; result[0] ^= nums[i]; &#125; else &#123; result[1] ^= nums[i]; &#125; &#125; return result; &#125;&#125; Given an array containing n distinct numbers taken from 0, 1, 2, …, n, find the one that is missing from the array. Example 1 Input: [3,0,1]Output: 2 思路： 由于是从0到n连续的，找其中missing number，则从1到nums.length的和sum1减去nums的和sum2，即为缺失的值。 123456789101112class Solution &#123; public int missingNumber(int[] nums) &#123; int sum1 = 0; int sum2 = 0; for (int i = 1; i &lt;= nums.length; i++) &#123; sum1 += i; sum2 += nums[i-1]; &#125; return sum1 - sum2; &#125;&#125; 位运算，本问题和single number类似，input nums加上0~nums.length的数组中缺失的值出现一次，其他值都出现两次 12345678910class Solution &#123; public int missingNumber(int[] nums) &#123; int xor = 0; for (int i = 0; i &lt; nums.length; i++) &#123; xor ^= i; xor ^= nums[i]; &#125; return xor ^ nums.length; &#125;&#125; Given an integer, write a function to determine if it is a power of two. 思路： 判断奇偶，偶数的话右移1位继续判断奇偶，直到最后不再是偶数为止，最后结果若为1，则表示是2的power，否则返回false 123456789101112class Solution &#123; public boolean isPowerOfTwo(int n) &#123; if (n == 0) &#123; return false; &#125; while ((n &amp; 1) == 0) &#123; n &gt;&gt;= 1; &#125; return n == 1; &#125;&#125; 使用位运算，2的指数最高位为1，其余位为0。①若n是2的指数，则n &amp; (n-1) = 0; ②n &amp; -n为最右边为1的位得到的值，由于2的指数只有一位为1，因此若n为2的指数，则 n = n&amp;-n; 123456class Solution &#123; public boolean isPowerOfTwo(int n) &#123; if (n &lt;= 0) return false; return (n &amp; (n-1)) == 0; &#125;&#125; 123456class Solution &#123; public boolean isPowerOfTwo(int n) &#123; if (n &lt;= 0) return false; return n == (n &amp; -n); &#125;&#125; Given an integer (signed 32 bits), write a function to check whether it is a power of 4. 思路： 在判别是2的指数的基础上，看是否是4的指数，4的指数的1的位置一定在基数位置，因此可以num &amp; 0x55555555 != 0 来判断. 12345class Solution &#123; public boolean isPowerOfFour(int num) &#123; return num &gt; 0 &amp;&amp; (num &amp; (num-1)) == 0 &amp;&amp; (num &amp; 0x55555555) != 0; &#125;&#125; Divide two integers without using multiplication, division and mod operator. If it is overflow, return MAX_INT. 思路：以15/3为例，15=3*4+3*1. 当dividend大于divisor的时候,divisor左移,直到dividend小于等于divisor. 3 &lt;&lt; 2 = 12 &lt; 15, 3 &lt;&lt; 3 = 24 &gt; 15,使用剩余的数15-12当做被除数,3作为除数,继续执行之前的步骤,3 &lt;&lt; 0 = 3 &lt; 4, 3 &lt;&lt; 1 = 6 &gt; 4.而4 - 3 = 1 &lt; 3,可以得到结果了,结果为1 &lt;&lt; 2 + 1 &lt;&lt; 0 = 5 注意overflow的情况 参考: https://leetcode.com/problems/divide-two-integers/discuss/ 123456789101112131415161718192021222324252627282930313233class Solution &#123; public int divide(int dividend, int divisor) &#123; // 判断除数，被除数的情况 if (divisor == 0 || (dividend == Integer.MIN_VALUE &amp;&amp; divisor == -1)) &#123; return Integer.MAX_VALUE; &#125; long ldividend = dividend; long ldivisor = divisor; // 判断最终输出的符号 int sign = 1; if (ldividend &lt; 0) &#123; sign *= -1; ldividend = -ldividend; &#125; if (ldivisor &lt; 0) &#123; sign *= -1; ldivisor = -ldivisor; &#125; int result = 0; while (ldividend &gt;= ldivisor) &#123; long multiple = 1; long temp = ldivisor; while (ldividend &gt;= (temp &lt;&lt; 1)) &#123; temp &lt;&lt;= 1; multiple &lt;&lt;= 1; &#125; result += multiple; ldividend = ldividend - temp; &#125; return result*sign; &#125;&#125; Implement pow(x, n). Example 1: Input: 2.00000, 10Output: 1024.00000 思路： (x^y^)^z^ = x^yz^ x^14^ = (x^2^)^14/2^ x^7^ = x(x^2^)^7/2^ x^3^ = x(x^2^)^3/2^ 即当y为偶数时x^y^ = (x^2^)^y/2^, 当y为奇数时x^y^ = x(x^2^)^y/2^ 123456789101112131415161718192021class Solution &#123; public double myPow(double x, int n) &#123; long ln = n; if (n &lt; 0) &#123; x = 1/x; ln = -ln; &#125; if (ln == 0) return 1; return pow(x, ln); &#125; public double pow(double x, long n) &#123; if (n == 1) return x; if ((n&amp;1) == 0) &#123; return pow(x*x, (n &gt;&gt; 1)); &#125; else &#123; return x*pow(x*x, (n &gt;&gt; 1)); &#125; &#125;&#125; Write a function that takes an unsigned integer and returns the number of ’1’ bits it has (also known as the Hamming weight). For example, the 32-bit integer ’11’ has binary representation 00000000000000000000000000001011, so the function should return 3. 思路： 常规解法，循环32次，将每一位通过mask得到是否为1 使用n = n &amp; (n-1)，每次都会将最右边的1置为0，直到n为0 第二种解法代码： 1234567891011public class Solution &#123; // you need to treat n as an unsigned value public int hammingWeight(int n) &#123; int count = 0; while (n != 0) &#123; count++; n = n &amp; (n - 1); &#125; return count; &#125;&#125; 参考：https://leetcode.com/problems/number-of-1-bits/solution/]]></content>
      <tags>
        <tag>LeetCode</tag>
        <tag>算法</tag>
        <tag>位运算</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode-动态规划问题]]></title>
    <url>%2FLeetCode-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[一、前言动态规划适用范围： 求最大值最小值 判断是否可行 统计方案个数 动态规划不适用的情况： 求出所有具体的方案（注：也可以结合动态规划，把动态规划作为预处理，然后再求具体方案） 输入数据是一个集合而不是序列 暴力算法的复杂度已经是多项式级别 动态规划 动态规划问题类型可分为： 坐标型 15% 序列型 30% 双序列型 30% 划分型 10% 区间型 5% 背包型 10% 求解动态规划的关键在于： 定义原问题的状态，分解成子问题求解 确定状态的转移方程，确定当前状态由哪些状态可以转移到 确定状态的初始值 根据递推式求解（递推式遍历的时候确定好遍历方式，对于二维动态规划先去固定一个的遍历方式，行或列先去遍历，然后再确定另外一个列或行的遍历方式） 二、LeetCode 问题LeetCode-5.Longest Palindromic Substring 问题描述：Given a string s, find the longest palindromic substring in s. You may assume that the maximum length of s is 1000. Example:12345Input: "babad"Output: "bab"Note: "aba" is also a valid answer. 思路：1.可以使用动态规划求解。第一步，拆分问题： 设dp[i][j]表示String的第i位到第j位组成的字符串是否为回文求max(j-i)对应的回文子串 状态dp[i][j] 第二步，状态初始值 第三步，状态转移方程： dp[i][j] = s.charAt(i) == s.charAt(j) &amp;&amp; (i+1 &gt;= j-1 || dp[i+1][j-1]) 当i+1 &gt;= j-1的时候dp[i+1][j-1]肯定是true，但由于遍历的时候只遍历了dp[i][j]中i= j-1这样的状态直接是true了 这样已经能唯一确定dp[i][j]了，不需要dp[i+1][j]或者dp[i][j-1] 要遍历dp[i][j]有3种方式： ①固定i，比如i=3，则j要从大于等于i的地方开始，直到n，由于i依赖于i+1，因此i要从n-1开始，循环体为for(int i = s.length() - 1; i &gt;=0; i–) for(int j = i; j &lt; s.length(); j++); ②固定j，比如j=3,则i因为依赖于i+1，因此i从小于等于3的位置开始(因为dp[i][j]表示String的第i位到第j位组成的字符串是否为回文，i]]></content>
      <tags>
        <tag>LeetCode</tag>
        <tag>算法</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode-回溯问题]]></title>
    <url>%2FLeetCode-%E5%9B%9E%E6%BA%AF%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[一、前言回溯法适用于：1.求解所有解；2.求解排列组合。 回溯法解题一般步骤： 针对所给问题，确定问题的解空间：首先应明确定义问题的解空间，问题的解空间应至少包含问题的一个（最优）解。 确定结点的扩展搜索规则 以深度优先方式搜索解空间，并在搜索过程中用剪枝函数避免无效搜索。 回溯法可以看成是蛮力法的升级版，它从解决问题每一步的所有可能选项里系统的选择出一个可行的解决方案。回溯法非常适合由多个步骤组成的问题，并且每个步骤都有多个选项。当我们在某一步选择了其中一个选项时，就进入下一步，然后面临新的选项。我们就这么重复选择，直至到达最终的状态。 具体求解时，先要确定问题由哪些步骤组成，每一个步骤i有哪些选项，即深度为i的有多少路径可以选择。 组合问题是没有顺序的，[3,1]和[1,3]一致，因此一般在选择了某个数以后，则只能选择该数及该数以后的数（即当前深度选择后要从当前的选择出发再进行选择） for (int i = start; i &lt; n; i++) backtracking(i+1) 或backtracking(i); 排列问题是有顺序的，(3,1)和(1,3)是不同的， 因此一般在选择了某个数以后，可以选择所有的数（有些问题排除当前使用过的数） for(int i = 0; i &lt; n; i++) 二、LeetCode 问题组合问题问题描述：Given a set of distinct integers, nums, return all possible subsets (the power set). Note: The solution set must not contain duplicate subsets. 解决方法 回溯代码： 12345678910111213public void backtracking(start) &#123; result.add(temp); for (int i = start; i &lt; n; i++) &#123; // 枚举当前状态下所有路径 temp.add(nums[i]); // 添加当前元素 backtracking(i+1); // 到下一状态 temp.remove(temp.size() - 1); // 删除当前元素，回溯，选择下一个选择点 &#125;&#125;// 最外层i = 0 时得到[] [1] [1,2] [1,2,3] [1,3]// 最外层i = 1 时得到[2] [2,3]// 最外层i = 2 时得到[3] 位运算代码： 123456789101112//思路：所有的组合可能性为2^n，根据位运算确定某个数是否在组合中，比如111表示[1,2,3],110表示[1,2]等等int numOfSet = 2 &lt;&lt; (nums.length - 1);for (int i = 0; i &lt; numOfSet; i++) &#123; List&lt;Integer&gt; temp = new ArrayList&lt;&gt;(); for (int j = 0; j &lt; nums.length; j++) &#123; if (i &gt;&gt; j &amp; 1 == 1) &#123; //第j个元素是否选择 temp.add(nums[j]); &#125; &#125; result.add(temp);&#125; 问题描述：Given a collection of integers that might contain duplicates, nums, return all possible subsets (the power set). Note: The solution set must not contain duplicate subsets. For example,If nums = [1,2,2], a solution is:[[], [1], [1,2], [1,2,2], [2], [2,2]] 回溯代码：1234567891011121314// Arrays.sort(nums); 首先要将nums排序，则相同的元素肯定相邻。public void backtracking(int start, int[] nums) &#123; result.add(new ArrayList(temp)); for (int i = start; i &lt; nums.length; i++) &#123; //枚举当前状态下所有路径 temp.add(nums[i]); backtracking(i+1, nums); temp.remove(temp.size() - 1); // 回溯 //关键：在回溯的时候相邻的如果相等就不能再选择了，会重复，因此找到一个i使得不会重复选择相同元素。 while (i &lt; nums.length - 1 &amp;&amp; nums[i+1] == nums[i]) &#123; i++; &#125; &#125;&#125; 问题描述：Given a set of candidate numbers (C) (without duplicates) and a target number (T), find all unique combinations in C where the candidate numbers sums to T. The same repeated number may be chosen from C unlimited number of times. Note:All numbers (including target) will be positive integers.The solution set must not contain duplicate combinations.For example, given candidate set [2, 3, 6, 7] and target 7,A solution set is: [[2,2,3],[7]] 回溯代码123456789101112131415161718// Arrays.sort(nums);public void backtracking(int start, int[] nums, int target) &#123; if (target == 0) &#123; // 满足条件输出结果 result.add(new ArrayList(temp)); return; &#125; for (int i = start; i &lt; nums.length; i++) &#123; // 枚举路径 if (target &lt; nums[i]) break; temp.add(nums[i]); // 由于可以有重复数据相加，比如[2,2,3],因此要从i开始继续找。 backtracking(i, nums, target-nums[i]); temp.remove(temp.size() - 1); &#125;&#125; 问题描述：Given a collection of candidate numbers (C) and a target number (T), find all unique combinations in C where the candidate numbers sums to T. Each number in C may only be used once in the combination. Note: All numbers (including target) will be positive integers. The solution set must not contain duplicate combinations. For example, given candidate set [10, 1, 2, 7, 6, 1, 5] and target 8, A solution set is:123456[ [1, 7], [1, 2, 5], [2, 6], [1, 1, 6]] 回溯代码:123456789101112131415161718// Arrays.sort(candidates);public void backtracking(int start, int[] candidates, int target) &#123; if (target == 0) &#123; result.add(new ArrayList(temp)); return; &#125; for (int i = start; i &lt; candidates.length; i++) &#123; if (target &lt; candidates[i]) break; temp.add(candidates[i]); backtracking(i+1, candidates, target-candidates[i]); // 不再使用重复数据，则需要从i+1处开始 temp.remove(temp.size() - 1); // 回溯到不相同的元素 while(i &lt; candidates.length - 1 &amp;&amp; candidates[i] == candidates[i+1]) &#123; i++; &#125; &#125; &#125; 问题描述：Find all possible combinations of k numbers that add up to a number n, given that only numbers from 1 to 9 can be used and each combination should be a unique set of numbers. Example 1: Input: k = 3, n = 7 Output: [[1,2,4]] 回溯代码：123456789101112131415// candidates = new int[]&#123;1,2,3,4,5,6,7,8,9&#125;;public void backtracking(int start, int[] candidates, int k, int target) &#123; if (target == 0 &amp;&amp; temp.size() == k) &#123; result.add(new ArrayList(temp)); //满足条件输出 return; &#125; if (temp.size() &lt; k) &#123; for (int i = start; i &lt; candidates.length; i++) &#123; if (target &lt; candidates[i]) break; temp.add(candidates[i]); backtracking(i+1, candidates, k, target-candidates[i]); //由于不找[1,1,5], [2,2,3]这样的，所以从i+1开始 temp.remove(temp.size() - 1); // 回溯 &#125; &#125;&#125; 问题描述：Given an integer array with all positive numbers and no duplicates, find the number of possible combinations that add up to a positive integer target. Example: 123456789101112131415nums = [1, 2, 3]target = 4The possible combination ways are:(1, 1, 1, 1)(1, 1, 2)(1, 2, 1)(1, 3)(2, 1, 1)(2, 2)(3, 1)Note that different sequences are counted as different combinations.Therefore the output is 7. 思路：本题中(1,3)和(3,1)是两种不同的组合，且求的是数目不是之前用回溯法求的具体的组合。4可以由3,2,1组成，则combinations(4) = combinations(3) + combinations(2) + combinations(1); 而conbinations(3) = combinations(2) + combinations(1), 因此可以使用dp来做。 原问题可以表述为： 设dp[i]表示和为i的combinations个数求dp[target] 状态定义dp[i]; 状态转移方程： dp[i] += dp[i-nums[k]] for i &gt; nums[k]; 状态初始值： dp[0] = 1; 返回[],所以有1种方案 根据递推关系得出结果 123456789101112131415161718192021class Solution &#123; public int combinationSum4(int[] candidates, int target) &#123; if (candidates.length == 0) return 0; Arrays.sort(candidates); int n = target + 1; int[] dp = new int[n]; dp[0] = 1; //状态初始值 for (int i = 0; i &lt; n; i++) &#123; for (int j = 0; j &lt; candidates.length; j++) &#123; // 状态转移方程 if (i &gt;= candidates[j]) &#123; dp[i] += dp[i-candidates[j]]; &#125; &#125; &#125; return dp[target]; &#125; &#125; 问题描述：Given a digit string, return all possible letter combinations that the number could represent. A mapping of digit to letters (just like on the telephone buttons) is given below. 12Input:Digit string "23"Output: ["ad", "ae", "af", "bd", "be", "bf", "cd", "ce", "cf"]. 解决方法： 回溯代码： 12345678910111213141516171819202122232425class Solution &#123; List&lt;String&gt; result; String[] charmap = new String[]&#123;"0", "1", "abc", "def", "ghi", "jkl", "mno", "pqrs", "tuv", "wxyz"&#125;; char[] chars; public List&lt;String&gt; letterCombinations(String digits) &#123; chars = digits.toCharArray(); result = new ArrayList&lt;&gt;(); if (digits.equals(""))&#123; return result; &#125; backtracking(0, chars.length, ""); return result; &#125; public void backtracking(int index, int n, String s) &#123; // index表示当前在第几个digit，如果到了最后一个digit则输出,当前状态由index确定 if (index &gt;= n) &#123; result.add(s); return ; &#125; char[] map = charmap[chars[index]-'0'].toCharArray(); for (int i = 0; i &lt; map.length; i++) &#123; backtracking(index+1, n, s+map[i]); &#125; &#125;&#125; 迭代 1234567891011121314151617181920212223242526class Solution &#123; public List&lt;String&gt; letterCombinations(String digits) &#123; String[] charmap = new String[]&#123;"0", "1", "abc", "def", "ghi", "jkl", "mno", "pqrs", "tuv", "wxyz"&#125;; char[] chars = digits.toCharArray(); List&lt;String&gt; result = new ArrayList&lt;&gt;(); if (digits.equals(""))&#123; return result; &#125; result.add(""); // 逐个digit处理添加到result中 // "234" 可以先处理'2',然后'23',然后'234' for (int i = 0; i &lt; chars.length; i++) &#123; List&lt;String&gt; res = new ArrayList&lt;&gt;(); char[] map = charmap[chars[i]-'0'].toCharArray(); for (int j = 0; j &lt; map.length; j++) &#123; for (String s : result) &#123; res.add(s + map[j]); &#125; &#125; result = res; &#125; return result; &#125;&#125; 问题描述：Given a string s, partition s such that every substring of the partition is a palindrome. Return all possible palindrome partitioning of s. For example, given s = “aab”, Return1234[ ["aa","b"], ["a","a","b"]] 思路“aab”划分的时候从0位置找第一个回文子串的划分位置i，然后接着上一个找到的回文子串的位置处i+1继续找第二个回文子串，直到找到末尾。 i是状态，表示找的起始位置，和N皇后问题类似，只有满足约束以后才继续往下一状态找，否则回溯。 回溯代码：1234567891011121314151617181920212223242526List&lt;List&lt;String&gt;&gt; result;List&lt;String&gt; temp;public void backtracking(String s, int start) &#123; if (start &gt;= str.length) &#123; result.add(new ArrayList(temp)); return; &#125; for (int i = start; i &lt; str.length; i++) &#123; //枚举当前状态下所有路径 if (isPalindrome(s, start, i)) &#123; //满足是回文之后才继续找下一个回文子串 temp.add(s.subString(start, i+1)); backtracking(s, i+1); temp.remove(temp.size() - 1); &#125; &#125;&#125;// 判断start到end位置的子串是否回文public boolean isPalindrome(String s, int start, int end) &#123; // 逐渐往中间靠拢 while (start &lt; end) &#123; if (s.charAt(start++) != s.charAt(end--)) &#123; return false; &#125; &#125; return true;&#125; 排列问题问题描述：Given a collection of distinct numbers, return all possible permutations. For example,[1,2,3] have the following permutations:[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]] 回溯代码：状态空间树: 12345678910111213141516171819// boolean[] isUsed = new boolean[nums.length];public void backtracking(int start, int[] nums) &#123; if (temp.size() &gt;= nums.length) &#123; result.add(temp); //满足条件 return; &#125; for (int i = 0; i &lt; nums.length; i++) &#123; //路径不再是从start开始了 if (!isUsed[i]) &#123; //判断之前是否已经添加过了 isUsed[i] = true; temp.add(nums[i]); backtracking(i+1, nums); temp.remove(temp.size() - 1); isUsed[i] = false; &#125; &#125;&#125; 问题描述：Given a collection of numbers that might contain duplicates, return all possible unique permutations. For example,[1,1,2] have the following unique permutations:[ [1,1,2], [1,2,1], [2,1,1]] 回溯代码：123456789101112131415161718public void backtracking(int start, int[] nums) &#123; if (temp.size() &gt;= nums.length) &#123; result.add(new ArrayList(temp)); return; &#125; for (int i = 0; i &lt; nums.length; i++) &#123; if (!isUsed[i]) &#123; isUsed[i] = true; temp.add(nums[i]); backtracking(i + 1, nums); temp.remove(temp.size() - 1); // 回溯 isUsed[i] = false; while(i &lt; nums.length - 1 &amp;&amp; nums[i] == nums[i+1]) &#123; i++; //找到不相同的再开始 &#125; &#125; &#125;&#125; 问题描述：Given a non-negative integer n, count all numbers with unique digits, x, where 0 ≤ x &lt; 10n. Example:Given n = 2, return 91. (The answer should be the total numbers in the range of 0 ≤ x &lt; 100, excluding [11,22,33,44,55,66,77,88,99]) 回溯代码：可以等价于排列问题，由[0,1,2,3,4,5,6,7,8,9]组成1到3位数，判断是否有相同的数 1234567891011121314151617181920212223242526272829303132class Solution &#123; private int count = 0; private boolean[] isUsed = new boolean[10]; public int countNumbersWithUniqueDigits(int n) &#123; int total = 1; for (int i = 0; i &lt; n; i++) &#123; total *= 10; &#125; backtracking(0, 0, n, false); return total - count; &#125; public void backtracking(int start, int k, int n, boolean isDuplicate) &#123; if (isDuplicate) &#123; count++; &#125; if (k &gt;= n) &#123; return; &#125; for (int i = 0; i &lt; 10; i++) &#123; if (start == 0 &amp;&amp; i == 0) continue; if (isUsed[i]) &#123; backtracking(start+1, k+1, n, true); &#125; else &#123; isUsed[i] = true; backtracking(start+1, k+1, n, isDuplicate); isUsed[i] = false; &#125; &#125; &#125;&#125; O(1)代码：This is a digit combination problem. Can be solved in at most 10 loops. When n == 0, return 1. I got this answer from the test case. When n == 1, _ can put 10 digit in the only position. [0, … , 10]. Answer is 10. When n == 2, first digit has 9 choices [1, …, 9], second one has 9 choices excluding the already chosen one. So totally 9 * 9 = 81. answer should be 10 + 81 = 91 When n == 3, _ total choice is 9 9 8 = 684. answer is 10 + 81 + 648 = 739 When n == 4, total choice is 9 9 8 * 7. … When n == 10, total choice is 9 9 8 7 6 5 4 3 2 * 1 When n == 11, _ total choice is 9 9 8 7 6 5 4 3 2 1 0 = 0 12345678910111213141516class Solution &#123; public int countNumbersWithUniqueDigits(int n) &#123; if (n == 0) return 1; int result = 10; int k = 9; int exclude = 9; while (k &gt;= 1 &amp;&amp; --n &gt; 0) &#123; exclude *= k; result += exclude; k--; &#125; return result; &#125;&#125;]]></content>
      <tags>
        <tag>LeetCode</tag>
        <tag>算法</tag>
        <tag>回溯</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[回溯法]]></title>
    <url>%2F%E5%9B%9E%E6%BA%AF%E6%B3%95%2F</url>
    <content type="text"><![CDATA[一、概念回溯法（英语：backtracking）是暴力搜寻法中的一种。对于某些计算问题而言，回溯法是一种可以找出所有（或一部分）解的一般性算法，尤其适用于约束满足问题（在解决约束满足问题时，我们逐步构造更多的候选解，并且在确定某一部分候选解不可能补全成正确解之后放弃继续搜索这个部分候选解本身及其可以拓展出的子候选解，转而测试其他的部分候选解）。 许多复杂的，规模较大的问题都可以使用回溯法，有“通用解题方法”的美称。 若用回溯法求问题的所有解时，要回溯到根，且根结点的所有可行的子树都要已被搜索遍才结束。而若使用回溯法求任一个解时，只要搜索到问题的一个解就可以结束。 二、基本思想回溯法的基本思想是按照输入数组的顺序，每一层递归处理一个元素，当处理到最后一层的时候，也就是把数组中的所有元素都处理完的时候，把当前结果加入到最后的返回结果中。值得注意的是，每次在递归到下一层之前，我们加入了某个要处理的元素X，在下一层递归返回之后，我们要把之前加入的元素X从当前结果中取出来。如果我们不把元素X取出来，那么在下一次循环中，我们还会加入新的元素Y。那么在这一层递归中就相当于处理了不止一个新元素。 三、框架1. 递归形式伪代码：123456789101112backtracking(当前状态) &#123; if 当前状态达到目标： 输出结果或记录 for (int i = 下界; i &lt; 上界; i++) &#123; //枚举当前状态下所有路径 if (constrain(i)) &#123; board[i] = 1; //修改全局变量 backtracking(下一状态); board[i] = 0; //恢复全局变量，回溯之前的清理 &#125; &#125;&#125; 2. 非递归形式伪代码：123456789101112while (有路径可走 &amp;&amp; 未达到目标) &#123; for 在解空间找解 if 找到解 &#123; if 达到目标 &#123; 记录解或输出结果 &#125; else &#123; 到下一个子问题找解，i++ &#125; &#125; else &#123; i--; &#125;&#125; 四、扩展：递归转非递归 递归的基本思想是把规模大的问题转化为规模小的相似的子问题来解决。在函数实现时，因为解决大问题的方法和解决小问题的方法往往是同一个方法，所以就产生了函数调用它自身的情况。另外这个解决问题的函数必须有明显的结束条件，这样就不会产生无限递归的情况了 In mathematics and computer science, a class of objects or methods exhibit recursive behavior when they can be defined by two properties:A simple base case (or cases)—a terminating scenario that does not use recursion to produce an answerA set of rules that reduce all other cases toward the base case 递归就是有去（递去）有回（归来）。 所有递归都可以用非递归的方式实现。 递归的过程其实是编译器帮我们处理了压栈和出栈的操作，转换为迭代函数就需要手动地处理压栈和出栈（或者直接根据递推形式转换为循环结构，不借助堆栈）。 五、相关问题LeetCode-回溯法问题 六、参考回溯法模板 wiki-回溯]]></content>
      <tags>
        <tag>算法</tag>
        <tag>回溯</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LintCode-33.N皇后问题]]></title>
    <url>%2FLintCode-33-N%E7%9A%87%E5%90%8E%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[一、问题描述n皇后问题是将n个皇后放置在n*n的棋盘上，皇后彼此之间不能相互攻击。 给定一个整数n，返回所有不同的n皇后问题的解决方案。 每个解决方案包含一个明确的n皇后放置布局，其中“Q”和“.”分别表示一个女王和一个空位置。 二、解题方法N皇后是典型的回溯问题，当row中未找到位置时向上回溯。 1. 递归版伪代码：12345678①遍历当前行所有位置，找满足条件的位置 找到： ② 当前行是否为最后一行?: 是：输出结果或记录; 否：找下一行，回到① 未找到： 回到上一行，函数返回 使用矩阵记录board，board[i][j]上有queen则为1，无queen则为0. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657public class Solution &#123; private int[][] board; /* * @param n: The number of queens * @return: All distinct solutions */ public List&lt;List&lt;String&gt;&gt; solveNQueens(int n) &#123; // write your code here List&lt;List&lt;String&gt;&gt; result = new ArrayList&lt;&gt;(); board = new int[n][n]; solve(result, 0, n); return result; &#125; public void solve(List&lt;List&lt;String&gt;&gt; result, int row, int n) &#123; for (int i = 0; i &lt; n; i++) &#123; if (isSafe(row, i, n)) &#123; // 满足限定条件 board[row][i] = 1; // 占住位置 if (row == n-1) &#123; //只有满足条件时才将结果赋值 result.add(getResult(n)); &#125; else &#123; solve(result, row + 1, n); // 到下一行 &#125; board[row][i] = 0; // 否则换位置，并清理位置，回溯 &#125; &#125; &#125; public List&lt;String&gt; getResult(int n) &#123; List&lt;String&gt; result = new ArrayList&lt;&gt;(); StringBuilder sb = new StringBuilder(); for (int i = 0; i &lt; n; i++) &#123; for (int j = 0; j &lt; n; j++) &#123; if (board[i][j] == 0) &#123; sb.append("."); &#125; else &#123; sb.append("Q"); &#125; &#125; result.add(sb.toString()); sb.setLength(0); &#125; return result; &#125; public boolean isSafe(int row, int column, int n) &#123; for (int i = 0; i &lt; row; i++) &#123; for (int j = 0; j &lt; n; j++) &#123; if ((i + j == row + column || i - j == row - column || j == column) &amp;&amp; board[i][j] == 1) &#123; return false; &#125; &#125; &#125; return true; &#125;&#125; 使用数组记录queen的位置，(row,col)位置上有queen则queens[row] = col. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859public class Solution &#123; private int[] queens; //每一行只有一个queen，所有只要一维n数组即可。 /* * @param n: The number of queens * @return: All distinct solutions */ public List&lt;List&lt;String&gt;&gt; solveNQueens(int n) &#123; // write your code here List&lt;List&lt;String&gt;&gt; result = new ArrayList&lt;&gt;(); queens = new int[n]; for (int i = 0; i &lt; n; i++) &#123; queens[i] = -1; &#125; solve(result, 0, n); return result; &#125; public void solve(List&lt;List&lt;String&gt;&gt; result, int row, int n) &#123; if (row == n) &#123; //只有满足条件时才将结果赋值 result.add(getResult(n)); &#125; for (int i = 0; i &lt; n; i++) &#123; if (isSafe(row, i, n)) &#123; // 满足限定条件 queens[row] = i; // 占住位置 if (row == n-1) &#123; //只有满足条件时才将结果赋值 result.add(getResult(n)); &#125; else &#123; solve(result, row + 1, n); // 到下一行 &#125; &#125; &#125; &#125; public List&lt;String&gt; getResult(int n) &#123; List&lt;String&gt; result = new ArrayList&lt;&gt;(); StringBuilder sb = new StringBuilder(); for (int i = 0; i &lt; n; i++) &#123; for (int j = 0; j &lt; n; j++) &#123; if (j != queens[i]) &#123; sb.append("."); &#125; else &#123; sb.append("Q"); &#125; &#125; result.add(sb.toString()); sb.setLength(0); &#125; return result; &#125; public boolean isSafe(int row, int column, int n) &#123; for (int i = 0; i &lt; row; i++) &#123; if (queens[i] + i == row + column || i - queens[i] == row - column || queens[i] == column) &#123; return false; &#125; &#125; return true; &#125;&#125; 2. 非递归版伪代码：12345678while row &gt;= 0: 在当前row找满足条件的位置; 找到： 当前行是否为最后一行?: 是：输出结果或记录; 否：寻找下一行，row++，且要从0列开始找 未找到： 返回前一行，从前一行的下个位置继续找，row-- 思考过程可以采取某个特殊的行，比如row=3来看。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061public class Solution &#123; private int[] queens; /* * @param n: The number of queens * @return: All distinct solutions */ public List&lt;List&lt;String&gt;&gt; solveNQueens(int n) &#123; // write your code here List&lt;List&lt;String&gt;&gt; result = new ArrayList&lt;&gt;(); queens = new int[n]; for (int i = 0; i &lt; n; i++) &#123; queens[i] = -1; &#125; int row = 0; while (row &gt;= 0) &#123; queens[row]++; while(!isSafe(row, queens[row], n)) &#123; //当前行找满足条件的列 queens[row]++; &#125; if (queens[row] &lt; n) &#123; // 如果当前行找到 if (row == n-1) &#123; result.add(getResult(n)); //如果是最后一行 &#125; else &#123; // 如果还未到最后，则接着找下一行 queens[++row] = -1; &#125; &#125; else &#123; // 如果当前行未找到满足条件的，则回溯 row--; &#125; &#125; return result; &#125; public List&lt;String&gt; getResult(int n) &#123; List&lt;String&gt; result = new ArrayList&lt;&gt;(); StringBuilder sb = new StringBuilder(); for (int i = 0; i &lt; n; i++) &#123; for (int j = 0; j &lt; n; j++) &#123; if (j != queens[i]) &#123; sb.append("."); &#125; else &#123; sb.append("Q"); &#125; &#125; result.add(sb.toString()); sb.setLength(0); &#125; return result; &#125; public boolean isSafe(int row, int column, int n) &#123; for (int i = 0; i &lt; row; i++) &#123; if (queens[i] + i == row + column || i - queens[i] == row - column || queens[i] == column) &#123; return false; &#125; &#125; return true; &#125;&#125; 参考非递归求解N皇后问题（回溯法） N皇后问题位运算求解 位运算求解N皇后问题-csdn]]></content>
      <tags>
        <tag>LintCode. 算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LintCode-162. 矩阵归零]]></title>
    <url>%2FLintCode-162-%E7%9F%A9%E9%98%B5%E5%BD%92%E9%9B%B6%2F</url>
    <content type="text"><![CDATA[一、问题描述给定一个m×n矩阵，如果一个元素是0，则将其所在行和列全部元素变成0。 需要在原矩阵上完成操作。 二、解决方法1. O(mn)空间复杂度12345678910111213141516171819202122232425262728293031public class Solution &#123; /* * @param matrix: A lsit of lists of integers * @return: */ public void setZeroes(int[][] matrix) &#123; // write your code here int m = matrix.length; if (m == 0) return; int n = matrix[0].length; if (n == 0) return; boolean[] rows = new boolean[m]; boolean[] columns = new boolean[n]; for (int i = 0; i &lt; m; i++) &#123; for (int j = 0; j &lt; n; j++) &#123; if (matrix[i][j] == 0) &#123; rows[i] = true; columns[j] = true; &#125; &#125; &#125; for (int i = 0; i &lt; m; i++) &#123; for (int j = 0; j &lt; n; j++) &#123; if (rows[i] || columns[j]) &#123; matrix[i][j] = 0; &#125; &#125; &#125; &#125;&#125; 2. O(1)空间复杂度思路：借用matrix第0行，第0列，遍历剩下的行和列，若在剩下的行和列中出现0，则将所在行或列的第0个元素设置为0。即m[i][j] = 0 =&gt; m[0][j] = 0; m[i][0] = 0; 注意matrix除去0行0列可能没有元素，且m[0][0]的最终值要根据matrix[0][j]和matrix[i][0]处理，因此要对第0行和第0列进行特殊处理。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354public class Solution &#123; /* * @param matrix: A lsit of lists of integers * @return: */ public void setZeroes(int[][] matrix) &#123; // write your code here int m = matrix.length; if (m == 0) return; int n = matrix[0].length; if (n == 0) return; boolean isFirstRowZero = false; boolean isFirstColZero = false; for (int i = 0; i &lt; m; i++) &#123; if (matrix[i][0] == 0) &#123; isFirstColZero = true; &#125; &#125; for (int j = 0; j &lt; n; j++) &#123; if (matrix[0][j] == 0) &#123; isFirstRowZero = true; &#125; &#125; for (int i = 1; i &lt; m; i++) &#123; for (int j = 1; j &lt; n; j++) &#123; if (matrix[i][j] == 0) &#123; matrix[0][j] = 0; matrix[i][0] = 0; &#125; &#125; &#125; for (int i = 1; i &lt; m; i++) &#123; for (int j = 1; j &lt; n; j++) &#123; if (matrix[i][0] == 0 || matrix[0][j] == 0) &#123; matrix[i][j] = 0; &#125; &#125; &#125; if (isFirstColZero) &#123; for (int i = 0; i &lt; m; i++) &#123; matrix[i][0] = 0; &#125; &#125; if (isFirstRowZero) &#123; for (int j = 0; j &lt; n; j++) &#123; matrix[0][j] = 0; &#125; &#125; &#125;&#125;]]></content>
      <tags>
        <tag>算法</tag>
        <tag>LintCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LintCode-77.最长公共子序列]]></title>
    <url>%2FLintCode-77-%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%AD%90%E5%BA%8F%E5%88%97%2F</url>
    <content type="text"><![CDATA[一、问题描述给出两个字符串，找到最长公共子序列(LCS)，返回LCS的长度。 二、解决方法第1步，拆分问题： 对于输入序列X,Y 设S[i][j]表示X的前i位组成的序列以及Y的前j为组成的序列的公共子序列的长度 求S[len(X) - 1][len(Y) - 1] 状态：S[i][j] 第二步，求状态转移方程： S[i][j] = S[i-1][j-1] + 1, 若X[i] == Y[j] S[i][j] = max(S[i-1][j], S[i][j-1]), 若X[i] != Y[j] (由于不需要连续，则X[i]和Y[j]不相等也是有值的，而对于最长公共子串来说，不相等则等于0)。 第三步，求状态初始值： S[i][0] = X[i] == Y[0] ? 1 : 0; S[0][j] = X[0] == Y[j] ? 1 : 0; 第四步，根据递推得出结果 12345678910111213141516171819202122232425262728293031323334353637public class Solution &#123; /* * @param A: A string * @param B: A string * @return: The length of longest common subsequence of A and B */ public int longestCommonSubsequence(String A, String B) &#123; // write your code here char[] x = A.toCharArray(); char[] y = B.toCharArray(); int m = x.length; int n = y.length; int[][] dp = new int[m][n]; if (m == 0 || n == 0) return 0; // 状态定义 dp[i][j]表示A的第i位,B的第j位前的最长公共子序列 // 状态初始值 for (int i = 0; i &lt; m; i++) &#123; dp[i][0] = x[i] == y[0] ? 1 : 0; &#125; for (int j = 0; j &lt; n; j++) &#123; dp[0][j] = x[0] == y[j] ? 1 : 0; &#125; // 状态转移 for (int i = 1; i &lt; m; i++) &#123; for (int j = 1; j &lt; n; j++) &#123; int same = x[i] == y[j] ? 1 : 0; dp[i][j] = Math.max(dp[i-1][j-1] + same, Math.max(dp[i][j-1], dp[i-1][j])); &#125; &#125; return dp[m-1][n-1]; &#125;&#125; 三、相关问题LintCode-79.最长公共子串：状态转移方程： S[i][j] = X[i] == Y[j] ? S[i-1][j-1] + 1 : 0; 状态初始值： S[i][0] = X[i] == Y[0] ? 1 : 0; S[0][j] = X[0] == Y[j] ? 1 : 0; 123456789101112131415161718192021222324252627282930313233343536373839404142public class Solution &#123; /* * @param A: A string * @param B: A string * @return: the length of the longest common substring. */ public int longestCommonSubstring(String A, String B) &#123; // write your code here char[] x = A.toCharArray(); char[] y = B.toCharArray(); int m = x.length; int n = y.length; if (m == 0 || n == 0) return 0; int[][] dp = new int[m][n]; int max = 0; for (int i = 0; i &lt; m; i++) &#123; dp[i][0] = x[i] == y[0] ? 1 : 0; if (max &lt; dp[i][0]) &#123; max = dp[i][0]; &#125; &#125; for (int j = 0; j &lt; n; j++) &#123; dp[0][j] = x[0] == y[j] ? 1 : 0; if (max &lt; dp[0][j]) &#123; max = dp[0][j]; &#125; &#125; for (int i = 1; i &lt; m; i++) &#123; for (int j = 1; j &lt; n; j++) &#123; dp[i][j] = x[i] == y[j] ? dp[i-1][j-1] + 1 : 0; if (max &lt; dp[i][j]) &#123; max = dp[i][j]; &#125; &#125; &#125; return max; &#125;&#125;]]></content>
      <tags>
        <tag>算法</tag>
        <tag>动态规划</tag>
        <tag>LintCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode-416. Partition Equal Subset Sum]]></title>
    <url>%2FLeetCode-416-Partition-Equal-Subset-Sum%2F</url>
    <content type="text"><![CDATA[一、问题描述Given a non-empty array containing only positive integers, find if the array can be partitioned into two subsets such that the sum of elements in both subsets is equal. Note:Each of the array element will not exceed 100.The array size will not exceed 200.Example 1: Input: [1, 5, 11, 5] Output: true Explanation: The array can be partitioned as [1, 5, 5] and [11]. 二、解题方法 当数组和为奇数时，return false; 当数组和尾偶数时，则需要在数组中找到一个子集，使得子集的和尾sum/2 因此可以将题目归结为subset sum problem 代码： 12345678910111213141516171819202122232425262728293031323334353637class Solution &#123; public boolean canPartition(int[] nums) &#123; int sum = 0; for (int num : nums) &#123; sum += num; &#125; if (sum%2 != 0) &#123; return false; &#125; return isSubSum(nums, sum/2); &#125; public boolean isSubSum(int[] nums, int sum) &#123; boolean[][] dp = new boolean[nums.length + 1][sum + 1]; // 定义初始值 for (int i = 0; i &lt;= n; i++) &#123; dp[i][0] = true; //使用前i个元素组成的集合得到sum=0，当i=0是表示集合为空集 &#125; for (int j = 1; j &lt;= sum; j++) &#123; dp[0][j] = false; //使用空集得到sum=j &#125; // 根据状态转移方程递推 for (int i = 1; i &lt;= n; i++) &#123; for (int j = 1; j &lt;= m; j++) &#123; if (j &lt; nums[i-1]) &#123; dp[i][j] = dp[i-1][j]; &#125; else &#123; dp[i][j] = dp[i-1][j] || dp[i-1][j-nums[i-1]; &#125; &#125; &#125; return dp[nums.length][sum]; &#125;&#125; 三、 subset sum problem1.暴力法列出所有子集，看子集和是否有等于target的，时间复杂度为(2^n) 2.动态规划nums = [1,3,5,2,9], target = 15 第一步，拆分问题成子问题： 设 S[i][j]为：是否存在前i个元素组成的集合的子集和为j。 求S[len(nums)][sum] 状态：S[i][j] 第二步，求状态转移方程： S[i][j] = S[i-1][j] || S[i-1][j-nums[i-1]] {j &gt;= nums[i-1]} S[i][j] = S[i-1][j] {j &lt; nums[i-1]} 第三步，求状态初始值： S[0][j] = false {j = 1,2,…,sum} S[i][0] = true {i=0,1,2…,len(nums)} 第四步，根据递推得出结果 12345678910111213141516171819202122232425public boolean isSubSum(int[] nums, int sum) &#123; boolean[][] dp = new boolean[nums.length + 1][sum + 1]; int n = nums.length; int m = sum; // 定义初始值 for (int i = 0; i &lt;= n; i++) &#123; dp[i][0] = true; //使用前i个元素组成的集合得到sum=0，当i=0是表示集合为空集 &#125; for (int j = 1; j &lt;= sum; j++) &#123; dp[0][j] = false; //使用空集得到sum=j &#125; // 根据状态转移方程递推 for (int i = 1; i &lt;= n; i++) &#123; for (int j = 1; j &lt;= m; j++) &#123; if (j &lt; nums[i-1]) &#123; dp[i][j] = dp[i-1][j]; &#125; else &#123; dp[i][j] = dp[i-1][j] || dp[i-1][j-nums[i-1]; &#125; &#125; &#125; return dp[nums.length][sum];&#125; 时间复杂度：O(n*sum)，空间复杂度：O(n*sum) 3. 优化动态规划 O(sum)空间复杂度状态转移方程： S[i][j] = S[i-1][j] || S[i-1][j-nums[i-1]] {j &gt;= nums[i-1]} S[i][j] = S[i-1][j] {j &lt; nums[i-1]} 根据此状态转移方程来看，只需要存储两行即可，前一行作为i-1，当前行作为i，则S = new boolean[2][sum+1]，空间复杂度为O(m) 优化后的代码： 12345678910111213141516171819202122public boolean isSubSum(int[] nums, int sum) &#123; boolean[][] dp = new boolean[2][sum+1]; int n = nums.length; for (int j = 0; j &lt;= sum; j++) &#123; dp[0][j] = false; &#125; dp[0][0] = true; for (int i = 1; i &lt;= n; i++) &#123; for (int j = 0; j &lt;= sum; j++) &#123; if (j == 0) &#123; dp[i&amp;2][j] = true; //&amp;2表示对2快速取余 &#125; if (j &lt; nums[i-1]) &#123; dp[i&amp;2][j] = dp[(i+1)&amp;2][j]; &#125; else &#123; dp[i&amp;2][j] = dp[(i+1)&amp;2][j] || dp[(i+1)&amp;2][j-nums[i-1]]; &#125; &#125; &#125; return dp[n&amp;2][sum];&#125; 4. 获取所有子集根据dp矩阵，从dp[nums.length][sum]深度优先搜索即可 123456789101112131415161718192021222324252627282930public void dfs(int[] nums, boolean[][] dp, int i, int sum, ArrayList&lt;Integer&gt; q) &#123; // If sum becomes 0 if (i == 0) &#123; display(q); q.clear(); return; &#125; if (dp[i-1][sum]) &#123; ArrayList&lt;Integer&gt; b = new ArrayList&lt;&gt;(); b.addAll(q); //很关键, 因为这里可能会出现岔路, 只要在出现岔路的某个分支上加新的ArrayList就好。 dfs(nums, dp, i-1, sum, b); &#125; if (sum &gt;= nums[i-1]) &#123; if (dp[i-1][sum-nums[i-1]]) &#123; // ArrayList&lt;Integer&gt; b = new ArrayList&lt;&gt;(); // b.addAll(q); // b.add(nums[i-1]); // dfs(nums, dp, i-1, sum-nums[i-1], b); 在这里添加分叉也可以,两边都加也可以 q.add(nums[i-1]); dfs(nums, dp, i-1, sum, q); &#125; &#125;&#125;public void display(ArrayList&lt;Integer&gt; q) &#123; for (Integer i : q) &#123; System.out.print(i + &quot; &quot;); &#125; System.out.println();&#125;]]></content>
      <tags>
        <tag>LeetCode</tag>
        <tag>算法</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode-300-Longest Increasing Subsequence]]></title>
    <url>%2FLeetCode-300-Longest-Increasing-Subsequence%2F</url>
    <content type="text"><![CDATA[一、问题描述Given an unsorted array of integers, find the length of longest increasing subsequence. For example,Given [10, 9, 2, 5, 3, 7, 101, 18],The longest increasing subsequence is [2, 3, 7, 101], therefore the length is 4. Note that there may be more than one LIS combination, it is only necessary for you to return the length. Your algorithm should run in O(n2) complexity. Follow up: Could you improve it to O(n log n) time complexity? 二、解题方法1. O(n^2)将问题抽象为第K个数的上升序列有多长 状态转移方程：Fk=max{Fi+1 | a[i] &lt; a[k]} 代码： 1234567891011121314151617181920212223class Solution &#123; public int lengthOfLIS(int[] nums) &#123; int n = nums.length; if (n == 0) return 0; int[] dp = new int[n]; int result = 0; for (int i = 0; i &lt; n; i++) &#123; int max = 0; for (int j = 0; j &lt; i; j++) &#123; if (nums[j] &lt; nums[i]) &#123; if (max &lt; dp[j]) &#123; max = dp[j]; &#125; &#125; &#125; dp[i] = max + 1; if (dp[i] &gt; result) &#123; result = dp[i]; &#125; &#125; return result; &#125;&#125; 2.O(nlogn)使用binary search，用一个数组存储上升序列长度所对应的序列的最小最右边的值。 比如[3,5,7,2,4,6,1]，使用O(n^2)的方法会遍历k之前所有的i，而其实只要知道k之前上升序列最右边最小的数是否比当前k值要小。 第1次，k=0, len=0; dp[0]=3, 上升序列长度为1的最右边最小值为2 第2次，k=1, len=1; dp[1]=5, 上升序列长度为2的最右边最小值为5 第3次，k=2, len=2; dp[2]=7, 上升序列长度为3的最右边最小值为7 第4次，k=3, len=3; dp[0] &lt; 4 &lt; dp[1], 则上升序列为长度为2的最右边最小值为4， 更新长度为2的上升序列最右边的值，即dp[1] = 4 第5次，k=4, len=3; dp[1] &lt; 6 &lt; dp[2], 则上升序列长度为3的最右边最小的值为6,更新长度为3的上升序列最右边最小值，即dp[2] = 6 第6次，k=1, len=3; 1 &lt; dp[0], 则上升序列长度为1的最优最小值为1，dp[0] = 1 综上，只要知道a[k]在dp数组中的位置就可以了。 a[k] &lt; dp[0] dp[0]=a[k]; dp[i-1] &lt; a[k] &lt; dp[i] dp[i] = a[k] dp[len] &lt; a[k] dp[len] = a[k], len++ 代码： 12345678910111213141516171819202122class Solution &#123; public int lengthOfLIS(int[] nums) &#123; int n = nums.length; if (n == 0) return 0; int[] dp = new int[n]; int size = 0; for (int i = 0; i &lt; n; i++) &#123; int k = 0, l = size; while (k != l) &#123; int t = (k+l)/2; if (dp[t] &gt;= nums[i]) &#123; l = t; &#125; else &#123; k = t + 1; &#125; &#125; dp[k] = nums[i]; if (k == size) size++; //找到最后还是没找到则size+1 &#125; return size; &#125;&#125; 参考Youtube Longest Increasing Subsequence O(n^2) Youtube Longest Increasing Subsequence O(nlogn) LeetCode-300 Solution]]></content>
      <tags>
        <tag>LeetCode</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[动态规划]]></title>
    <url>%2F%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%2F</url>
    <content type="text"><![CDATA[一、定义 dynamic programming (also known as dynamic optimization) is a method for solving a complex problem by breaking it down into a collection of simpler subproblems, solving each of those subproblems just once, and storing their solutions. 动态规划是通过拆分问题，定义问题状态和状态之间的关系，使得问题能够以递推（或者说分治）的方式去解决。是用来求解最优化问题的一种方法，与贪心算法求得局部最优解不同，动态规划是求解全局最优解的。 二、求解步骤动态规划算法的4个步骤： 状态是什么 状态转移方程是什么 状态的初始值是什么 问题要求的最后答案是什么 构建状态转移方程的详细步骤： 构造问题所对应的过程。 思考过程的最后一个步骤，看看有哪些选择情况。(方便构建状态转移方程) 找到最后一步的子问题，确保符合“子问题重叠”，把子问题中不相同的地方设置为参数。 使得子问题符合“最优子结构”。 找到边界，考虑边界的各种处理方式。 确保满足“子问题独立”，一般而言，如果我们是在多个子问题中选择一个作为实施方案，而不会同时实施多个方案，那么子问题就是独立的。 考虑如何做备忘录。 分析所需时间是否满足要求。 写出转移方程式。 三、动态规划应用1. LeetCode-62 Unique paths A robot is located at the top-left corner of a m x n grid (marked ‘Start’ in the diagram below).The robot can only move either down or right at any point in time. The robot is trying to reach the bottom-right corner of the grid (marked ‘Finish’ in the diagram below).How many possible unique paths are there? 1234567891011121314public class Solution &#123; private int[][] path; //路径的数组 public int uniquePaths(int m, int n) &#123; path = new int[m][n]; return dp(m-1, n-1); &#125; public int dp(int m, int n) &#123; if (m == 0 || n == 0) return 1; //边界条件 if (path[m][n] != 0) return path[m][n]; path[m][n] = dp(m-1, n) + dp(m, n-1); //状态转移 return path[m][n]; &#125;&#125; 2. LeetCode-63 Unique paths2 Follow up for “Unique Paths”: Now consider if some obstacles are added to the grids. How many unique paths would there be? An obstacle and empty space is marked as 1 and 0 respectively in the grid. 1234567891011121314151617181920212223242526272829303132333435363738public class Solution &#123; public int uniquePathsWithObstacles(int[][] obstacleGrid) &#123; int m = obstacleGrid.length; if (m == 0) &#123; return 0; &#125; int n = obstacleGrid[0].length; if (n == 0) &#123; return 0; &#125; int[][] path = new int[m][n]; for (int i = 0; i &lt; m; i ++) &#123; for (int j = 0; j &lt; n; j++) &#123; if (obstacleGrid[i][j] == 1) &#123; path[i][j] = 0; &#125; else &#123; if (i==0 &amp;&amp;j==0) &#123; path[i][j] = 1; &#125; else&#123; if (i &gt; 0 &amp;&amp; j &gt; 0) &#123; path[i][j] = path[i-1][j] + path[i][j-1]; &#125; else &#123; if (i &gt; 0) &#123; path[i][j] = path[i-1][j]; &#125; else if (j &gt; 0)&#123; path[i][j] = path[i][j-1]; &#125; &#125; &#125; &#125; &#125; &#125; return path[m-1][n-1]; &#125;&#125; 3. LeetCode-64 Minimum Path Sum Given a m x n grid filled with non-negative numbers, find a path from top left to bottom right which minimizes the sum of all numbers along its path. 123456789101112131415161718192021public class Solution &#123; public int minPathSum(int[][] grid) &#123; if (grid.length == 0 || grid[0].length == 0) return 0; int m = grid.length; int n = grid[0].length; for (int i = 1; i &lt; m; i++) &#123; grid[i][0] += grid[i-1][0]; &#125; for (int j = 1; j &lt; n; j++) &#123; grid[0][j] += grid[0][j-1]; &#125; for (int i = 1; i &lt; m; i++) &#123; for (int j = 1; j &lt; n; j++) &#123; grid[i][j] += grid[i-1][j] &gt; grid[i][j-1] ? grid[i][j-1] : grid[i-1][j]; &#125; &#125; return grid[m-1][n-1]; &#125;&#125; LintCode-动态规划 参考什么是动态规划？动态规划的意义是什么？ 如何理解动态规划？ 五大常用算法之二：动态规划算法]]></content>
      <tags>
        <tag>算法</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode-200.Number of Islands]]></title>
    <url>%2FLeetCode-200-Number-of-Islands%2F</url>
    <content type="text"><![CDATA[一、问题描述Given a 2d grid map of ‘1’s (land) and ‘0’s (water), count the number of islands. An island is surrounded by water and is formed by connecting adjacent lands horizontally or vertically. You may assume all four edges of the grid are all surrounded by water. Example 1: 11110 11010 11000 00000 Answer: 1 Example 2: 11000 11000 00100 00011 Answer: 3 二、解题方法1. 使用union-find方法，将→和↓的相邻的1连接起来(16ms)相邻的1可以union，以↓和→的方式查找可以union的1，遍历所有的边。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576class Solution &#123; class UF &#123; private int[] idx; private int[] rank; private int count; public UF(int N) &#123; idx = new int[N]; rank = new int[N]; for (int i = 0; i &lt; N; i++) &#123; idx[i] = i; rank[i] = 1; &#125; count = N; &#125; private int getCount() &#123; return count; &#125; private int find(int p) &#123; if (idx[p] == p) &#123; return p; &#125; idx[p] = find(idx[p]); return idx[p]; &#125; private void union(int p, int q) &#123; int i = find(p); int j = find(q); if (i != j) &#123; // 两个set不同，根据秩合并 if (rank[i] &gt;= rank[j]) &#123; // 只有秩相同才加1 rank[i] = rank[i] == rank[j] ? rank[i] + 1 : rank[i]; idx[j] = i; &#125; else &#123; idx[i] = j; &#125; count--; &#125; &#125; &#125; public int numIslands(char[][] grid) &#123; int rows = grid.length; if (rows == 0) &#123; return 0; &#125; int columns = grid[0].length; UF uf = new UF(rows*columns); int oneCount = 0; for (int i = 0; i &lt; rows; i++) &#123; for (int j = 0; j &lt; columns; j++) &#123; if (grid[i][j] == '1') &#123; oneCount++; &#125; if (j &lt; columns - 1) &#123; if (grid[i][j] == '1' &amp;&amp; grid[i][j+1] == '1') &#123; uf.union(i*columns+j, i*columns+j+1); &#125; &#125; if (i &lt; rows - 1) &#123; if (grid[i][j] == '1' &amp;&amp; grid[i+1][j] == '1') &#123; uf.union(i*columns+j, (i+1)*columns+j); &#125; &#125; &#125; &#125; // 每连接一个1都会减一，但输入是包括0的，所以要用1的个数减去减少的量 return oneCount - (rows*columns - uf.getCount()); &#125;&#125; 2. 使用DFS方法(7ms)深度优先搜索，由某一点开始开始向↑↓←→遍历，每次遍历将所在点置成’0’，一条路走完岛屿数就加1，直到遍历完所有的。 1234567891011121314151617181920212223242526272829303132class Solution &#123; private int rows, columns; public int numIslands(char[][] grid) &#123; int count = 0; rows = grid.length; if (rows == 0) &#123; return 0; &#125; columns = grid[0].length; for (int i = 0; i &lt; rows; i++) &#123; for (int j = 0; j &lt; columns; j++) &#123; if (grid[i][j] == '1') &#123; dfs(grid, i, j, rows, columns); count++; &#125; &#125; &#125; return count; &#125; private void dfs(char[][] grid, int i, int j, int rows, int columns) &#123; if (i &lt; 0 || j &lt; 0 || i &gt;= rows || j &gt;= columns || grid[i][j] != '1') &#123; return ; &#125; grid[i][j] = '0'; dfs(grid, i, j - 1, rows, columns); dfs(grid, i - 1, j, rows, columns); dfs(grid, i, j + 1, rows, columns); dfs(grid, i + 1, j, rows, columns); &#125;&#125; 3. 使用BFS方法(11ms)12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970class Solution &#123; class Dot &#123; private int m; private int n; Dot(int m, int n) &#123; this.m = m; this.n = n; &#125; public int getM() &#123; return m; &#125; public int getN() &#123; return n; &#125; &#125; private int rows, columns; public int numIslands(char[][] grid) &#123; if (grid.length == 0) &#123; return 0; &#125; int count = 0; rows = grid.length; columns = grid[0].length; for (int i = 0; i &lt; rows; i++) &#123; for (int j = 0; j &lt; columns; j++) &#123; if (grid[i][j] == '1') &#123; bfs(grid, i, j); count++; &#125; &#125; &#125; return count; &#125; private void bfs(char[][] grid, int i, int j) &#123; grid[i][j] = '0'; Deque&lt;Dot&gt; queue = new ArrayDeque&lt;&gt;(); queue.add(new Dot(i, j)); while (!queue.isEmpty()) &#123; Dot element = queue.poll(); int m = element.getM(); int n = element.getN(); // uper if (m - 1 &gt;= 0 &amp;&amp; grid[m-1][n] == '1') &#123; queue.add(new Dot(m-1, n)); grid[m-1][n] = '0'; &#125; // down if (m + 1 &lt; rows &amp;&amp; grid[m+1][n] == '1') &#123; queue.add(new Dot(m+1, n)); // 必须立马标记为0，这样下一次出队列查询上下左右的时候不会一直加入队列中。 grid[m+1][n] = '0'; &#125; // left if (n - 1 &gt;= 0 &amp;&amp; grid[m][n-1] == '1') &#123; queue.add(new Dot(m, n-1)); grid[m][n-1] = '0'; &#125; // right if (n + 1 &lt; columns &amp;&amp; grid[m][n+1] == '1') &#123; queue.add(new Dot(m, n+1)); grid[m][n+1] = '0'; &#125; &#125; &#125;&#125; 三、相关概念并查集(union-find)是一种树型的数据结构，用于处理一些不相交集合（Disjoint Sets）的union及find问题，例如动态连通性等问题。 并查集一般有以下接口： makeSet: 建立DisJoint Sets unoin: 合并集合 find: 查询元素所属集合 在并查集的基础实现方法上，有两个优化，一个是按秩合并，可以让树较为平衡；另一个是路径压缩，在查找的过程中将树扁平化，方便下次查找。 时间复杂度：O(α(n)) 实现方法可以使用数组实现，数组的值表示父节点 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950public class UF &#123; private int[] idx; //父链接索引，idx[1]=2表示1的父节点为2 private int[] rank; //每个set的大小，两个set大小相同union时加一 private int count; // 连通分量的个数 public UF(int N) &#123; makeSet(N); &#125; public void makeSet(int N) &#123; idx = new int[N]; rank = new int[N]; for (int i = 0; i &lt; N; i++) &#123; idx[i] = i; rank[i] = 1; &#125; count = N; &#125; public boolean connected(int p, int q) &#123; return find(p) == find(q); &#125; public int find(int p) &#123; if (idx[p] == p) &#123; return p; &#125; else &#123; idx[p] = find(idx[p]); // 路径压缩 return idx[p]; &#125; &#125; public void union(int p, int q) &#123; int i = find(p); int j = find(q); if (i != j) &#123; // p 和 q不在一个集合里， 合并两个集合， 按秩合并 if (rank[i] &gt;= rank[j]) &#123; rank[i] = rank[i] == rank[j] ? rank[i] + 1 : rank[i]; idx[j] = i; &#125; else &#123; idx[i] = j; &#125; count--; &#125; &#125; public int count() &#123; return count; &#125;&#125;]]></content>
      <tags>
        <tag>LeetCode</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构-图]]></title>
    <url>%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%9B%BE%2F</url>
    <content type="text"><![CDATA[一、基本概念 顶点V：数据元素通常称为顶点。 边：顶点之间的无向连线 弧：顶点之间的有向连线 有向图：由一组顶点和一组有方向的边组成 无向图：由一组顶点和一组无方向的边组成 简单图：不存在顶点到其自身的边，且同一条边不重复。 边或弧很少的图称为稀疏图；边或弧较多的图称为稠密图。 度：一个顶点的度是与它相关联的边的条数 入度：有向图中到达顶点的边数。 出度：有向图中顶点出发的边数 网：带权值的图，分为有向网和无向网。 子图：由一幅图的所有边的子集（以及它们所依附的所有顶点）组成的图。 路径：由边顺序连接的一系列顶点。 路径长度：路径上边或弧的数目；网中为路径上的边或弧的权值之和。 环：至少含有一条边且起点和重点相同的路径。 简单路径：没有重复顶点的路径。 简单环：不含有重复顶点和边的环。 连通：当两个顶点之间存在一条连接双方的路径时，称一个顶点和另一个顶点是连通的。 连通图：如果从任意一个顶点都存在一条路径到达另一个任意顶点，即任一对顶点都存在路径，则成为连通图。 连通分量：无向图中的极大连通子图。 强连通图：在有向图中，任何一对顶点都存在路径 强连通分量：有向图中的极大连通子图。 生成树：连通图中一个极小连通子图，含有全部顶点，但只有足以构成树的n-1条边。 生成树森林：在连通图中每个连通分量，都可以得到一颗生成树，这些生成树构成生成森林。 二、图的存储结构1. 邻接矩阵使用二维数组表示顶点之间相邻关系的矩阵。 arc[i,j] = 1((v[i], v[j]) ∈E或 ∈E) 1()为指示器函数 2. 邻接表邻接表表示法类似于树的孩子链表表示法，用顺序结构存放节点，用链式结构存储弧。 3. 十字链表邻接表和逆邻接表的结合，方便同时求出度和入度。 4. 邻接多重表5. 边集数组利用两个一维数组，其中一个数组存储图中的顶点，另一个数组存储图中的边。在存储边的数组中，每个数组元素存储一条边的起点、终点和权值，在数组中的次序可以任意安排。 三、图的遍历 深度优先搜索(DFS) 广度优先搜索(BFS) 四、最小生成树基本概念图的生成树是它的一棵含有其所有顶点的无环连通子图。一副加权图的最小生成树是它的一棵权值（树中所有边的权值之和）最小的生成树。 当且仅当一幅含有V个节点的图G满足下列5个条件之一时，它就是一棵树： G有V-1条边且不含有环 G有V-1条边且是连通的 G是连通的，但删除任意一条边都会使它不再连通 G是无环图，但添加任意一条边都会产生一条环 G中的任意一对顶点之间仅润在一条简单路径。 Kruskal算法和Prim算法都是依据了上述5个条件来建立的。 Prim算法假设n个顶点分成两个集合U(包含已落在生成树上的结点)和V-U(尚未落在生成树上的顶点)，则在所有连通U中顶点和V-U中顶点的边中选取权值最小的边，就是最小生成树上的边，把对应的顶点添加到U中。具体做法和dijkstra算法类似, Prim算法是找到某个顶点的某条边的值最小，而dijkstra则是找到某个顶点的路径值最小，因此dijkstra需要累加。 优先队列主要有几个方法： add poll heapifyDown() heapifyUp() 时间复杂度：简易实现是O(|V|^2), 使用二叉堆实现是O(|E|log|V|) 代码：no heap Prim Prim’s Algorithm Minimum Spanning Tree Graph Algorithm Kruskal算法思想：为使生成树上边的权值之和最小，显然，其中每一条边的权值应该尽可能小。 操作：使用DisJointSet，先对所有顶点makeSet，然后排序所有边(时间复杂度为O(ElogE))，接着从小到大选择边，将边对应的两个顶点所在集合合并，若两个顶点所在集合一致则不加入，直到所有顶点在一个set里(即所有点都连通了)。 伪代码： 123456789101112sort(E)for vertex in V: disJointSet.makeSet(vertex.getId())for edge in E: # 如果disJointSet只剩一个就表明所有顶点已连通 if (disJointSet.getCount() == 1): break; v1 = edge.getV1() v2 = edge.getV2() if disJointSet.find(v1) != disJointSet.find(v2): result.add(edge) disJointSet.union(v1.getId(), v2.getId()) 五、最短路径Dijkstra算法单源到任意顶点的最短路， 使用binary heap和贪心算法做。 步骤： 找出从源点能够直接到达的顶点的所有路径，从中选出一条最短的路径； 以这条已选出的最短路径作为转发路径，找出经过这条路径转发后到达的其他能直接到达的顶点的路径，并从中选出一条最短的路径，更新从源点到节点路径的长度。 重复执行上述操作，直到找到所有顶点的最短路径为止。 时间复杂度：若不采用最小优先队列，时间复杂度为O(|V|^2)，否则为O(|E|log|V|). Youtube-Dijkstra’s Shortest Path Algorithm Folyd算法六、拓扑排序拓扑排序]]></content>
      <tags>
        <tag>算法</tag>
        <tag>数据结构</tag>
        <tag>图</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构-拓扑排序]]></title>
    <url>%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[1. 概念拓扑排序是对有向无环图的顶点的一种排序，它使得如果存在一条从顶点A到顶点B的路径，那么在排序中B出现在A的后面。 在图论中，由一个有向无环图的顶点组成的序列，当且仅当满足下列条件时，称为该图的一个拓扑排序：①每个顶点出现且只出现一次；②若A在序列中排在B的前面，则在图中不存在从B到A的路径。 只有DAG才有拓扑排序。通常，一个有向无环图可以有一个或多个拓扑排序序列。 2.算法Kahn算法 从DAG图中选择一个没有前驱即入度为0的顶点并输出(根据拓扑排序的定义来，若有入度，则在该顶点之前必然还有顶点要输出)。 从图中删除该顶点和所有以它为起点的有向边（把问题缩小） 重复前面两个步骤直到DAG图为空。 DFS DFS思路和Kahn算法类似，在深度优先搜索的过程中，最下面的顶点在Kahn算法中是被最后删除的，因此应该放在栈底，即应该第一个被放入栈中。（拓扑序列也要求最后的点应该放在最末尾，即栈底） 时间复杂度 当以邻接表存储时，时间复杂度为O(|V|+|E|) 当以邻接矩阵存储时，时间复杂度为O(|V|^2)。 代码实现：Topological Sort 3.如何检测有向环？ 使用Kahn算法，迭代删除入度为0的顶点和边所对应的顶点，若最后还有未遍历到的点，则有环。 使用深度优先搜索，一条深度优先搜索的路径上如果折回到已经遍历的点，则表示有环。具体可以加个white set表示没被访问过的，gray set表示正在访问的，black set表示已经访问的，但凡在dfs过程中遇到的点在gray set中就表示有环。 代码实现:有向环检测 4. 如何检测无向环 使用Disjoint算法，一开始将所有顶点放到不同的set中，然后遍历边，将边所对应的两个set合并，若出现有边对应的两个顶点在同一个set中，则表明有环。 使用深度优先搜索算法，将parent顶点传下去防止子顶点遍历parent顶点，只要在visited中已经被访问过，则表示有环。 代码实现:无向环检测 5. 有向环和无向环检测的区别区别的关键在于有向图是有方向的，无向环的检测方法都忽略了方向，若使用检测无向环的方式检测的话会导致判断错误，如下图所示。 6.参考：geeksforgeeks Topological sort Youtube-Topological Sort Graph Algorithm 相关问题并查集(union-find)在计算机科学中，并查集是一种树型的数据结构，用于处理一些不相交集合（Disjoint Sets）的合并及查询问题。 有一个联合-查找算法（union-find algorithm）定义了两个用于此数据结构的操作： Find：确定元素属于哪一个子集。它可以被用来确定两个元素是否属于同一子集。 Union：将两个子集合并成同一个集合。 由于支持这两种操作，一个不相交集也常被称为联合-查找数据结构（union-find data structure）或合并-查找集合（merge-find set）。其他的重要方法，MakeSet，用于建立单元素集合。有了这些方法，许多经典的划分问题可以被解决。 实现 加权(按秩):12345678910111213141516private void union(long data1, long data2) &#123; Node node1 = map.get(data1); Node node2 = map.get(data2); Node parent1 = findSet(node1); Node parent2 = findSet(node2); if (parent1.data != parent2.data) &#123; if (parent1.rank &gt;= parent2.rank) &#123; parent1.rank = parent1.rank == parent2.rank ? parent1.rank + 1 : parent1.rank; //按秩，两个集合秩相同才加1 parent2.parent = parent1; &#125; else &#123; parent1.parent = parent2; &#125; &#125;&#125; 路径压缩：12345678private Node findSet(Node node) &#123; if (node.parent == node) &#123; // base case return node; &#125; else &#123; node.parent = findSet(node.parent); //路径压缩 return node.parent; &#125;&#125; 复杂度 时间复杂度：O(α(n)) 空间复杂度：O(n) 完整代码 使用Node的并查集 使用数组的并查集]]></content>
      <tags>
        <tag>数据结构</tag>
        <tag>图</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[机器学习Stacking]]></title>
    <url>%2F%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0Stacking%2F</url>
    <content type="text"><![CDATA[简要总结Staking 是一种模型融合方法，以多个模型的对Training set 和 Test set的预测结果作为特征。 例如： Training set：X_train -&gt; y_trainTest set: X_test -&gt; y_test 将X_train和X_test同时用某个模型变换成X_train’和X_test’, 再使用 stacking 模型训练, 最终对X_test’进行预测得到结果y, 如下图所示: 代码1234567891011121314151617181920212223ntrain = train.shape[0]ntest = test.shape[0]SEED = 0 # for reproducibilityNFOLDS = 5 # set folds for out-of-fold predictionkf = KFold(ntrain, n_folds= NFOLDS, random_state=SEED)def get_oof(clf, X_train, y_train, X_test): oof_train = np.zeros((ntrain,)) oof_test = np.zeros((ntest,)) oof_test_skf = np.empty((NFOLDS, ntest)) for i, (train_index, test_index) in enumerate(kf): x_tr = x_train[train_index] y_tr = y_train[train_index] x_te = x_train[test_index] clf = clf.fit(x_tr, y_tr) oof_train[test_index] = clf.predict(x_te) oof_test_skf[i, :] = clf.predict(x_test) oof_test[:] = oof_test_skf.mean(axis=0) return oof_train.reshape(-1, 1), oof_test.reshape(-1, 1) 具体可以参考： Kaggle机器学习之模型融合（stacking）心得 A Kaggler’s Guide to Model Stacking in Practice 如何在 Kaggle 首战中进入前 10%]]></content>
      <tags>
        <tag>机器学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[统计学习方法笔记：感知机]]></title>
    <url>%2F%E7%BB%9F%E8%AE%A1%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%B3%95%E7%AC%94%E8%AE%B0%EF%BC%9A%E6%84%9F%E7%9F%A5%E6%9C%BA%2F</url>
    <content type="text"><![CDATA[感知机是二类分类的线性分类模型，属于判别模型。 感知机模型f(x) = sign(wx+b) 假设空间：{f|f(x)=wx+b} 感知机学习策略假设训练数据集是线性可分的，感知机学习的目标是求得一个能够将训练集正实例点和负实例点完全正确分开的分离超平面。为了找到这样的超平面，即确定模型参数w,b，需要确定一个学习策略，即定义经验损失函数并将损失函数极小化。 损失函数： 感知机学习算法感知机学习问题转化为求解损失函数的最优化问题，最优化的方法是随机梯度下降法。 具体算法： 原始形式 对偶形式 参考： 浅析感知机（一）–模型与学习策略 如何理解感知机学习算法的对偶形式？ 支持向量机中的函数距离和几何距离怎么理解？]]></content>
      <tags>
        <tag>机器学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[机器学习范数]]></title>
    <url>%2F%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E8%8C%83%E6%95%B0%2F</url>
    <content type="text"><![CDATA[监督机器学习问题无非就是“minimizeyour error while regularizing your parameters”，也就是在规则化参数的同时最小化误差。规则化是结构风险最小化策略的实现，是在经验风险上加一个正则化项(regularizer)或惩罚项(penalty term)。 机器学习中的范数一般指的是向量的范数。 L0范数，向量中非零元素的个数。用于产生稀疏性，但是在实际研究中很少用，因为L0范数很难优化求解，是一个NP-hard问题，因此更多情况下我们是使用L1范数 L1范数，为绝对值之和。用以产生稀疏性，因为它是L0范式的一个最优凸近似，容易优化求解 L2范数，向量元素绝对值的平方和再开方。L2范数更多是防止过拟合，并且让优化求解变得稳定很快速（这是因为加入了L2范式之后，满足了强凸）。 从贝叶斯的角度来看，正则化等价于对模型参数引入先验分布 。 对参数引入先验分布，降低模型复杂度。L1正则相当于假设参数w服从拉普拉斯分布；L2正则假设参数服从高斯分布。 参考： LR正则化与数据先验分布的关系 l0-Norm, l1-Norm, l2-Norm, … , l-infinity Norm L0,L1,L2范数及其应用 0范数、1范数、2范数有什么区别 机器学习中的范数规则化之（一）L0、L1与L2范数]]></content>
      <tags>
        <tag>机器学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[统计学习方法第一章笔记]]></title>
    <url>%2F%E7%BB%9F%E8%AE%A1%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%B3%95%E7%AC%AC%E4%B8%80%E7%AB%A0%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[一、统计学习方法三要素1.模型监督学习的目的在于学习一个由输入到输出的映射，这一映射由模型来表示。 模型属于由输入空间到输出空间的映射的集合，这个集合是假设空间。 概率模型：由条件概率分布P(Y|X)表示 非概率模型：由决策函数f(X)表示 假设空间：F = {f|Y=f(X)} 或 F = {P|P(Y|X)} 2.策略有了模型的假设空间，统计学习的目标在于从假设空间中选取最优模型，如何选择模型就是统计学习的策略。 损失函数：0-1损失函数；平方损失函数；绝对损失函数；对数损失函数等 风险函数：损失函数的期望 经验风险：模型关于训练数据集的平均损失 结构风险：当样本容量很小时，经验风险最小化学习的效果会导致过拟合。结构风险=经验风险+正则化项 监督学习常用两种策略： 经验风险最小化 结构风险最小化 3.算法最小二乘法、梯度下降法、牛顿法等 二、模型评估 训练误差 测试误差 过拟合：学习时选择的模型所包含的参数过多，导致在训练集表现良好而在测试集上表现很差的现象 三、模型选择1.正则化 结构风险最小化 范数 2.交叉验证 简单交叉验证 S折交叉验证 留一交叉验证 四、监督学习方法1.生成方法由数据学习联合概率分布P(X,Y)，然后求出条件概率分布P(Y|X)作为预测的模型，即生成模型： P(Y|X) = P(X,Y)/P(X) e.g. 朴素贝叶斯、隐马尔科夫模型 优点：收敛速度更快，适用于存在隐变量的情况 2.判别方法由数据直接学习决策函数f(X)或条件概率分布P(Y|X) e.g. k邻近法、感知机、决策树、逻辑斯谛回归模型、最大熵模型、支持向量机、提升方法、条件随机场等。 优点：准确率更高；便于对数据进行抽象和特征提取 五、监督学习种类1.分类问题 准确率 accuracy=(TP+TN)/(TP+TN+FP+FN) 精确率 P = TP/(TP+FP)：预测为正类的有多少是真正的正类 召回率 R=TP/(TP+FN):样本中正类样本多少标记正确 如何解释召回率与准确率？ 2.标注问题分类问题的推广 3.回归问题等价于函数拟合]]></content>
      <tags>
        <tag>机器学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前序遍历、中序遍历、后序遍历的递归和非递归实现方法]]></title>
    <url>%2F%E5%89%8D%E5%BA%8F%E9%81%8D%E5%8E%86%E3%80%81%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86%E3%80%81%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86%E7%9A%84%E9%80%92%E5%BD%92%E5%92%8C%E9%9D%9E%E9%80%92%E5%BD%92%E5%AE%9E%E7%8E%B0%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[二叉树有4种遍历方式：前序遍历、中序遍历、后序遍历和后序遍历方式。 前序遍历、中序遍历、后序遍历是深度优先搜索，适合用递归方式和栈实现。 层次遍历是广度优先搜索，适合用队列实现。 树的结点：12345678Node &#123; int data; Node left, right; Node(int data) &#123; this.data = data; left = right = null; &#125;&#125; 一、前序遍历 root -&gt; left_child -&gt; right_child 递归方式： 访问根节点 访问左子树 访问右子树 123456public void recursivePreorder(Node root) &#123; if (root == null) return; System.out.println(root.data); recursivePreorder(root.left); recursivePreorder(root.right);&#125; 非递归方式：方法1 push左子树直到叶子节点，边push边遍历 12345while (p != null) &#123; System.out.println(p.data); stack.push(p); p = p.left;&#125; 当Stack不为空时，弹出栈，若该节点有右子树，则push右子树的左子树直到叶子节点。重复1,2（根节点-&gt;遍历左子树-&gt;遍历右子树） 12p = stack.pop();p = p.right; 完整代码： 123456789101112131415public void iterativePreorder(Node root) &#123; ArrayDeque&lt;Node&gt; stack = new ArrayDeque&lt;&gt;(); Node p = root; while (!stack.isEmpty() || p != null) &#123; while (p != null) &#123; // 边push边遍历，之后要借助push进来的节点到右子树上 System.out.println(p.data); stack.push(p); p = p.left; &#125; p = stack.pop(); p = p.right; &#125;&#125; 方法2利用栈具有First-In-Last-Out的特点。 过程：循环{ pop出节点后，先push当前节点的右节点，再push当前节点的左节点 }。 完整代码： 12345678910111213141516public void iterativePreorder(Node root) &#123; if (root == null) return; Node p = null; stack.push(root); while (!stack.isEmpty()) &#123; p = stack.pop(); System.out.println(p.data); if (p.right != null) &#123; stack.push(p.right); &#125; if (p.left != null) &#123; stack.push(p.left); &#125; &#125;&#125; 二、中序遍历 left_child -&gt; root -&gt; right_child 递归方式： 访问左子树 访问根节点 访问右子树 123456public void recursiveInorder(Node root) &#123; if (root == null) return; recursivePreorder(root.left); System.out.println(root.data); recursivePreorder(root.right);&#125; 非递归方式： push左子树直到叶子节点 1234while (p != null) &#123; stack.push(p); p = p.left;&#125; 当Stack不为空时，弹出栈，遍历该节点。若该节点有右子树，则push右子树的左子树直到叶子节点。重复1，2 （遍历左子树-&gt;根节点-&gt;遍历右子树） 123p = stack.pop();System.out.println(p.data);p = p.right; 完整代码：123456789101112131415public void iterativeInorder(Node root) &#123; ArrayDeque&lt;Node&gt; stack = new ArrayDeque&lt;&gt;(); Node p = root; while (!stack.isEmpty() || p != null) &#123; while (p != null) &#123; stack.push(p); p = p.left; &#125; p = stack.pop(); System.out.println(p.data); p = p.right; //下次循环就开始遍历右子树了 &#125;&#125; 三、后序遍历 left_child -&gt; right_child -&gt; root 递归方式： 访问左子树 访问右子树 访问根节点 123456public void recursiveInorder(Node root) &#123; if (root == null) return; recursivePreorder(root.left); recursivePreorder(root.right); System.out.println(root.data);&#125; 非递归方式：方法1后序遍历的迭代方法比前两个要难一点，难点在于只有当右子树遍历完了以后才可以弹出根节点。 设置一个lastVisitNode来指示最后一次遍历到哪了，根据这个来判断弹出的元素的右子树有没有遍历过，只有遍历过才可以访问根节点。 push左子树直到叶子节点 1234while (p != null) &#123; stack.push(p); p = p.left;&#125; 当Stack非空时，peek栈顶，看栈顶节点的右子树是否全部访问过，如果访问过就弹出该栈顶节点并访问；如果没有访问过，则push右子树的左子树直到叶子节点。重复1,2。（遍历左子树-&gt;遍历右子树-&gt;根节点） 12345678p = stack.peek();if (p.right == null || p.right == lastVisitNode) &#123; stack.pop(); System.out.println(p.data); lastVisitNode = p;&#125; else &#123; p = p.right;&#125; 完整代码： 12345678910111213141516171819202122public void iterativePostorder(Node root) &#123; ArrayDeque&lt;Node&gt; stack = new ArrayDeque&lt;&gt;(); Node p = root; Node lastVisitNode = null; while (!stack.isEmpty() || p != null) &#123; while (p != null) &#123; stack.push(p); p = p.left; &#125; p = stack.peek(); if (p.right == null || p.right == lastVisitNode) &#123; stack.pop(); System.out.println(p.data); lastVisitNode = p; // p节点已经访问过了，要置null防止下次循环再遍历 p = null; &#125; else &#123; p = p.right; &#125; &#125;&#125; 方法2思路：后序遍历是左子树-&gt;右子树-&gt;根节点，倒过来则可以是根节点-&gt;右子树-&gt;左子树，是前序遍历的变形。然后将这样的遍历压到另一个栈中，再弹出来。这样空间复杂度会由O(logn)变大为O(n)。 完整代码：123456789101112131415161718public void iterativePostorder3(Node root) &#123; ArrayDeque&lt;Node&gt; stack1 = new ArrayDeque&lt;&gt;(); ArrayDeque&lt;Node&gt; stack2 = new ArrayDeque&lt;&gt;(); Node p = root; while (!stack1.isEmpty() || p != null) &#123; while (p != null) &#123; stack2.push(p); stack1.push(p); p = p.right; &#125; p = stack1.pop(); p = p.left; &#125; while (!stack2.isEmpty()) &#123; System.out.println(stack2.pop().data); &#125;&#125; 四、层次遍历 level1 -&gt; level2 -&gt; … (每一层从左到右) 层次遍历是广度优先搜索，需要使用队列，利用队列的First-In-First-Out的特点，每一层逐个按左孩子右孩子的顺序往队列里添加。 12345678910111213141516public void levelOrder(Node root) &#123; ArrayDeque&lt;Node&gt; queue = new ArrayDeque&lt;&gt;(); if (root == null) return; Node p = null; queue.offer(root); while (!queue.isEmpty()) &#123; p = queue.poll(); System.out.println(p.data); if (p.left != null) &#123; queue.offer(p.left); &#125; if (p.right != null) &#123; queue.offer(p.right); &#125; &#125;&#125; 五、总结 一定要记住树的定义本身是一种递归的方式定义的。因此左子树和右子树都可以看成一棵树，实现各种算法的时候可以根据这点来考虑。左孩子是左子树的根节点，右孩子是右子树的根节点。 A tree data structure can be defined recursively (locally) as a collection of nodes (starting at a root node), where each node is a data structure consisting of a value, together with a list of references to nodes (the “children”), with the constraints that no reference is duplicated, and none points to the root. 递归一定要从大局入手，不要考虑细节，比如前序遍历，大局就是先访问根节点，再访问左子树，再访问右子树，可以立马能写出来代码。 广度优先搜索一般使用队列；深度优先搜索一般使用栈和递归方式。 所有代码见github-tree 参考Iterative Preorder Traversal Inorder Tree Traversal without Recursion Iterative Postorder Traversal | Set 2 (Using One Stack) 二叉树前序、中序、后序遍历非递归写法的透彻解析 二叉树的层次遍历]]></content>
      <tags>
        <tag>算法</tag>
        <tag>树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Windows Server 2016 计划任务优先级更改方法]]></title>
    <url>%2FWindows-Server-2016-%E8%AE%A1%E5%88%92%E4%BB%BB%E5%8A%A1%E4%BC%98%E5%85%88%E7%BA%A7%E6%9B%B4%E6%94%B9%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[遇到的问题 以交互方式运行程序的IO速度远快于以计划任务运行程序的IO速度 原因 计划任务默认的优先级为低于正常，IO速度会下降。 解决方式打开任务计划程序 创建任务 创建完成后，导出该任务为xml文件 编辑修改该xml文件的&lt;Priority&gt;7&lt;/Priority&gt;，将7改成正常的优先级(4-6)。优先级4将会使计划任务有和交互式程序一样的IO优先级和内存优先级；优先级5和6则会有较低的内存优先级。 在任务计划程序中删除刚才创建的任务。 在任务计划程序中导入修改好的任务xml文件创建计划任务。 参考Is there any way for a win2k8 scheduled task to have normal priority IO? TaskSettings.Priority]]></content>
      <tags>
        <tag>Windows</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[如何寻找N范围内的所有质数]]></title>
    <url>%2F%E5%A6%82%E4%BD%95%E5%AF%BB%E6%89%BEN%E8%8C%83%E5%9B%B4%E5%86%85%E7%9A%84%E6%89%80%E6%9C%89%E8%B4%A8%E6%95%B0%2F</url>
    <content type="text"><![CDATA[一、基本概念质数(prime number):指在大于1的自然数中，除了1和该数自身外，无法被其他自然数整除的数。 合数(composite number)：指在大于1的自然数中，因数除了1和其本身外具有另一因数的正整数。 0和1既不是质数也不是合数。 孪生素数：是指一对素数，它们之间相差2。例如3和5，5和7，11和13，10016957和10016959等等都是孪生素数。 约数：假如整数n除以m，结果是无余数的整数，那么我们称m就是n的约数。 自然数 N 的全部正约数个数以d(n)表示，若N=a1^n1 *a2^n2 …，其中a1,a2为质数，则d(n) = (n1+1)(n2+1)… ，对a1可以取a1^0 可以取 a1^1, a1^2…,所有a1因子有n1+1中选择，其他因子类似。 二、相关定理素数定理用于估计素数个数。对正整数x，小于等于x范围内的素数的个数π(x)≈x/lnx，误差一般不超过±15%。x越大误差越小。 算术基本定理，又称为正整数的唯一分解定理。每个大于1的自然数均可写为质数的积，而且这些素因子按大小排列之后，写法仅有一种方式。 三、测试素数1. 试除法（确定性算法）测试n是否为素数的最基本方法为试除法。此一程序将n除以每个大于1且小于等于n的平方根之整数m。若存在一个相除为整数的结果，则n不是素数；反之则是个素数。实际上，若n=ab是个合数（其中a与b≠1），则其中一个约数a或b必定至大为sqrt(n)。 2. 埃拉托斯特尼筛法埃拉托斯特尼筛法（sieve of Eratosthenes），简称埃氏筛，是一种简单且年代久远的筛法，用来找出一定范围内所有的素数。 所使用的原理是从2开始，将每个素数的各个倍数，标记成合数。一个素数的各个倍数，是一个差为此素数本身的等差数列。此为这个筛法和试除法不同的关键之处，后者是以素数来测试每个待测数能否被整除。 伪代码: 1234567891011Input: an integer n &gt; 1Let A be an array of Boolean values, indexed by integers 2 to n,initially all set to true.for i = 2, 3, 4, ..., not exceeding √n: if A[i] is true: for j = i^2, i^2+i, i^2+2i, i^2+3i, ..., not exceeding n: A[j] := falseOutput: all i such that A[i] is true. Java 代码： 1234567891011121314public boolean[] primes(int num) &#123; boolean[] isPrime = new boolean[num + 1]; for (int i = 2; i &lt;= num; i++) &#123; isPrime[i] = true; &#125; for (int i = 2; i*i &lt;= num; i++) &#123; if (isPrime[i]) &#123; for (int j = i*i; j &lt;= num; j+=i) &#123; isPrime[j] = false; &#125; &#125; &#125; return isPrime;&#125; 时间复杂度：O(nloglogn)。此种筛法会重复删除某个合数，比如30=2*15=3*10=5*6，会重复筛掉3次，这样会导致速度慢。解决方法是按照一个数的最小素因子筛选。 3. 欧拉筛法（线性筛法）基本思想：按照一个数的的最小素因子筛选。每个合数一定有几个素因子，一定有最小的一个素因子。最大素因子是唯一的，所以合数只会被它自己唯一的最素因子筛掉一次。 过程：当前数字是n=p1^a * p2^b * p3^c (p1 &lt; p2 &lt; p3)，一次循环筛掉小于等于p1素因子（根据构建的素数表）乘以n得到的数。比如p1之前有pi,pj和pk三个素数，则此次循环筛掉的数有 pi*n, pj*n, pk*n 和 p1*n。 从图上我们看到，第一列筛掉的是最小素因子是2的数，第二列筛掉的是最小素因子为3的数，依次类推，可以把所有的合数都筛掉，不会重复筛选。 比如30=2*15=3*10=5*6仅仅会根据15*2去筛掉。 Java 代码： 123456789101112131415161718192021public boolean[] primes(int num) &#123; boolean[] isPrime = new boolean[num + 1]; int[] primes = new int[num]; int cnt = 0; for (int i = 2; i &lt;= num; i++) &#123; isPrime[i] = true; &#125; for (int i = 2; i &lt;= num; i++) &#123; if (isPrime[i]) &#123; primes[cnt++] = i; &#125; for (int j = 0; j &lt; cnt &amp;&amp; i*primes[j] &lt;= num; j++) &#123; isPrime[i*primes[j]] = false; if (i % primes[j] == 0) &#123; break; &#125; &#125; &#125; return isPrime;&#125; 时间复杂度：O(n) 代码见：github max prime 4. 米勒拉宾检验（随机性算法）参考：求质数算法的 N 种境界1-试除法和初级筛法 线性筛法 wiki-Sieve of Eratosthenes 这只菜鸟总算搞懂了线性筛素数 数论——筛法求素数 线性筛法求素数 Sieve of Sundaram]]></content>
      <tags>
        <tag>算法</tag>
        <tag>数论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构-哈希表]]></title>
    <url>%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%93%88%E5%B8%8C%E8%A1%A8%2F</url>
    <content type="text"><![CDATA[一、前言查找的实质是确定关键码等于给定值的记录在查找集合中的存储位置。 由于存储位置与关键码之间不存在确定的对应关系，一般的查找方法是通过比较的方法找到要查询的记录。 若存储位置与关键码之间存在对应关系，则可以通过计算的方式来查找，这种方式就是散列技术. 二、基本概念 若关键字为 key，则其值存放在H(key)的存储位置上。由此，不需比较便可直接取得所查记录。称这个对应关系H为散列函数，按这个思想建立的表为散列表，也叫哈希表。 散列过程：①存储记录，通过H(key)计算记录的散列地址，并按此地址存储记录；②查找记录，通过同样的H(key)计算记录的散列地址，按此地址访问该记录。 现实中，对不同的关键字可能得到同一散列地址，即key1≠key2，而H(kye1)=H(key2)，则产生了冲突，针对冲突有多种解决方式。 哈希表的实现主要需要解决两个问题，哈希函数和冲突处理。 三、散列函数(哈希函数)哈希查找第一步就是使用哈希函数将键映射成索引。这种映射函数就是哈希函数。如果我们有一个保存0-M数组，那么我们就需要一个能够将任意键转换为该数组范围内的索引（0~M-1）的哈希函数。哈希函数需要易于计算并且能够均匀分布所有键。 1. 直接定址法取关键字或关键字的某个线性函数值为散列地址。H(key) = a * k + b 2. 除留余数法取关键字被某个不大于散列表表长m的数p除后所得的余数为散列地址。H(key) = key % p, p &lt;= m.其中p一般选取为小于或等于散列表长度m的某个最大素数。这种方法计算简单且效果好，因此最常用。 3. 数字分析法在已知所有关键码，并对每一位的取值分布有所分析的情况下，可以取关键字的若干数位（分布均匀的数位）组合成为哈希地址。 4. 平方取中法取关键字平方后的中间几位为哈希地址。通常在选定哈希函数时不一定能知道关键字的全部情况，取其中的哪几位也不一定合适，而一个数平方后的中间几位数和数的每一位都相关，由此使随机分布的关键字得到的哈希地址也是随机的。取的位数由表长决定。 5. 折叠法将关键码从左到右分割成位数相等（根据散列表长的位数决定）的若干部分，然后取他们的叠加并舍弃最高进位后的结果为哈希地址。 叠加的方法有两种： 移位叠加：将各部分相加。 间界叠加：从一端到另一端沿各部分分界来回折叠后相加，其中奇数段为正序，偶数段为倒序。 如key=25346358705，散列表长为三位数，则可以将关键码三位一分割，得到253,463,587,05。 移位叠加：(253+463+587+05) = 1308 舍弃最高进位得308。 间界叠加：(253+364+587+50) = 1254 舍弃最高进位得254。 这种方法适用于关键字的数字位数特别多的情况。 四、冲突处理尽管散列函数的目标是使得冲突最少，但实际上冲突是无法避免的。因此，我们必须研究冲突解决策略。 冲突处理实质上是为产生冲突的地址寻找下一个地址。 冲突处理的方法有以下几种： 1. 开放地址法(open addressing)当冲突发生时，使用某种方法在散列表中形成一个探测序列，沿着此探测序列逐个单元地查找，直到找到给定的关键码或者碰到一个开放的地址为止。 形成探测序列的方法不同，所得到的解决冲突的方法也不同。 哈希地址的计算公式为： H=(H(key) + di) % m 其中m为散列表的长度，di表示探测序列。 不同的di，会产生不同的探测法。 线性探测法，di=1,2,3,…,m-1。此种方法会造成聚集(cluster)现象，产生一次聚集。 平方探测法，di=1^2, 2^2, 3^2, …, k^2(k&lt;=m/2)。此种方法解决了线性探测法的一次聚集，但还是会产生二次聚集。 随机探测法，di是一组伪随机数列。 2. 链地址法(seperate chaining)将所有散列地址相同的记录都存储在一个单链表中，称为同义词子表。 如图所示： 链地址法优点：不会产生聚集现象；适合无法确定表长的情况；删除节点方便。 3. 公共溢出法公共溢出法的基本思想是散列表包含基本表和溢出表两个部分，将发生冲突的记录存储在溢出表中。对应的查找方法是通过散列函数计算散列地址，先与基本表进行比较，若相等，则查找成功；否则，到溢出表中顺序查找。 4.双散列法 Double Hashing is works on a similar idea to linear and quadratic probing. Use a big table and hash into it. Whenever a collision occurs, choose another spot in table to put the value. The difference here is that instead of choosing next opening, a second hash function is used to determine the location of the next spot. For example, given hash function H1 and H2 and key. do the following: Check location hash1(key). If it is empty, put record in it.If it is not empty calculate hash2(key). Check if hash1(key)+hash2(key) is open, if it is, put it in repeat with hash1(key)+2hash2(key), hash1(key)+3hash2(key) and so on, until an opening is found. like quadratic probing, you must take care in choosing hash2. hash2 CANNOT ever return 0. hash2 must be done so that all cells will be probed eventually. 5.再散列法即在上次散列计算发生冲突时，利用该次冲突的散列函数地址产生新的散列函数地址，直到冲突不再发生. 五、哈希表的性能影响冲突的因素有： 散列函数是否均匀 处理冲突的方法 散列函数的装填因子(负载因子)a，即 a=填入表中的元素的个数/散列表的长度，a与表中的元素的个数成正比，表征了哈希表装满程度。a越大，表中的元素越多，产生的冲突可能性就越大。 扩展哈希树 参考：Collision Resolution YouTube-CS50-Hash Tables YouTube-Hashing Technique - Simplified YouTube-Hash Tables and Hash Functions]]></content>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构-栈和队列]]></title>
    <url>%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97%2F</url>
    <content type="text"><![CDATA[一、栈栈 (Stack)是一种后进先出(last in first out，LIFO)的数据结构。栈只允许在一端进行操作。 栈的操作栈是一种抽象数据类型(ADT),其上的操作有: Stack() 创建空栈 void push(T x) 向栈中添加元素 T pop() 从栈顶弹出数据 T peek() 仅查看栈顶元素，并不弹出 boolean isEmpty() 判断栈是否为空。 以上这些操作的时间复杂度要满足O(1)的约束。 栈的实现栈的实现方式有两种：采用数组或链表实现。 数组实现Java官方库中有个Stack类（但不推荐，因为它是遗留下来的，不属于集合类中，建议使用Deque实现栈的操作），其采用的就是数组实现。 数组实现要注意动态Resize，当栈满的时候扩充容量，当栈较空的时候缩小容量。有一个top指明了当前栈顶元素所在位置，当top=-1时，栈为空。 实现见 github ArrayStack 链表实现栈也可以采用单链表实现，push和pop操作只要在链表头进行操作即可满足O(1)的约束。无论采取何种方式实现，只要满足以上ADT的约束（即实现这些操作，并使这些操作的时间复杂度为O(1))，则为Stack。 实现见 github LinkedListStack 参考：浅谈算法和数据结构: 一 栈和队列 纸上谈兵: 栈 (stack) YouTube - Array implementation of Stack 二、队列队列 (Queue)是一种先进先出(first in first out，FIFO)的数据结构。队列只允许在后端（称为rear）进行插入操作，在前端（称为front）进行删除操作。 队列的操作队列是一种抽象数据类型(ADT),其上的操作有: Queue() 创建空队列 void enqueue(T x) 向队列中添加元素 T dequeue() 从队列中出列一个数据 T front() 仅查看队列的头元素，并不出列 boolean isEmpty() 判断队列是否为空。 以上这些操作的时间复杂度要满足O(1)的约束。无论采取何种方式实现，只要满足以上ADT的约束（即实现这些操作，并使这些操作的时间复杂度为O(1))，则为Queue。 队列的实现队列的实现方式有两种：采用数组或链表实现。 数组实现Java官方库中有个ArrayBlockingQueue类，其采用的就是数组实现。 数组实现中有两个指针，head和tail，分别指向队列头和尾。初始时head=tail=-1。 实现见 github ArrayQueue 链表实现队列也可以采用单链表实现，要有两个指针，head和tail指针分别指向对头和对尾。 实现见 github LinkedListQueue 参考：The Queue Abstract Data Type YouTube - Array implementation of Queue 数据结构（三）——队列及实现、循环队列实现 java数据结构与算法之（Queue）队列设计与实现 三、双端队列双端队列（deque，全名double-ended queue）是一种同时具有队列和栈性质的数据结构。双端队列中的元素可以从两端弹出，插入和删除操作限定在队列的两边进行。 在Java中实现了Deque，有两个重要的实现子类，ArrayDeque和LinkedList。ArrayDeque是采用数组实现的双端队列，LinkedList是采用链表实现的双端队列。 建议使用栈时，用ArrayDeque或者LinkedList的push和pop方法；使用队列时，使用ArrayDeque或者LinkedList的add和remove方法。 参考：java 中的Stack、Queue、Deque Wiki-Deque 深入理解循环队列—-循环数组实现ArrayDeque Java 数据结构之Deque(双向队列)]]></content>
      <tags>
        <tag>算法</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[算法问题-约瑟夫问题]]></title>
    <url>%2F%E7%AE%97%E6%B3%95%E9%97%AE%E9%A2%98-%E7%BA%A6%E7%91%9F%E5%A4%AB%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[约瑟夫问题是一个非常著名的趣题，即由n个人坐成一圈，按顺时针由1开始给他们编号。然后由第一个人开始报数，数到m的人出局。现在需要求的是最后一个出局的人的编号。 给定两个int n和m，代表游戏的人数。请返回最后一个出局的人的编号。保证n和m小于等于1000。 测试样例： 5 3 返回: 4 一、单循环链表法构建单循环链表，遇到被kill的编号则删除节点，直到最后留下一个节点。此种方法较为简单直接，不作具体展开。 时间复杂度：O(n*m) 二、递推法初始情况：0,1,2,3,4…,n-1(共n个人)，0为第一个人的编号 第一个被kill的人的编号是 (m-1) % n，分析过程如下： 当m &lt;= n 时，比如m=3，n=5，则第一个被kill的编号为0，即 (m-1)%n 当m &gt; n 时，比如m=3, n=2，则第一个被kill的编号为0，即 (m-1)%n 设第一个被kill的人编号为k, k = (m-1) % n，则第二次报数从k+1开始，剩下的构成了n-1人的约瑟夫环。 k+1 -&gt; 0 k+2 -&gt; 1 n-1 -&gt; n-k-2 … 0 -&gt; n-k-1 1 -&gt; n-k … k-1 -&gt; n-2 右边即为n-1的约瑟夫环问题了，求出n-1的约瑟夫的幸存者编号x0，则可以由上面的关系来逆推得到n的约瑟夫环问题的编号x， x = (x0 + k + 1) % n = (x0 + m) % n。 设初始问题的解为f(n, m)，子问题的解为f(n-1, m)，则有以下递推式： f(n, m) = (f(n-1, m) + m) % n f(1, m) = 0 特别地，当m=2时， 若n=2^a + t f(n, 2) = 2*t 当编号由1开始时，递推式变成： f(n, m) = (f(n-1, m) + m - 1) % n + 1 f(1, m) = 1 f(n, 2) = 2*t + 1 注：比如当n = 5, m = 5时，第一个被kill的编号为5，是(m-1) % n + 1，内部式子减掉1，取余后再加1即可得到5。 代码实现见 ： 迭代版 12345678910public class Joseph &#123; public int getResult(int n, int m) &#123; if (n &lt; 1 || m &lt; 1) return -1; int last = 1; for (int i = 2; i &lt;= n; i++) &#123; last = (last + m - 1) % i + 1; &#125; return last; &#125;&#125; 递推版 12345678public class Joseph &#123; public int getResult(int n, int m) &#123; // write code here if (n &lt; 1 || m &lt; 1) return -1; if (n == 1) return 1; return (getResult(n - 1, m) + m - 1) % n + 1; &#125;&#125; 时间复杂度: O(n)，空间复杂度：O(1) 参考： What is the best solution for Josephus problem algorithm? Youtube - 约瑟夫问题(m=2) Wiki - Josephus problem 动态规划解决约瑟夫环问题 约瑟夫问题的两个O(log n)解法 Explanation for recursive implementation of Josephus prob]]></content>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构-数组和链表]]></title>
    <url>%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%95%B0%E7%BB%84%E5%92%8C%E9%93%BE%E8%A1%A8%2F</url>
    <content type="text"><![CDATA[数据存储结构数据元素在计算机存储器的方式主要有两种： 顺序存储，一般使用数组。 链式存储，一般使用链表。 数组数组是一种最基本的数据结构，它是一种物理存储单元上连续、顺序的存储结构，数据元素的逻辑顺序是通过数组的索引次序实现的。 时间复杂度： Access: O(1) Delete: O(n) Insert: O(n) 优点：查找访问速度快。缺点：不能适应动态数据增减；插入和删除操作速度慢。 链表链表是一种最基本的数据结构，它是一种物理存储单元上非连续、非顺序的存储结构，数据元素的逻辑顺序是通过链表中的指针链接次序实现的。 链表由一系列结点（链表中每一个元素称为结点）组成，结点可以在运行时动态生成。每个结点包括两个部分：存储数据元素的数据域，存储下一个结点地址的指针域。 123456789101112131415161718192021222324252627public class Node &#123; private int data; private Node next; Node() &#123; &#125; Node(int data) &#123; this.data = data; &#125; public void setData(int data) &#123; this.data = data; &#125; public void setNextNode(Node nextNode) &#123; this.next = nextNode; &#125; public int getData() &#123; return this.data; &#125; public Node getNextNode() &#123; return this.next; &#125;&#125; 时间复杂度： Access: O(n) Delete: O(1) Insert: O(1) 优点：能适应动态数据增减，新添加的节点可以动态申请内存，对内存的利用率高；插入和删除操作速度快。缺点：由于要存储指针域，空间占用大；查找访问速度慢。 链表按链表方式分为： 单链表：只有一个next指针域。一般有个头指针指向链表中第一个结点，为了操作的统一与方便，设立了，放在第一个元素结点之前，其数据域一般无意义。实现见github singly linked list 双链表：有next指针域和prev指针域。克服了单链表查找前驱节点时间复杂度为O(n)的缺点。 循环链表：最后一个结点的指针域指向头结点，整个链表形成一个环。用尾指针rear表示的单循环链表对开始结点a1和终端结点an查找时间都是O(1)，如果仅用头指针来表示的话，查找到终端节点需要O(n)。表的操作常常是在表的首尾位置上进行，因此，实用中多采用尾指针表示单循环链表。循环链表可以解决约瑟夫问题。 链表按实现方式分为： 动态链表(使用指针或引用的方式实现) 静态链表(使用数组和游标实现) 扩展-链表相关问题静态链表静态链表相当于是用一个数组来实现线性表的链式存储结构，在静态链表中操作的是数组。 静态链表的数组元素也有数据域和指针域，只不过指针域是int型，表示下一个元素在数组中的索引，也可以称之为游标。 1234private static class Node&lt;E&gt; &#123; E data; int next; //下一个结点所在的数组下标&#125; 数组第一个元素和最后一个元素为特殊元素，数据域不存数据，第一个元素的指针域(cur)存放的是第一个空间可用元素(元素为空)的下标，最后一个元素的指针域(cur)存放的是实际数据的首元素的下标(类似于动态链表front-&gt;next)。 实现见github static linked list 参考： 数据结构与算法–静态链表 静态链表（游标实现法） 使用递归方法反向单链表1234567891011public Node reverse(Node node) &#123; if (node == null || node.getNext() == null) &#123; front.setNext(node); return; &#125; reverse(node.getNext()); node.getNext().setNext(node); node.setNext(null);&#125; 针对递归方式，要弄清楚最后一次end condition，以及递归返回以后要做什么操作。 参考：YouTube-Reverse a linked list - Reverse a linked list using recursion 使用非递归方法反向单链表123456789101112131415161718public void reverse() &#123; if (front.getNext() == null) &#123; return; &#125; Node prev = null; Node curr = front.getNext(); Node next; while (curr != null) &#123; next = curr.getNext(); curr.setNext(prev); prev = curr; curr = next; &#125; front.setNext(prev);&#125; 参考：YouTube-Reverse a linked list - Iterative method 检查链表是否有环使用龟兔赛跑模型：如果是一条直线，兔子永远会跑在前面；如果兔子发现又追上乌龟了，那么只能是兔子套了乌龟一圈。 算法逻辑如下： 指针hare初始化指向链表头结点，每次向后移动2个节点。 指针tortoise初始化指向链表头结点，每次向后移动1个节点。 如果hare最终指向尾节点或尾节点前一个节点（总结点数可能是奇数也可能是偶数），则该链表无圈。 如果hare和tortoise又指向了同一个节点，则该链表有圈。 1234567891011121314151617181920212223242526272829303132333435// Floyd's cycle-finding algorithmpublic boolean isCyclic() &#123; Node tortoise = front; Node hare = front; while (hare != null &amp;&amp; hare.getNext() != null) &#123; tortoise = tortoise.getNext(); hare = hare.getNext().getNext(); if (tortoise == hare) &#123; return true; &#125; &#125; return false;&#125;// Brent's Cycle Detection Algorithmpublic boolean isCyclic2() &#123; Node tortoise = front; Node hare = front; int taken = 0; int limit = 2; while (hare != null) &#123; hare = hare.getNext(); taken++; if (hare == tortoise) &#123; return true; &#125; if (taken == limit) &#123; taken = 0; limit &lt;&lt;= 1; tortoise = hare; &#125; &#125; return false;&#125; 参考： wiki-Cycle detection How to detect a loop in a linked list? Brent’s Cycle Detection Algorithm (The Teleporting Turtle 使用单向循环链表解决约瑟夫问题 其他参考： CSDN 数组、链表、堆栈和队列 cnblogs 数组、链表、栈、队列和STL 时间复杂度分别为 O（n）和 O（1）的删除单链表结点的方法 结构之美：单链表的头结点与头指针 用链表的目的是什么？省空间还是省时间？ LeetCode #141 Linked List Cycle How to Find if Linked List contains Loops or Cycles in Java How to reverse a singly linked list in Java 单循环链表中设置尾指针比设置头指针更好的原因]]></content>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构和算法基本概念]]></title>
    <url>%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5%2F</url>
    <content type="text"><![CDATA[算法 + 数据结构 = 程序 一、数据结构数据结构是指数据的逻辑结构和存储结构。数据结构是按照某种逻辑关系组成的一组数据，并按一定的存储方式存储在计算机的存储器中，并在这些数据上定义了一组运算的集合。 数据结构有三要素：数据逻辑结构、数据存储结构、数据的运算。 逻辑结构逻辑结构：数据元素之间的存储关系。 集合结构 集合结构:数据元素除了同属于一个集合外,他们之间没有其他关系。 线性结构 数据元素之间的关系是一对一的关系。 线性表 栈 队列 串 非线性结构 数据元素之间的关系是一对多或多对多的关系。 树 图 多维数组 堆 存储结构存储结构：数据元素及其关系在计算机存储器内的存储形式。 顺序存储结构：逻辑上相邻的节点存储在物理位置上相邻的存储单元中。通常以数组的形式存储，但是静态链表由于相邻的节点并不一定存储在物理位置相邻的存储单元中，所以不是顺序存储结构，还是一个链式存储结构。 链式存储结构：任意的存储单元存储线性表的数据元素，每个结点由数据域和指针域组成。 索引存储结构：在存储元素信息的同时，还建立附加的索引表。索引表中的每一项称为索引项，索引项的一般形式是：（关键字，地址）。 散列存储结构：根据元素的关键字直接计算出该元素的存储地址，又称为Hash存储。 用顺序存储结构存储的线性表称为顺序表。 用链式存储结构存储的线性表称为链表。 其他逻辑结构都可以采用两种不同的存储结构来实现，比如栈既可以用数组实现，也可以用链表实现，区别就在于数组需要固定大小，而链表则可以动态添加。` 链表按实现方式可分为：静态链表和动态链表。 链表按链接方式可分为：单链表、双链表和循环链表。 抽象数据类型(ADT)抽象数据类型（Abstract Data Type，ADT）是计算机科学中具有类似行为的特定类别的数据结构的数学模型；或者具有类似语义的一种或多种程序设计语言的数据类型。抽象数据类型是间接定义的，通过其上的可执行的操作以及这些操作的效果的数学约束（与可能的代价）。 对于用户来说只关心数据模型和在其上的操作，并不关心如何实现，如何存储的。比如Stack,它仅能在一端进行添加数据和取出数据的操作(LIFO),有init, push, pop, top, isEmpty等操作。 粗略地说， 抽象数据类型=逻辑结构+操作 在Java中通过接口来表示抽象数据类型，接口的实现来表示抽闲数据类型的实现。 参考: 「数据结构」和「数据类型」两个概念的本质是什么，区别与联系 数据类型和常用数据结构 二、算法算法是指对数据的操作方法的描述。]]></content>
      <tags>
        <tag>算法</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[非比较排序算法：计数排序、基数排序和桶排序]]></title>
    <url>%2F%E9%9D%9E%E6%AF%94%E8%BE%83%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%EF%BC%9A%E8%AE%A1%E6%95%B0%E6%8E%92%E5%BA%8F%E3%80%81%E5%9F%BA%E6%95%B0%E6%8E%92%E5%BA%8F%E5%92%8C%E6%A1%B6%E6%8E%92%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[计数排序计数排序的思想：对每一个输入元素，计算小于等于它的元素个数，如果有10个元素小于等于它，那么它就应该放在11的位置上，如果有17个元素小于等于它，它就应该放在18的位置上。 计数排序的过程： 找出待排序的数组中最大和最小的元素 统计数组中每个值为i的元素出现的次数，存入数组 C 的第 i 项（如果min &gt; 0， 则存入数组 C 的第 i - min 项，下同） 对所有的计数累加（从C中的第一个元素开始，每一项和前一项相加） 反向填充目标数组：将每个元素i放在新数组的第C(i)项，每放一个元素就将C(i)减去1，原来数组后面的先放，这样就保证了稳定性。 复杂度： 时间复杂度：O(n+k)， n是输入数据的个数，k是输入数据的范围大小 空间复杂度: O(n+k)， n是输入数据的个数，k是输入数据的范围大小 当输入数据的范围大小超过n时，计数排序就不合适了，计数排序适用于小范围的整数序列的排序。 算法实现见:github counting sort 计数排序参考： YouTube-CountingSort Why can’t we use count sort as a general purpose sorting algorithm? 基数排序基数排序（Radix sort)是把每一位用计数排序来排序（由低位到高位排序，每次排序得到一个中间结果，然后用这个中间结果继续排序，直到所有位都排序完得到最终结果），解决了计数排序范围大时时间复杂度和空间复杂度都大的问题。 为什么要从低位开始向高位排序? 如果要从高位排序, 那么次高位的排序会影响高位已经排好的大小关系. 在数学中, 数位越高,数位值对数的大小的影响就越大.从低位开始排序,就是对这种影响的排序. 数位按照影响力从低到高的顺序排序, 数位影响力相同则比较数位值。 其实，也是可以从高位开始排序，算法为MSD Radix sort。过程： 获取每个key的最大位。 根据最大位排序，并将相同位的数据放在一个bucket中。 根据下一位递归的排序每一个bucket。 将所有的bucket组合按顺序输出即可。 复杂度： 时间复杂度：O(d(n+k))， n是输入数据的个数，d是最大数字位数，k是每一位的数据范围大小 空间复杂度: O(n+k)，n是输入数据的个数, k是每一位的数据范围大小 算法实现见:github radix sort 基数排序参考: YouTube-Radix Sort-step by step guide 维基百科-基数排序 YouTube-MSD radix sort 桶排序桶排序的过程： 将输入数据划分到N个桶中(多少个桶由自己决定)，即将min~max分成N份（最好能差不多均匀分布）。 对这N个桶分别进行插入排序。 遍历每个桶，按照次序把各个桶的元素列出来。 伪代码： 1234567function bucketSort(array, n) is buckets ← new array of n empty lists for i = 0 to (length(array)-1) do insert array[i] into buckets[msbits(array[i], k)] for i = 0 to n - 1 do nextSort(buckets[i]); return the concatenation of buckets[0], ...., buckets[n-1] 当每个桶的数据范围大小为1时，则为鸽巢排序。当数据分布很不均匀时，时间复杂度有可能是O(n^2)。 桶排序参考： YouTube-Bucket Sort-step by step guide YouTube-Bucket sort YouTube-Pigeonholes sort 总结：以上三种排序算法虽然能在线性时间内排序，但是需要额外的空间，并且输入要满足一定的条件，比如计数排序要求输入满足整数才可以，桶排序则需要输入数据满足均匀分布，因此大部分情况下都是采用的基于排序的O(nlogn)的排序算法如快速排序。]]></content>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构-堆]]></title>
    <url>%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%A0%86%2F</url>
    <content type="text"><![CDATA[堆是计算机科学中一类特殊的数据结构的统称。堆又被称为优先队列，普通的队列是先进先出，堆是最小或最大(分别对应最小堆和最大堆)先出。 n个元素序列{k1,k2…ki…kn},当且仅当满足下列关系时称之为堆：(ki &lt;= k2i,ki &lt;= k2i+1)或者(ki &gt;= k2i,ki &gt;= k2i+1), (i = 1,2,3,4…n/2) 堆的性质堆的实现是完全二叉树，实现的堆称为二叉堆。其具有以下性质: 父节点大于所有子节点(最大堆，大根堆)或者父节点小于所有子节点(最小堆，小根堆) 堆总是一棵完全树。即除了最底层，其它层的节点都被元素填满，最底层尽可能地从左到右填入。 应用场景重要有两个： 堆排序 优先队列 堆的操作堆的操作主要有两个(其他的比如创建空堆，重构堆等操作则是辅助操作)： 删除操作(删除操作只能删除根节点) 插入操作 这两个操作都涉及到了堆的重构，因为它们都破坏了堆的结构。本文暂时以小根堆来讲解这些操作。 针对删除操作的重构方式：删掉根节点后，会有两个子树，将最后一个节点放到根节点的位置，然后不断的跟子节点比较，如果大于小的那个子节点，则交换两者，递归这个过程，直到下沉的节点不再大于任一子节点或者成为了叶节点。 针对插入操作的重构方式：新插入的节点放在完全二叉树最后的位置（数组的末尾）。再和父节点进行比较，如果小于父节点，这父节点交换，递归调用此过程直至不小于父节点或成为根节点。 堆的实现堆通常以数组的形式实现，位置k的节点的父节点的位置为k/2向下取整(可以使用右移一位表示)，而它的两个子节点的位置分别为2k和2k+1。为方便这样计数，简化计算，一般根节点是放在k=1的位置，堆的表示中不使用a[0]。 具体实现代码见 github 总结堆有两种主要操作：插入元素和删除根节点。堆一般用数组实现。 扩展阅读优先队列优先队列是计算机科学中的一类抽象数据类型。优先队列中的每个元素都有各自的优先级，优先级最高的元素最先得到服务；优先级相同的元素按照其在优先队列中的顺序得到服务。优先队列往往用堆来实现。 优先队列有两种实现： 初级实现 堆实现 初级实现采用有序数组或者无序数组来实现。有序数组插入操作时间复杂度为O(n)，删除操作为O(1)；无序数组插入操作时间复杂度为O(1)，删除操作为O(n)。 堆实现则使插入和删除操作的时间复杂度为O(logn)。 因此优先队列常使用堆来实现。 堆排序堆排序（Heapsort）是指利用堆这种数据结构所设计的一种排序算法。 在堆的数据结构中，堆中的最大值总是位于根节点(在优先队列中使用堆的话堆中的最小值位于根节点)。堆中定义以下几种操作： 最大堆调整（Max_Heapify）：将堆的末端子节点作调整，使得子节点永远小于父节点 创建最大堆（Build_Max_Heap）：将堆所有数据重新排序 堆排序（HeapSort）：移除位在第一个数据的根节点，交换到数组的末尾，并做最大堆调整的递归运算。 具体实现代码见 github 性能： 最优时间复杂度：O(nlogn) 最坏时间复杂度：O(nlogn) 平均时间复杂度：O(nlogn) 空间复杂度: O(1) 不稳定。 参考： 纸上谈兵: 堆 (heap) Youtube-堆 数据结构系列——堆 维基百科-堆) 维基百科-优先队列]]></content>
      <tags>
        <tag>算法</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo中如何插入图片]]></title>
    <url>%2FHexo%E4%B8%AD%E5%A6%82%E4%BD%95%E6%8F%92%E5%85%A5%E5%9B%BE%E7%89%87%2F</url>
    <content type="text"><![CDATA[Hexo有多种方式插入图片，以下讲解其中三种方式。 一、通过Markdown语法引用将图片 example.jpg 放在 source/images 目录下，在文章的md文件中插入 ![](/images/example.jpg) 即可。 这种方法针对的是在hexo整个项目中有少量的图片的情况，且 _config.yml 中 post_asset_folder 必须为 false 才能引用。 二、通过标签插件引用在hexo3中，新的标签插件被加入到了核心代码里，此时可以采用标签插件引用来插入图片，这样的好处在于图片资源管理较为方便。 设置_config.yml 中 post_asset_folder 为 true 可以使每一次hexo new post postname都创建一个postname的文件夹和postname.md的文件。 把图片 example.jpg 放到postname文件夹中，然后在md文件里使用下面方式引用： {% asset_img example.jpg This is an example image %} 三、CDN引用将图片上传到一些免费的CDN服务中。上传完图片后会生成对应的url，直接引用url即可插入图片。 图片测试： 参考: Hexo官方文档-Asset资源文件夹]]></content>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[GitHub+Hexo搭建博客]]></title>
    <url>%2FGitHub%2BHexo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%2F</url>
    <content type="text"><![CDATA[一、创建github page在github.com上新建repository，repository的名字是 username.github.io ，比如我在github上的用户名是limitless083，因此新建的repository名字为 limistless083.github.io 二、安装Hexo的依赖Hexo依赖下列应用程序： Git Node.js Git 用来将生成的网页部署到github上。 Node 则用来生成网页。 三、安装Hexo执行以下命令即可 $ npm install -g hexo-cli 前三部分参考: Hexo官方安装文档 四、部署Hexo应用在自己创建的文件夹比如my_blog文件夹内用命令行执行以下命令 123hexo init # 初始化hexo新项目npm install # 安装依赖npm install hexo-deployer-git --save # 安装git依赖 更新_config.yml中配置，修改为： 123deploy:- type: git repo: git@github.com:limitless083/limitless083.github.io.git 清空旧文件: hexo clean部署：hexo deploy 本部分可以参考: Hexo官方部署文档 五、更改主题hexo 主题有很多，其中最出名的是NexT主题，该主题有详细的文档设置，可以参考NexT官方文档 结语以上就是一些大概的流程介绍，Hexo官方文档和NexT官方文档解释的都比较详细，在此就不再赘述了。]]></content>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[执行inotifywait过程出现upper limit on inotify watches reached的解决方式]]></title>
    <url>%2F%E6%89%A7%E8%A1%8Cinotifywait%E8%BF%87%E7%A8%8B%E5%87%BA%E7%8E%B0upper%20limit%20on%20inotify%20watches%20reached%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[遇到的问题 执行inotifywait过程中出现upper limit on inotify watches reached 解决方式增加/proc/sys/fs/inotify/max_user_watches /proc/sys/fs/inotify/max_user_watches 表示每个inotify instatnces可监控的最大目录数量，在相关知识部分可以了解一下inotify。 解决步骤 检查一下inotify watches的最大值 1cat /proc/sys/fs/inotify/max_user_watches 设置inotify watches(以root权限) 12345678# 临时的sysctl fs.inotify.max_user_watches=81960# 永久的vi /etc/sysctl.conf添加 fs.inotify.max_user_watches=81960# 重新加载sysctl配置sysctl -p 相关知识sysctlsysctl命令被用于在内核运行时动态地修改内核的运行参数，可用的内核参数在目录/proc/sys中 常见用法: sysctl -a 列出所有可读变量 sysctl variable=value 设置指定变量(临时的,若要永久的可以更改/etc/sysctl.conf文件) sysctl -p 从配置文件“/etc/sysctl.conf”加载内核参数设置 参考：Linux命令大全-sysctl命令 inotifyInotify为Linux提供了一套高效监控和跟踪文件变化的机制，可以监控文件系统的访问属性、读写属性、权限属性、删除创建、移动等操作，也就是可以监控文件发生的一切变化，它采用的是事件驱动机制，不是轮询机制。 在Linux中提供了inotify-tools，该工具包含了两个命令inotifywait和inotifywatch,分别用来收集有关文件访问信息和关于被监视的文件系统的统计信息。 常见用法： inotifywait -mrq --timefmt &#39;%d/%m/%y/%H:%M&#39; --format &#39;%T %w %f&#39; -e create /dir 监听目录创建文件的事件。 参考: Linux命令大全-inotifywait Inotify: Efficient, Real-Time Linux File System Event Monitoring rsyncrsync是一个远程数据同步工具，可通过LAN/WAN快速同步多台主机间的文件。它使用所谓的“Rsync演算法”来使本地和远程两个主机之间的文件达到同步，这个算法只传送两个文件的不同部分，而不是每次都整份传送，因此速度相当快。所以通常可以作为备份工具来使用。 rsync的不足之处：rsync同步数据时，需要扫描所有文件后进行比对，进行差量传输。如果文件数量达到了百万甚至千万量级，扫描所有文件将是非常耗时的。因此常常使用rsync+inotify组合来实时同步数据。 常见用法: rsync -a /data /backup 从/data目录同步文件到/backup目录 rsync -v rsync://192.168.78.192/www 列远程机的文件列表。 参考: Linux命令大全-rsync]]></content>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux命令:find, grep和xargs的爱恨情仇]]></title>
    <url>%2FLinux%E5%91%BD%E4%BB%A4-find%2C%20grep%E5%92%8Cxargs%E7%9A%84%E7%88%B1%E6%81%A8%E6%83%85%E4%BB%87%2F</url>
    <content type="text"><![CDATA[find命令用来在指定目录下查找文件。 grep命令用来正则匹配，搜索文本，找到匹配的行并打印出来。全称是global search regular expression and print out the line。 xargs命令将参数列表转换成小块分段传递给其他命令，以避免参数列表过长的问题，一般是管道输出给xargs。 findfind的常见用法： 列出当前目录及子目录下所有文件和文件夹 find . 在”/home”目录下查找以.txt结尾的文件 find /home -name “*.txt” 在”/home”目录下查找不是以.txt结尾的文件 find /home ! -name “*.txt” 根据文件类型查找 find . -type 类型参数 类型参数有: f 普通文件l 符号链接d 目录c 字符设备b 块设备s 套接字p fifo 根据文件大小进行匹配, 搜索大于10k的文件 find . -type f -size +10k 根据权限进行匹配 find . -type f -perm 777 查找所有空文件 find . -empty 其他的详细的可以参考man find grepgrep的常见用法： 在文件中搜索一个单词，命令会返回一个包含”match_pattern”的文本行 grep “match_pattern” file 等同于 cat file | grep “match_pattern” 递归搜索文件 grep “text” . -r 在grep搜索结果中包括或者排除指定文件 只在目录中所有的.php和.html文件中递归搜索字符”main()” grep “main()” . -r –include *.{php,html} 在搜索结果中排除所有README文件grep “main()” . -r –exclude “README” 在搜索结果中排除filelist文件列表里的文件 grep “main()” . -r –exclude-from filelist 显示匹配某个结果的之前或之后的行，-A(after),-B(before),-C(context) cat file | grep “haha” -A 3 其他的详细的可以参考man grep xargsxargs的常见用法: xargs用作替换工具，读取输入数据重新格式化后输出 cat test.txt 输出： a b c d e f cat test.txt | xargs 输出： a b c d e f 删除最近的5个文件 ls -t | head -5 | xargs rm -rf 统计一个源代码目录中所有erlang文件的行数: find . -type f -name “*.erl” | xargs wc -l 其他的详细的可以参考man xargs]]></content>
  </entry>
  <entry>
    <title><![CDATA[How can I increase open files limit]]></title>
    <url>%2FHow-can-I-increase-open-files-limit%2F</url>
    <content type="text"><![CDATA[步骤 Use the following command command to display maximum number of open file descriptors cat /proc/sys/fs/file-max 6508886 To see the hard and soft values, issue the command as follows ulimit -Hn 4096 ulimit -Sn 1024 open the sysctl.conf and add this line fs.file-max = 65536, 65536 can be other number. vi /etc/sysctl.conf add new line: fs.file-max = 65536 modify /etc/security/limits.conf according to limits.conf man-page add user limit configuration, for example, for user cold: vi /etc/security/limits.conf add new line: cold - nofile 500000 500000 should be lower than file-max exit user and relogin 参考How can I increase open files limit for all processes? Linux Increase The Maximum Number Of Open Files / File Descriptors limits.conf man-page On Linux - set maximum open files to unlimited. Possible?]]></content>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>

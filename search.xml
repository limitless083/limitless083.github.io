<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[前序遍历、中序遍历、后序遍历的递归和非递归实现方法]]></title>
    <url>%2F%E5%89%8D%E5%BA%8F%E9%81%8D%E5%8E%86%E3%80%81%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86%E3%80%81%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86%E7%9A%84%E9%80%92%E5%BD%92%E5%92%8C%E9%9D%9E%E9%80%92%E5%BD%92%E5%AE%9E%E7%8E%B0%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[二叉树有4种遍历方式：前序遍历、中序遍历、后序遍历和后序遍历方式。 前序遍历、中序遍历、后序遍历是深度优先搜索，适合用递归方式和栈实现。 层次遍历是广度优先搜索，适合用队列实现。 树的结点：12345678Node &#123; int data; Node left, right; Node(int data) &#123; this.data = data; left = right = null; &#125;&#125; 一、前序遍历 root -&gt; left_child -&gt; right_child 递归方式： 访问根节点 访问左子树 访问右子树 123456public void recursivePreorder(Node root) &#123; if (root == null) return; System.out.println(root.data); recursivePreorder(root.left); recursivePreorder(root.right);&#125; 非递归方式：方法1 push左子树直到叶子节点，边push边遍历 12345while (p != null) &#123; System.out.println(p.data); stack.push(p); p = p.left;&#125; 当Stack不为空时，弹出栈，若该节点有右子树，则push右子树的左子树直到叶子节点。重复1,2（根节点-&gt;遍历左子树-&gt;遍历右子树） 12p = stack.pop();p = p.right; 完整代码： 123456789101112131415public void iterativePreorder(Node root) &#123; ArrayDeque&lt;Node&gt; stack = new ArrayDeque&lt;&gt;(); Node p = root; while (!stack.isEmpty() || p != null) &#123; while (p != null) &#123; // 边push边遍历，之后要借助push进来的节点到右子树上 System.out.println(p.data); stack.push(p); p = p.left; &#125; p = stack.pop(); p = p.right; &#125;&#125; 方法2利用栈具有First-In-Last-Out的特点。 过程：循环{ pop出节点后，先push当前节点的右节点，再push当前节点的左节点 }。 完整代码： 12345678910111213141516public void iterativePreorder(Node root) &#123; if (root == null) return; Node p = null; stack.push(root); while (!stack.isEmpty()) &#123; p = stack.pop(); System.out.println(p.data); if (p.right != null) &#123; stack.push(p.right); &#125; if (p.left != null) &#123; stack.push(p.left); &#125; &#125;&#125; 二、中序遍历 left_child -&gt; root -&gt; right_child 递归方式： 访问左子树 访问根节点 访问右子树 123456public void recursiveInorder(Node root) &#123; if (root == null) return; recursivePreorder(root.left); System.out.println(root.data); recursivePreorder(root.right);&#125; 非递归方式： push左子树直到叶子节点 1234while (p != null) &#123; stack.push(p); p = p.left;&#125; 当Stack不为空时，弹出栈，遍历该节点。若该节点有右子树，则push右子树的左子树直到叶子节点。重复1，2 （遍历左子树-&gt;根节点-&gt;遍历右子树） 123p = stack.pop();System.out.println(p.data);p = p.right; 完整代码：123456789101112131415public void iterativeInorder(Node root) &#123; ArrayDeque&lt;Node&gt; stack = new ArrayDeque&lt;&gt;(); Node p = root; while (!stack.isEmpty() || p != null) &#123; while (p != null) &#123; stack.push(p); p = p.left; &#125; p = stack.pop(); System.out.println(p.data); p = p.right; //下次循环就开始遍历右子树了 &#125;&#125; 三、后序遍历 left_child -&gt; right_child -&gt; root 递归方式： 访问左子树 访问右子树 访问根节点 123456public void recursiveInorder(Node root) &#123; if (root == null) return; recursivePreorder(root.left); recursivePreorder(root.right); System.out.println(root.data);&#125; 非递归方式：方法1后序遍历的迭代方法比前两个要难一点，难点在于只有当右子树遍历完了以后才可以弹出根节点。 设置一个lastVisitNode来指示最后一次遍历到哪了，根据这个来判断弹出的元素的右子树有没有遍历过，只有遍历过才可以访问根节点。 push左子树直到叶子节点 1234while (p != null) &#123; stack.push(p); p = p.left;&#125; 当Stack非空时，peek栈顶，看栈顶节点的右子树是否全部访问过，如果访问过就弹出该栈顶节点并访问；如果没有访问过，则push右子树的左子树直到叶子节点。重复1,2。（遍历左子树-&gt;遍历右子树-&gt;根节点） 12345678p = stack.peek();if (p.right == null || p.right == lastVisitNode) &#123; stack.pop(); System.out.println(p.data); lastVisitNode = p;&#125; else &#123; p = p.right;&#125; 完整代码： 12345678910111213141516171819202122public void iterativePostorder(Node root) &#123; ArrayDeque&lt;Node&gt; stack = new ArrayDeque&lt;&gt;(); Node p = root; Node lastVisitNode = null; while (!stack.isEmpty() || p != null) &#123; while (p != null) &#123; stack.push(p); p = p.left; &#125; p = stack.peek(); if (p.right == null || p.right == lastVisitNode) &#123; stack.pop(); System.out.println(p.data); lastVisitNode = p; // p节点已经访问过了，要置null防止下次循环再遍历 p = null; &#125; else &#123; p = p.right; &#125; &#125;&#125; 方法2思路：后序遍历是左子树-&gt;右子树-&gt;根节点，倒过来则可以是根节点-&gt;右子树-&gt;左子树，是前序遍历的变形。然后将这样的遍历压到另一个栈中，再弹出来。这样空间复杂度会由O(logn)变大为O(n)。 完整代码：123456789101112131415161718public void iterativePostorder3(Node root) &#123; ArrayDeque&lt;Node&gt; stack1 = new ArrayDeque&lt;&gt;(); ArrayDeque&lt;Node&gt; stack2 = new ArrayDeque&lt;&gt;(); Node p = root; while (!stack1.isEmpty() || p != null) &#123; while (p != null) &#123; stack2.push(p); stack1.push(p); p = p.right; &#125; p = stack1.pop(); p = p.left; &#125; while (!stack2.isEmpty()) &#123; System.out.println(stack2.pop().data); &#125;&#125; 四、层次遍历 level1 -&gt; level2 -&gt; … (每一层从左到右) 层次遍历是广度优先搜索，需要使用队列，利用队列的First-In-First-Out的特点，每一层逐个按左孩子右孩子的顺序往队列里添加。 12345678910111213141516public void levelOrder(Node root) &#123; ArrayDeque&lt;Node&gt; queue = new ArrayDeque&lt;&gt;(); if (root == null) return; Node p = null; queue.offer(root); while (!queue.isEmpty()) &#123; p = queue.poll(); System.out.println(p.data); if (p.left != null) &#123; queue.offer(p.left); &#125; if (p.right != null) &#123; queue.offer(p.right); &#125; &#125;&#125; 五、总结 一定要记住树的定义本身是一种递归的方式定义的。因此左子树和右子树都可以看成一棵树，实现各种算法的时候可以根据这点来考虑。左孩子是左子树的根节点，右孩子是右子树的根节点。 A tree data structure can be defined recursively (locally) as a collection of nodes (starting at a root node), where each node is a data structure consisting of a value, together with a list of references to nodes (the “children”), with the constraints that no reference is duplicated, and none points to the root. 递归一定要从大局入手，不要考虑细节，比如前序遍历，大局就是先访问根节点，再访问左子树，再访问右子树，可以立马能写出来代码。 广度优先搜索一般使用队列；深度优先搜索一般使用栈和递归方式。 所有代码见github-tree 参考Iterative Preorder Traversal Inorder Tree Traversal without Recursion Iterative Postorder Traversal | Set 2 (Using One Stack) 二叉树前序、中序、后序遍历非递归写法的透彻解析 二叉树的层次遍历]]></content>
      <tags>
        <tag>算法</tag>
        <tag>树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Windows Server 2016 计划任务优先级更改方法]]></title>
    <url>%2FWindows-Server-2016-%E8%AE%A1%E5%88%92%E4%BB%BB%E5%8A%A1%E4%BC%98%E5%85%88%E7%BA%A7%E6%9B%B4%E6%94%B9%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[遇到的问题 以交互方式运行程序的IO速度远快于以计划任务运行程序的IO速度 原因 计划任务默认的优先级为低于正常，IO速度会下降。 解决方式打开任务计划程序 创建任务 创建完成后，导出该任务为xml文件 编辑修改该xml文件的&lt;Priority&gt;7&lt;/Priority&gt;，将7改成正常的优先级(4-6)。优先级4将会使计划任务有和交互式程序一样的IO优先级和内存优先级；优先级5和6则会有较低的内存优先级。 在任务计划程序中删除刚才创建的任务。 在任务计划程序中导入修改好的任务xml文件创建计划任务。 参考Is there any way for a win2k8 scheduled task to have normal priority IO? TaskSettings.Priority]]></content>
      <tags>
        <tag>Windows</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[如何寻找N范围内的所有质数]]></title>
    <url>%2F%E5%A6%82%E4%BD%95%E5%AF%BB%E6%89%BEN%E8%8C%83%E5%9B%B4%E5%86%85%E7%9A%84%E6%89%80%E6%9C%89%E8%B4%A8%E6%95%B0%2F</url>
    <content type="text"><![CDATA[一、基本概念质数(prime number):指在大于1的自然数中，除了1和该数自身外，无法被其他自然数整除的数。 合数(composite number)：指在大于1的自然数中，因数除了1和其本身外具有另一因数的正整数。 0和1既不是质数也不是合数。 孪生素数：是指一对素数，它们之间相差2。例如3和5，5和7，11和13，10016957和10016959等等都是孪生素数。 约数：假如整数n除以m，结果是无余数的整数，那么我们称m就是n的约数。 自然数 N 的全部正约数个数以d(n)表示，若N=a1^n1 *a2^n2 …，其中a1,a2为质数，则d(n) = (n1+1)(n2+1)… ，对a1可以取a1^0 可以取 a1^1, a1^2…,所有a1因子有n1+1中选择，其他因子类似。 二、相关定理素数定理素数定理用于估计素数个数。对正整数x，小于等于x范围内的素数的个数π(x)≈x/lnx，误差一般不超过±15%。x越大误差越小。 算术基本定理算术基本定理，又称为正整数的唯一分解定理。每个大于1的自然数均可写为质数的积，而且这些素因子按大小排列之后，写法仅有一种方式。 三、测试素数1. 试除法（确定性算法）测试n是否为素数的最基本方法为试除法。此一程序将n除以每个大于1且小于等于n的平方根之整数m。若存在一个相除为整数的结果，则n不是素数；反之则是个素数。实际上，若n=ab是个合数（其中a与b≠1），则其中一个约数a或b必定至大为sqrt(n)。 2. 埃拉托斯特尼筛法埃拉托斯特尼筛法（sieve of Eratosthenes），简称埃氏筛，是一种简单且年代久远的筛法，用来找出一定范围内所有的素数。 所使用的原理是从2开始，将每个素数的各个倍数，标记成合数。一个素数的各个倍数，是一个差为此素数本身的等差数列。此为这个筛法和试除法不同的关键之处，后者是以素数来测试每个待测数能否被整除。 伪代码: 1234567891011Input: an integer n &gt; 1Let A be an array of Boolean values, indexed by integers 2 to n,initially all set to true.for i = 2, 3, 4, ..., not exceeding √n: if A[i] is true: for j = i^2, i^2+i, i^2+2i, i^2+3i, ..., not exceeding n: A[j] := falseOutput: all i such that A[i] is true. Java 代码： 1234567891011121314public boolean[] primes(int num) &#123; boolean[] isPrime = new boolean[num + 1]; for (int i = 2; i &lt;= num; i++) &#123; isPrime[i] = true; &#125; for (int i = 2; i*i &lt;= num; i++) &#123; if (isPrime[i]) &#123; for (int j = i*i; j &lt;= num; j+=i) &#123; isPrime[j] = false; &#125; &#125; &#125; return isPrime;&#125; 时间复杂度：O(nloglogn)。此种筛法会重复删除某个合数，比如30=2*15=3*10=5*6，会重复筛掉3次，这样会导致速度慢。解决方法是按照一个数的最小素因子筛选。 3. 欧拉筛法（线性筛法）基本思想：按照一个数的的最小素因子筛选。每个合数一定有几个素因子，一定有最小的一个素因子。最大素因子是唯一的，所以合数只会被它自己唯一的最素因子筛掉一次。 过程：当前数字是n=p1^a * p2^b * p3^c (p1 &lt; p2 &lt; p3)，一次循环筛掉小于等于p1素因子（根据构建的素数表）乘以n得到的数。比如p1之前有pi,pj和pk三个素数，则此次循环筛掉的数有 pi*n, pj*n, pk*n 和 p1*n。 从图上我们看到，第一列筛掉的是最小素因子是2的数，第二列筛掉的是最小素因子为3的数，依次类推，可以把所有的合数都筛掉，不会重复筛选。 比如30=2*15=3*10=5*6仅仅会根据15*2去筛掉。 Java 代码： 123456789101112131415161718192021public boolean[] primes(int num) &#123; boolean[] isPrime = new boolean[num + 1]; int[] primes = new int[num]; int cnt = 0; for (int i = 2; i &lt;= num; i++) &#123; isPrime[i] = true; &#125; for (int i = 2; i &lt;= num; i++) &#123; if (isPrime[i]) &#123; primes[cnt++] = i; &#125; for (int j = 0; j &lt; cnt &amp;&amp; i*primes[j] &lt;= num; j++) &#123; isPrime[i*primes[j]] = false; if (i % primes[j] == 0) &#123; break; &#125; &#125; &#125; return isPrime;&#125; 时间复杂度：O(n) 代码见：github max prime 4. 米勒拉宾检验（随机性算法）参考：求质数算法的 N 种境界1-试除法和初级筛法 线性筛法 wiki-Sieve of Eratosthenes 这只菜鸟总算搞懂了线性筛素数 数论——筛法求素数 线性筛法求素数 Sieve of Sundaram]]></content>
      <tags>
        <tag>算法</tag>
        <tag>数论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构-哈希表]]></title>
    <url>%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%93%88%E5%B8%8C%E8%A1%A8%2F</url>
    <content type="text"><![CDATA[一、前言查找的实质是确定关键码等于给定值的记录在查找集合中的存储位置。 由于存储位置与关键码之间不存在确定的对应关系，一般的查找方法是通过比较的方法找到要查询的记录。 若存储位置与关键码之间存在对应关系，则可以通过计算的方式来查找，这种方式就是散列技术. 二、基本概念 若关键字为 key，则其值存放在H(key)的存储位置上。由此，不需比较便可直接取得所查记录。称这个对应关系H为散列函数，按这个思想建立的表为散列表，也叫哈希表。 散列过程：①存储记录，通过H(key)计算记录的散列地址，并按此地址存储记录；②查找记录，通过同样的H(key)计算记录的散列地址，按此地址访问该记录。 现实中，对不同的关键字可能得到同一散列地址，即key1≠key2，而H(kye1)=H(key2)，则产生了冲突，针对冲突有多种解决方式。 哈希表的实现主要需要解决两个问题，哈希函数和冲突处理。 三、散列函数(哈希函数)哈希查找第一步就是使用哈希函数将键映射成索引。这种映射函数就是哈希函数。如果我们有一个保存0-M数组，那么我们就需要一个能够将任意键转换为该数组范围内的索引（0~M-1）的哈希函数。哈希函数需要易于计算并且能够均匀分布所有键。 1. 直接定址法取关键字或关键字的某个线性函数值为散列地址。H(key) = a * k + b 2. 除留余数法取关键字被某个不大于散列表表长m的数p除后所得的余数为散列地址。H(key) = key % p, p &lt;= m.其中p一般选取为小于或等于散列表长度m的某个最大素数。这种方法计算简单且效果好，因此最常用。 3. 数字分析法在已知所有关键码，并对每一位的取值分布有所分析的情况下，可以取关键字的若干数位（分布均匀的数位）组合成为哈希地址。 4. 平方取中法取关键字平方后的中间几位为哈希地址。通常在选定哈希函数时不一定能知道关键字的全部情况，取其中的哪几位也不一定合适，而一个数平方后的中间几位数和数的每一位都相关，由此使随机分布的关键字得到的哈希地址也是随机的。取的位数由表长决定。 5. 折叠法将关键码从左到右分割成位数相等（根据散列表长的位数决定）的若干部分，然后取他们的叠加并舍弃最高进位后的结果为哈希地址。 叠加的方法有两种： 移位叠加：将各部分相加。 间界叠加：从一端到另一端沿各部分分界来回折叠后相加，其中奇数段为正序，偶数段为倒序。 如key=25346358705，散列表长为三位数，则可以将关键码三位一分割，得到253,463,587,05。 移位叠加：(253+463+587+05) = 1308 舍弃最高进位得308。 间界叠加：(253+364+587+50) = 1254 舍弃最高进位得254。 这种方法适用于关键字的数字位数特别多的情况。 四、冲突处理尽管散列函数的目标是使得冲突最少，但实际上冲突是无法避免的。因此，我们必须研究冲突解决策略。 冲突处理实质上是为产生冲突的地址寻找下一个地址。 冲突处理的方法有以下几种： 1. 开放地址法(open addressing)当冲突发生时，使用某种方法在散列表中形成一个探测序列，沿着此探测序列逐个单元地查找，直到找到给定的关键码或者碰到一个开放的地址为止。 形成探测序列的方法不同，所得到的解决冲突的方法也不同。 哈希地址的计算公式为： H=(H(key) + di) % m 其中m为散列表的长度，di表示探测序列。 不同的di，会产生不同的探测法。 线性探测法，di=1,2,3,…,m-1。此种方法会造成聚集(cluster)现象，产生一次聚集。 平方探测法，di=1^2, 2^2, 3^2, …, k^2(k&lt;=m/2)。此种方法解决了线性探测法的一次聚集，但还是会产生二次聚集。 随机探测法，di是一组伪随机数列。 2. 链地址法(seperate chaining)将所有散列地址相同的记录都存储在一个单链表中，称为同义词子表。 如图所示： 链地址法优点：不会产生聚集现象；适合无法确定表长的情况；删除节点方便。 3. 公共溢出法公共溢出法的基本思想是散列表包含基本表和溢出表两个部分，将发生冲突的记录存储在溢出表中。对应的查找方法是通过散列函数计算散列地址，先与基本表进行比较，若相等，则查找成功；否则，到溢出表中顺序查找。 4.双散列法 Double Hashing is works on a similar idea to linear and quadratic probing. Use a big table and hash into it. Whenever a collision occurs, choose another spot in table to put the value. The difference here is that instead of choosing next opening, a second hash function is used to determine the location of the next spot. For example, given hash function H1 and H2 and key. do the following: Check location hash1(key). If it is empty, put record in it.If it is not empty calculate hash2(key). Check if hash1(key)+hash2(key) is open, if it is, put it in repeat with hash1(key)+2hash2(key), hash1(key)+3hash2(key) and so on, until an opening is found. like quadratic probing, you must take care in choosing hash2. hash2 CANNOT ever return 0. hash2 must be done so that all cells will be probed eventually. 5.再散列法即在上次散列计算发生冲突时，利用该次冲突的散列函数地址产生新的散列函数地址，直到冲突不再发生. 五、哈希表的性能影响冲突的因素有： 散列函数是否均匀 处理冲突的方法 散列函数的装填因子(负载因子)a，即 a=填入表中的元素的个数/散列表的长度，a与表中的元素的个数成正比，表征了哈希表装满程度。a越大，表中的元素越多，产生的冲突可能性就越大。 参考：Collision Resolution YouTube-CS50-Hash Tables YouTube-Hashing Technique - Simplified YouTube-Hash Tables and Hash Functions]]></content>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构-栈和队列]]></title>
    <url>%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97%2F</url>
    <content type="text"><![CDATA[一、栈栈 (Stack)是一种后进先出(last in first out，LIFO)的数据结构。栈只允许在一端进行操作。 栈的操作栈是一种抽象数据类型(ADT),其上的操作有: Stack() 创建空栈 void push(T x) 向栈中添加元素 T pop() 从栈顶弹出数据 T peek() 仅查看栈顶元素，并不弹出 boolean isEmpty() 判断栈是否为空。 以上这些操作的时间复杂度要满足O(1)的约束。 栈的实现栈的实现方式有两种：采用数组或链表实现。 数组实现Java官方库中有个Stack类（但不推荐，因为它是遗留下来的，不属于集合类中，建议使用Deque实现栈的操作），其采用的就是数组实现。 数组实现要注意动态Resize，当栈满的时候扩充容量，当栈较空的时候缩小容量。有一个top指明了当前栈顶元素所在位置，当top=-1时，栈为空。 实现见 github ArrayStack 链表实现栈也可以采用单链表实现，push和pop操作只要在链表头进行操作即可满足O(1)的约束。无论采取何种方式实现，只要满足以上ADT的约束（即实现这些操作，并使这些操作的时间复杂度为O(1))，则为Stack。 实现见 github LinkedListStack 参考：浅谈算法和数据结构: 一 栈和队列 纸上谈兵: 栈 (stack) YouTube - Array implementation of Stack 二、队列队列 (Queue)是一种先进先出(first in first out，FIFO)的数据结构。队列只允许在后端（称为rear）进行插入操作，在前端（称为front）进行删除操作。 队列的操作队列是一种抽象数据类型(ADT),其上的操作有: Queue() 创建空队列 void enqueue(T x) 向队列中添加元素 T dequeue() 从队列中出列一个数据 T front() 仅查看队列的头元素，并不出列 boolean isEmpty() 判断队列是否为空。 以上这些操作的时间复杂度要满足O(1)的约束。无论采取何种方式实现，只要满足以上ADT的约束（即实现这些操作，并使这些操作的时间复杂度为O(1))，则为Queue。 队列的实现队列的实现方式有两种：采用数组或链表实现。 数组实现Java官方库中有个ArrayBlockingQueue类，其采用的就是数组实现。 数组实现中有两个指针，head和tail，分别指向队列头和尾。初始时head=tail=-1。 实现见 github ArrayQueue 链表实现队列也可以采用单链表实现，要有两个指针，head和tail指针分别指向对头和对尾。 实现见 github LinkedListQueue 参考：The Queue Abstract Data Type YouTube - Array implementation of Queue 数据结构（三）——队列及实现、循环队列实现 java数据结构与算法之（Queue）队列设计与实现 三、双端队列双端队列（deque，全名double-ended queue）是一种同时具有队列和栈性质的数据结构。双端队列中的元素可以从两端弹出，插入和删除操作限定在队列的两边进行。 在Java中实现了Deque，有两个重要的实现子类，ArrayDeque和LinkedList。ArrayDeque是采用数组实现的双端队列，LinkedList是采用链表实现的双端队列。 建议使用栈时，用ArrayDeque或者LinkedList的push和pop方法；使用队列时，使用ArrayDeque或者LinkedList的add和remove方法。 参考：java 中的Stack、Queue、Deque Wiki-Deque 深入理解循环队列—-循环数组实现ArrayDeque Java 数据结构之Deque(双向队列)]]></content>
      <tags>
        <tag>算法</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[算法问题-约瑟夫问题]]></title>
    <url>%2F%E7%AE%97%E6%B3%95%E9%97%AE%E9%A2%98-%E7%BA%A6%E7%91%9F%E5%A4%AB%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[约瑟夫问题是一个非常著名的趣题，即由n个人坐成一圈，按顺时针由1开始给他们编号。然后由第一个人开始报数，数到m的人出局。现在需要求的是最后一个出局的人的编号。 给定两个int n和m，代表游戏的人数。请返回最后一个出局的人的编号。保证n和m小于等于1000。 测试样例： 5 3 返回: 4 一、单循环链表法构建单循环链表，遇到被kill的编号则删除节点，直到最后留下一个节点。此种方法较为简单直接，不作具体展开。 时间复杂度：O(n*m) 二、递推法初始情况：0,1,2,3,4…,n-1(共n个人)，0为第一个人的编号 第一个被kill的人的编号是 (m-1) % n，分析过程如下： 当m &lt;= n 时，比如m=3，n=5，则第一个被kill的编号为0，即 (m-1)%n 当m &gt; n 时，比如m=3, n=2，则第一个被kill的编号为0，即 (m-1)%n 设第一个被kill的人编号为k, k = (m-1) % n，则第二次报数从k+1开始，剩下的构成了n-1人的约瑟夫环。 k+1 -&gt; 0 k+2 -&gt; 1 n-1 -&gt; n-k-2 … 0 -&gt; n-k-1 1 -&gt; n-k … k-1 -&gt; n-2 右边即为n-1的约瑟夫环问题了，求出n-1的约瑟夫的幸存者编号x0，则可以由上面的关系来逆推得到n的约瑟夫环问题的编号x， x = (x0 + k + 1) % n = (x0 + m) % n。 设初始问题的解为f(n, m)，子问题的解为f(n-1, m)，则有以下递推式： f(n, m) = (f(n-1, m) + m) % n f(1, m) = 0 特别地，当m=2时， 若n=2^a + t f(n, 2) = 2*t 当编号由1开始时，递推式变成： f(n, m) = (f(n-1, m) + m - 1) % n + 1 f(1, m) = 1 f(n, 2) = 2*t + 1 注：比如当n = 5, m = 5时，第一个被kill的编号为5，是(m-1) % n + 1，内部式子减掉1，取余后再加1即可得到5。 代码实现见 github： 迭代版 12345678910public class Joseph &#123; public int getResult(int n, int m) &#123; if (n &lt; 1 || m &lt; 1) return -1; int last = 1; for (int i = 2; i &lt;= n; i++) &#123; last = (last + m - 1) % i + 1; &#125; return last; &#125;&#125; 递推版 12345678public class Joseph &#123; public int getResult(int n, int m) &#123; // write code here if (n &lt; 1 || m &lt; 1) return -1; if (n == 1) return 1; return (getResult(n - 1, m) + m - 1) % n + 1; &#125;&#125; 时间复杂度: O(n)，空间复杂度：O(1) 参考： What is the best solution for Josephus problem algorithm? Youtube - 约瑟夫问题(m=2) Wiki - Josephus problem 动态规划解决约瑟夫环问题 约瑟夫问题的两个O(log n)解法 Explanation for recursive implementation of Josephus prob]]></content>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构-数组和链表]]></title>
    <url>%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%95%B0%E7%BB%84%E5%92%8C%E9%93%BE%E8%A1%A8%2F</url>
    <content type="text"><![CDATA[数据存储结构数据元素在计算机存储器的方式主要有两种： 顺序存储，一般使用数组。 链式存储，一般使用链表。 数组数组是一种最基本的数据结构，它是一种物理存储单元上连续、顺序的存储结构，数据元素的逻辑顺序是通过数组的索引次序实现的。 时间复杂度： Access: O(1) Delete: O(n) Insert: O(n) 优点：查找访问速度快。缺点：不能适应动态数据增减；插入和删除操作速度慢。 链表链表是一种最基本的数据结构，它是一种物理存储单元上非连续、非顺序的存储结构，数据元素的逻辑顺序是通过链表中的指针链接次序实现的。 链表由一系列结点（链表中每一个元素称为结点）组成，结点可以在运行时动态生成。每个结点包括两个部分：存储数据元素的数据域，存储下一个结点地址的指针域。 123456789101112131415161718192021222324252627public class Node &#123; private int data; private Node next; Node() &#123; &#125; Node(int data) &#123; this.data = data; &#125; public void setData(int data) &#123; this.data = data; &#125; public void setNextNode(Node nextNode) &#123; this.next = nextNode; &#125; public int getData() &#123; return this.data; &#125; public Node getNextNode() &#123; return this.next; &#125;&#125; 时间复杂度： Access: O(n) Delete: O(1) Insert: O(1) 优点：能适应动态数据增减，新添加的节点可以动态申请内存，对内存的利用率高；插入和删除操作速度快。缺点：由于要存储指针域，空间占用大；查找访问速度慢。 链表按链表方式分为： 单链表：只有一个next指针域。一般有个头指针指向链表中第一个结点，为了操作的统一与方便，设立了，放在第一个元素结点之前，其数据域一般无意义。实现见github singly linked list 双链表：有next指针域和prev指针域。克服了单链表查找前驱节点时间复杂度为O(n)的缺点。 循环链表：最后一个结点的指针域指向头结点，整个链表形成一个环。用尾指针rear表示的单循环链表对开始结点a1和终端结点an查找时间都是O(1)，如果仅用头指针来表示的话，查找到终端节点需要O(n)。表的操作常常是在表的首尾位置上进行，因此，实用中多采用尾指针表示单循环链表。循环链表可以解决约瑟夫问题。 链表按实现方式分为： 动态链表(使用指针或引用的方式实现) 静态链表(使用数组和游标实现) 扩展-链表相关问题静态链表静态链表相当于是用一个数组来实现线性表的链式存储结构，在静态链表中操作的是数组。 静态链表的数组元素也有数据域和指针域，只不过指针域是int型，表示下一个元素在数组中的索引，也可以称之为游标。 1234private static class Node&lt;E&gt; &#123; E data; int next; //下一个结点所在的数组下标&#125; 数组第一个元素和最后一个元素为特殊元素，数据域不存数据，第一个元素的指针域(cur)存放的是第一个空间可用元素(元素为空)的下标，最后一个元素的指针域(cur)存放的是实际数据的首元素的下标(类似于动态链表front-&gt;next)。 实现见github static linked list 参考： 数据结构与算法–静态链表 静态链表（游标实现法） 使用递归方法反向单链表1234567891011public Node reverse(Node node) &#123; if (node == null || node.getNext() == null) &#123; front.setNext(node); return; &#125; reverse(node.getNext()); node.getNext().setNext(node); node.setNext(null);&#125; 针对递归方式，要弄清楚最后一次end condition，以及递归返回以后要做什么操作。 参考：YouTube-Reverse a linked list - Reverse a linked list using recursion 使用非递归方法反向单链表123456789101112131415161718public void reverse() &#123; if (front.getNext() == null) &#123; return; &#125; Node prev = null; Node curr = front.getNext(); Node next; while (curr != null) &#123; next = curr.getNext(); curr.setNext(prev); prev = curr; curr = next; &#125; front.setNext(prev);&#125; 参考：YouTube-Reverse a linked list - Iterative method 检查链表是否有环使用龟兔赛跑模型：如果是一条直线，兔子永远会跑在前面；如果兔子发现又追上乌龟了，那么只能是兔子套了乌龟一圈。 算法逻辑如下： 指针hare初始化指向链表头结点，每次向后移动2个节点。 指针tortoise初始化指向链表头结点，每次向后移动1个节点。 如果hare最终指向尾节点或尾节点前一个节点（总结点数可能是奇数也可能是偶数），则该链表无圈。 如果hare和tortoise又指向了同一个节点，则该链表有圈。 1234567891011121314151617181920212223242526272829303132333435// Floyd's cycle-finding algorithmpublic boolean isCyclic() &#123; Node tortoise = front; Node hare = front; while (hare != null &amp;&amp; hare.getNext() != null) &#123; tortoise = tortoise.getNext(); hare = hare.getNext().getNext(); if (tortoise == hare) &#123; return true; &#125; &#125; return false;&#125;// Brent's Cycle Detection Algorithmpublic boolean isCyclic2() &#123; Node tortoise = front; Node hare = front; int taken = 0; int limit = 2; while (hare != null) &#123; hare = hare.getNext(); taken++; if (hare == tortoise) &#123; return true; &#125; if (taken == limit) &#123; taken = 0; limit &lt;&lt;= 1; tortoise = hare; &#125; &#125; return false;&#125; 参考： wiki-Cycle detection How to detect a loop in a linked list? Brent’s Cycle Detection Algorithm (The Teleporting Turtle 使用单向循环链表解决约瑟夫问题 其他参考： CSDN 数组、链表、堆栈和队列 cnblogs 数组、链表、栈、队列和STL 时间复杂度分别为 O（n）和 O（1）的删除单链表结点的方法 结构之美：单链表的头结点与头指针 用链表的目的是什么？省空间还是省时间？ LeetCode #141 Linked List Cycle How to Find if Linked List contains Loops or Cycles in Java How to reverse a singly linked list in Java 单循环链表中设置尾指针比设置头指针更好的原因]]></content>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构和算法基本概念]]></title>
    <url>%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5%2F</url>
    <content type="text"><![CDATA[算法 + 数据结构 = 程序 一、数据结构数据结构是指数据的逻辑结构和存储结构。数据结构是按照某种逻辑关系组成的一组数据，并按一定的存储方式存储在计算机的存储器中，并在这些数据上定义了一组运算的集合。 数据结构有三要素：数据逻辑结构、数据存储结构、数据的运算。 逻辑结构逻辑结构：数据元素之间的存储关系。 集合结构 集合结构:数据元素除了同属于一个集合外,他们之间没有其他关系。 线性结构 数据元素之间的关系是一对一的关系。 线性表 栈 队列 串 非线性结构 数据元素之间的关系是一对多或多对多的关系。 树 图 多维数组 堆 存储结构存储结构：数据元素及其关系在计算机存储器内的存储形式。 顺序存储结构：逻辑上相邻的节点存储在物理位置上相邻的存储单元中。通常以数组的形式存储，但是静态链表由于相邻的节点并不一定存储在物理位置相邻的存储单元中，所以不是顺序存储结构，还是一个链式存储结构。 链式存储结构：任意的存储单元存储线性表的数据元素，每个结点由数据域和指针域组成。 索引存储结构：在存储元素信息的同时，还建立附加的索引表。索引表中的每一项称为索引项，索引项的一般形式是：（关键字，地址）。 散列存储结构：根据元素的关键字直接计算出该元素的存储地址，又称为Hash存储。 用顺序存储结构存储的线性表称为顺序表。 用链式存储结构存储的线性表称为链表。 其他逻辑结构都可以采用两种不同的存储结构来实现，比如栈既可以用数组实现，也可以用链表实现，区别就在于数组需要固定大小，而链表则可以动态添加。` 链表按实现方式可分为：静态链表和动态链表。 链表按链接方式可分为：单链表、双链表和循环链表。 抽象数据类型(ADT)抽象数据类型（Abstract Data Type，ADT）是计算机科学中具有类似行为的特定类别的数据结构的数学模型；或者具有类似语义的一种或多种程序设计语言的数据类型。抽象数据类型是间接定义的，通过其上的可执行的操作以及这些操作的效果的数学约束（与可能的代价）。 对于用户来说只关心数据模型和在其上的操作，并不关心如何实现，如何存储的。比如Stack,它仅能在一端进行添加数据和取出数据的操作(LIFO),有init, push, pop, top, isEmpty等操作。 粗略地说， 抽象数据类型=逻辑结构+操作 在Java中通过接口来表示抽象数据类型，接口的实现来表示抽闲数据类型的实现。 参考: 「数据结构」和「数据类型」两个概念的本质是什么，区别与联系 数据类型和常用数据结构 二、算法算法是指对数据的操作方法的描述。]]></content>
      <tags>
        <tag>算法</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[非比较排序算法：计数排序、基数排序和桶排序]]></title>
    <url>%2F%E9%9D%9E%E6%AF%94%E8%BE%83%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%EF%BC%9A%E8%AE%A1%E6%95%B0%E6%8E%92%E5%BA%8F%E3%80%81%E5%9F%BA%E6%95%B0%E6%8E%92%E5%BA%8F%E5%92%8C%E6%A1%B6%E6%8E%92%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[计数排序计数排序的思想：对每一个输入元素，计算小于等于它的元素个数，如果有10个元素小于等于它，那么它就应该放在11的位置上，如果有17个元素小于等于它，它就应该放在18的位置上。 计数排序的过程： 找出待排序的数组中最大和最小的元素 统计数组中每个值为i的元素出现的次数，存入数组 C 的第 i 项（如果min &gt; 0， 则存入数组 C 的第 i - min 项，下同） 对所有的计数累加（从C中的第一个元素开始，每一项和前一项相加） 反向填充目标数组：将每个元素i放在新数组的第C(i)项，每放一个元素就将C(i)减去1，原来数组后面的先放，这样就保证了稳定性。 复杂度： 时间复杂度：O(n+k)， n是输入数据的个数，k是输入数据的范围大小 空间复杂度: O(n+k)， n是输入数据的个数，k是输入数据的范围大小 当输入数据的范围大小超过n时，计数排序就不合适了，计数排序适用于小范围的整数序列的排序。 算法实现见:github counting sort 计数排序参考： YouTube-CountingSort Why can’t we use count sort as a general purpose sorting algorithm? 基数排序基数排序（Radix sort)是把每一位用计数排序来排序（由低位到高位排序，每次排序得到一个中间结果，然后用这个中间结果继续排序，直到所有位都排序完得到最终结果），解决了计数排序范围大时时间复杂度和空间复杂度都大的问题。 为什么要从低位开始向高位排序? 如果要从高位排序, 那么次高位的排序会影响高位已经排好的大小关系. 在数学中, 数位越高,数位值对数的大小的影响就越大.从低位开始排序,就是对这种影响的排序. 数位按照影响力从低到高的顺序排序, 数位影响力相同则比较数位值。 其实，也是可以从高位开始排序，算法为MSD Radix sort。过程： 获取每个key的最大位。 根据最大位排序，并将相同位的数据放在一个bucket中。 根据下一位递归的排序每一个bucket。 将所有的bucket组合按顺序输出即可。 复杂度： 时间复杂度：O(d(n+k))， n是输入数据的个数，d是最大数字位数，k是每一位的数据范围大小 空间复杂度: O(n+k)，n是输入数据的个数, k是每一位的数据范围大小 算法实现见:github radix sort 基数排序参考: YouTube-Radix Sort-step by step guide 维基百科-基数排序 YouTube-MSD radix sort 桶排序桶排序的过程： 将输入数据划分到N个桶中(多少个桶由自己决定)，即将min~max分成N份（最好能差不多均匀分布）。 对这N个桶分别进行插入排序。 遍历每个桶，按照次序把各个桶的元素列出来。 伪代码： 1234567function bucketSort(array, n) is buckets ← new array of n empty lists for i = 0 to (length(array)-1) do insert array[i] into buckets[msbits(array[i], k)] for i = 0 to n - 1 do nextSort(buckets[i]); return the concatenation of buckets[0], ...., buckets[n-1] 当每个桶的数据范围大小为1时，则为鸽巢排序。当数据分布很不均匀时，时间复杂度有可能是O(n^2)。 桶排序参考： YouTube-Bucket Sort-step by step guide YouTube-Bucket sort YouTube-Pigeonholes sort 总结：以上三种排序算法虽然能在线性时间内排序，但是需要额外的空间，并且输入要满足一定的条件，比如计数排序要求输入满足整数才可以，桶排序则需要输入数据满足均匀分布，因此大部分情况下都是采用的基于排序的O(nlogn)的排序算法如快速排序。]]></content>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构-堆]]></title>
    <url>%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%A0%86%2F</url>
    <content type="text"><![CDATA[堆是计算机科学中一类特殊的数据结构的统称。堆又被称为优先队列，普通的队列是先进先出，堆是最小或最大(分别对应最小堆和最大堆)先出。 n个元素序列{k1,k2…ki…kn},当且仅当满足下列关系时称之为堆：(ki &lt;= k2i,ki &lt;= k2i+1)或者(ki &gt;= k2i,ki &gt;= k2i+1), (i = 1,2,3,4…n/2) 堆的性质堆的实现是完全二叉树，实现的堆称为二叉堆。其具有以下性质: 父节点大于所有子节点(最大堆，大根堆)或者父节点小于所有子节点(最小堆，小根堆) 堆总是一棵完全树。即除了最底层，其它层的节点都被元素填满，最底层尽可能地从左到右填入。 应用场景重要有两个： 堆排序 优先队列 堆的操作堆的操作主要有两个(其他的比如创建空堆，重构堆等操作则是辅助操作)： 删除操作(删除操作只能删除根节点) 插入操作 这两个操作都涉及到了堆的重构，因为它们都破坏了堆的结构。本文暂时以小根堆来讲解这些操作。 针对删除操作的重构方式：删掉根节点后，会有两个子树，将最后一个节点放到根节点的位置，然后不断的跟子节点比较，如果大于小的那个子节点，则交换两者，递归这个过程，直到下沉的节点不再大于任一子节点或者成为了叶节点。 针对插入操作的重构方式：新插入的节点放在完全二叉树最后的位置（数组的末尾）。再和父节点进行比较，如果小于父节点，这父节点交换，递归调用此过程直至不小于父节点或成为根节点。 堆的实现堆通常以数组的形式实现，位置k的节点的父节点的位置为k/2向下取整(可以使用右移一位表示)，而它的两个子节点的位置分别为2k和2k+1。为方便这样计数，简化计算，一般根节点是放在k=1的位置，堆的表示中不使用a[0]。 具体实现代码见 github 总结堆有两种主要操作：插入元素和删除根节点。堆一般用数组实现。 扩展阅读优先队列优先队列是计算机科学中的一类抽象数据类型。优先队列中的每个元素都有各自的优先级，优先级最高的元素最先得到服务；优先级相同的元素按照其在优先队列中的顺序得到服务。优先队列往往用堆来实现。 优先队列有两种实现： 初级实现 堆实现 初级实现采用有序数组或者无序数组来实现。有序数组插入操作时间复杂度为O(n)，删除操作为O(1)；无序数组插入操作时间复杂度为O(1)，删除操作为O(n)。 堆实现则使插入和删除操作的时间复杂度为O(logn)。 因此优先队列常使用堆来实现。 堆排序堆排序（Heapsort）是指利用堆这种数据结构所设计的一种排序算法。 在堆的数据结构中，堆中的最大值总是位于根节点(在优先队列中使用堆的话堆中的最小值位于根节点)。堆中定义以下几种操作： 最大堆调整（Max_Heapify）：将堆的末端子节点作调整，使得子节点永远小于父节点 创建最大堆（Build_Max_Heap）：将堆所有数据重新排序 堆排序（HeapSort）：移除位在第一个数据的根节点，交换到数组的末尾，并做最大堆调整的递归运算。 具体实现代码见 github 性能： 最优时间复杂度：O(nlogn) 最坏时间复杂度：O(nlogn) 平均时间复杂度：O(nlogn) 空间复杂度: O(1) 不稳定。 参考： 纸上谈兵: 堆 (heap) Youtube-堆 数据结构系列——堆 维基百科-堆) 维基百科-优先队列]]></content>
      <tags>
        <tag>算法</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo中如何插入图片]]></title>
    <url>%2FHexo%E4%B8%AD%E5%A6%82%E4%BD%95%E6%8F%92%E5%85%A5%E5%9B%BE%E7%89%87%2F</url>
    <content type="text"><![CDATA[Hexo有多种方式插入图片，以下讲解其中三种方式。 一、通过Markdown语法引用将图片 example.jpg 放在 source/images 目录下，在文章的md文件中插入 ![](/images/example.jpg) 即可。 这种方法针对的是在hexo整个项目中有少量的图片的情况，且 _config.yml 中 post_asset_folder 必须为 false 才能引用。 二、通过标签插件引用在hexo3中，新的标签插件被加入到了核心代码里，此时可以采用标签插件引用来插入图片，这样的好处在于图片资源管理较为方便。 设置_config.yml 中 post_asset_folder 为 true 可以使每一次hexo new post postname都创建一个postname的文件夹和postname.md的文件。 把图片 example.jpg 放到postname文件夹中，然后在md文件里使用下面方式引用： {% asset_img example.jpg This is an example image %} 三、CDN引用将图片上传到一些免费的CDN服务中。上传完图片后会生成对应的url，直接引用url即可插入图片。 图片测试： 参考: Hexo官方文档-Asset资源文件夹]]></content>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[GitHub+Hexo搭建博客]]></title>
    <url>%2FGitHub%2BHexo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%2F</url>
    <content type="text"><![CDATA[一、创建github page在github.com上新建repository，repository的名字是 username.github.io ，比如我在github上的用户名是limitless083，因此新建的repository名字为 limistless083.github.io 二、安装Hexo的依赖Hexo依赖下列应用程序： Git Node.js Git 用来将生成的网页部署到github上。 Node 则用来生成网页。 三、安装Hexo执行以下命令即可 $ npm install -g hexo-cli 前三部分参考: Hexo官方安装文档 四、部署Hexo应用在自己创建的文件夹比如my_blog文件夹内用命令行执行以下命令 123hexo init # 初始化hexo新项目npm install # 安装依赖npm install hexo-deployer-git --save # 安装git依赖 更新_config.yml中配置，修改为： 123deploy:- type: git repo: git@github.com:limitless083/limitless083.github.io.git 清空旧文件: hexo clean部署：hexo deploy 本部分可以参考: Hexo官方部署文档 五、更改主题hexo 主题有很多，其中最出名的是NexT主题，该主题有详细的文档设置，可以参考NexT官方文档 结语以上就是一些大概的流程介绍，Hexo官方文档和NexT官方文档解释的都比较详细，在此就不再赘述了。]]></content>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[执行inotifywait过程出现upper limit on inotify watches reached的解决方式]]></title>
    <url>%2F%E6%89%A7%E8%A1%8Cinotifywait%E8%BF%87%E7%A8%8B%E5%87%BA%E7%8E%B0upper%20limit%20on%20inotify%20watches%20reached%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[遇到的问题 执行inotifywait过程中出现upper limit on inotify watches reached 解决方式增加/proc/sys/fs/inotify/max_user_watches /proc/sys/fs/inotify/max_user_watches 表示每个inotify instatnces可监控的最大目录数量，在相关知识部分可以了解一下inotify。 解决步骤 检查一下inotify watches的最大值 1cat /proc/sys/fs/inotify/max_user_watches 设置inotify watches(以root权限) 12345678# 临时的sysctl fs.inotify.max_user_watches=81960# 永久的vi /etc/sysctl.conf添加 fs.inotify.max_user_watches=81960# 重新加载sysctl配置sysctl -p 相关知识sysctlsysctl命令被用于在内核运行时动态地修改内核的运行参数，可用的内核参数在目录/proc/sys中 常见用法: sysctl -a 列出所有可读变量 sysctl variable=value 设置指定变量(临时的,若要永久的可以更改/etc/sysctl.conf文件) sysctl -p 从配置文件“/etc/sysctl.conf”加载内核参数设置 参考：Linux命令大全-sysctl命令 inotifyInotify为Linux提供了一套高效监控和跟踪文件变化的机制，可以监控文件系统的访问属性、读写属性、权限属性、删除创建、移动等操作，也就是可以监控文件发生的一切变化，它采用的是事件驱动机制，不是轮询机制。 在Linux中提供了inotify-tools，该工具包含了两个命令inotifywait和inotifywatch,分别用来收集有关文件访问信息和关于被监视的文件系统的统计信息。 常见用法： inotifywait -mrq --timefmt &#39;%d/%m/%y/%H:%M&#39; --format &#39;%T %w %f&#39; -e create /dir 监听目录创建文件的事件。 参考: Linux命令大全-inotifywait Inotify: Efficient, Real-Time Linux File System Event Monitoring rsyncrsync是一个远程数据同步工具，可通过LAN/WAN快速同步多台主机间的文件。它使用所谓的“Rsync演算法”来使本地和远程两个主机之间的文件达到同步，这个算法只传送两个文件的不同部分，而不是每次都整份传送，因此速度相当快。所以通常可以作为备份工具来使用。 rsync的不足之处：rsync同步数据时，需要扫描所有文件后进行比对，进行差量传输。如果文件数量达到了百万甚至千万量级，扫描所有文件将是非常耗时的。因此常常使用rsync+inotify组合来实时同步数据。 常见用法: rsync -a /data /backup 从/data目录同步文件到/backup目录 rsync -v rsync://192.168.78.192/www 列远程机的文件列表。 参考: Linux命令大全-rsync]]></content>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux命令:find, grep和xargs的爱恨情仇]]></title>
    <url>%2FLinux%E5%91%BD%E4%BB%A4-find%2C%20grep%E5%92%8Cxargs%E7%9A%84%E7%88%B1%E6%81%A8%E6%83%85%E4%BB%87%2F</url>
    <content type="text"><![CDATA[find命令用来在指定目录下查找文件。 grep命令用来正则匹配，搜索文本，找到匹配的行并打印出来。全称是global search regular expression and print out the line。 xargs命令将参数列表转换成小块分段传递给其他命令，以避免参数列表过长的问题，一般是管道输出给xargs。 findfind的常见用法： 列出当前目录及子目录下所有文件和文件夹 find . 在”/home”目录下查找以.txt结尾的文件 find /home -name “*.txt” 在”/home”目录下查找不是以.txt结尾的文件 find /home ! -name “*.txt” 根据文件类型查找 find . -type 类型参数 类型参数有: f 普通文件l 符号链接d 目录c 字符设备b 块设备s 套接字p fifo 根据文件大小进行匹配, 搜索大于10k的文件 find . -type f -size +10k 根据权限进行匹配 find . -type f -perm 777 查找所有空文件 find . -empty 其他的详细的可以参考man find grepgrep的常见用法： 在文件中搜索一个单词，命令会返回一个包含”match_pattern”的文本行 grep “match_pattern” file 等同于 cat file | grep “match_pattern” 递归搜索文件 grep “text” . -r 在grep搜索结果中包括或者排除指定文件 只在目录中所有的.php和.html文件中递归搜索字符”main()” grep “main()” . -r –include *.{php,html} 在搜索结果中排除所有README文件grep “main()” . -r –exclude “README” 在搜索结果中排除filelist文件列表里的文件 grep “main()” . -r –exclude-from filelist 显示匹配某个结果的之前或之后的行，-A(after),-B(before),-C(context) cat file | grep “haha” -A 3 其他的详细的可以参考man grep xargsxargs的常见用法: xargs用作替换工具，读取输入数据重新格式化后输出 cat test.txt 输出： a b c d e f cat test.txt | xargs 输出： a b c d e f 删除最近的5个文件 ls -t | head -5 | xargs rm -rf 统计一个源代码目录中所有erlang文件的行数: find . -type f -name “*.erl” | xargs wc -l 其他的详细的可以参考man xargs]]></content>
  </entry>
  <entry>
    <title><![CDATA[How can I increase open files limit]]></title>
    <url>%2FHow-can-I-increase-open-files-limit%2F</url>
    <content type="text"><![CDATA[步骤 Use the following command command to display maximum number of open file descriptors cat /proc/sys/fs/file-max 6508886 To see the hard and soft values, issue the command as follows ulimit -Hn 4096 ulimit -Sn 1024 open the sysctl.conf and add this line fs.file-max = 65536, 65536 can be other number. vi /etc/sysctl.conf add new line: fs.file-max = 65536 modify /etc/security/limits.conf according to limits.conf man-page add user limit configuration, for example, for user cold: vi /etc/security/limits.conf add new line: cold - nofile 500000 500000 should be lower than file-max exit user and relogin 参考How can I increase open files limit for all processes? Linux Increase The Maximum Number Of Open Files / File Descriptors limits.conf man-page On Linux - set maximum open files to unlimited. Possible?]]></content>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
